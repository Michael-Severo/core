/** Folder layout
 * cmd: npx directory-tree-ascii . -b node_modules .git

> core@2.0.0 npx
> daa . -b node_modules .git

```
└─ .
   ├─ dev
   │  ├─ current_code.txt
   │  ├─ docs
   │  │  ├─ dev_manual.md
   │  │  └─ dev_technical.md
   │  └─ tools
   │     └─ combined.js
   ├─ package-lock.json
   ├─ package.json
   └─ src
      └─ core
         ├─ common
         │  ├─ ErrorUtils.js
         │  ├─ SystemConstants.js
         │  ├─ index.js
         │  └─ utilities_and_definitions.md
         ├─ container
         │  ├─ ContainerSystem.js
         │  ├─ container-system.md
         │  └─ index.js
         ├─ core_architecture.md
         ├─ errors
         │  ├─ CoreError.js
         │  ├─ ErrorCodes.js
         │  ├─ ErrorSystem.js
         │  ├─ error-system.md
         │  ├─ index.js
         │  ├─ integrations
         │  │  ├─ IFrameworkIntegration.js
         │  │  ├─ fastify
         │  │  │  ├─ FastifyErrorHandler.js
         │  │  │  ├─ FastifyErrorSerializer.js
         │  │  │  └─ index.js
         │  │  └─ index.js
         │  └─ types
         │     ├─ AccessError.js
         │     ├─ AuthError.js
         │     ├─ ConfigError.js
         │     ├─ EventError.js
         │     ├─ ModuleError.js
         │     ├─ NetworkError.js
         │     ├─ RouterError.js
         │     ├─ ServiceError.js
         │     ├─ ValidationError.js
         │     └─ index.js
         ├─ event
         │  ├─ CoreEventBus.js
         │  ├─ EventBusSystem.js
         │  ├─ eventbus-system.md
         │  └─ index.js
         ├─ module
         │  ├─ CoreModule.js
         │  ├─ ModuleSystem.js
         │  ├─ index.js
         │  └─ module-system.md
         └─ router
            ├─ CoreRouter.js
            ├─ RoutableModule.js
            ├─ RouterSystem.js
            ├─ index.js
            ├─ integrations
            │  ├─ IRouterAdapter.js
            │  ├─ fastify
            │  │  ├─ FastifyAdapter.js
            │  │  └─ index.js
            │  └─ index.js
            └─ router-system.md

```
*/


// src/core/common/ErrorUtils.js

/**
 * @file ErrorUtils.js
 * @description Shared utility functions for error handling.
 */

/**
 * Safely handles an error by attempting to forward it to the ErrorSystem.
 * If ErrorSystem is unavailable or fails, it logs the error to the console.
 *
 * @param {object|null|undefined} errorSystem - The ErrorSystem instance.
 * @param {Error} error - The error object to handle.
 * @param {object} [context={}] - Additional context for the error.
 * @returns {Promise<void>}
 */
export async function safeHandleError(errorSystem, error, context = {}) {
  const source = context.source || 'UnknownSystem';

  if (!errorSystem || typeof errorSystem.handleError !== 'function') {
    console.error(
      `[${new Date().toISOString()}] Unhandled error in ${source} (ErrorSystem unavailable/invalid):`,
      {
        errorCode: error.code,
        errorMessage: error.message,
        errorDetails: error.details,
        errorCause: error.cause,
        context,
        stack: error.stack
      }
    );
    return;
  }

  try {
    await errorSystem.handleError(error, context);
  } catch (forwardingError) {
    console.error(
      `[${new Date().toISOString()}] Failed to forward error from ${source} to ErrorSystem:`,
      {
        originalErrorCode: error.code,
        originalErrorMessage: error.message,
        forwardingErrorCode: forwardingError.code,
        forwardingErrorMessage: forwardingError.message,
        context,
        originalErrorStack: error.stack,
        forwardingErrorStack: forwardingError.stack
      }
    );
  }
}

/**
 * Creates a standardized health check result object.
 *
 * @param {string} status - The health status (e.g., SYSTEM_STATUS.HEALTHY).
 * @param {object} [detail={}] - Specific details for this health check.
 * @param {Array<Error>} [errors=[]] - Any errors encountered during the health check.
 * @returns {{status: string, detail: object, errors: Array<Error>}}
 */
export function createStandardHealthCheckResult(status, detail = {}, errors = []) {
  return {
    status,
    detail,
    errors: errors.map(err => ({ // Store a serializable summary of the error
      name: err.name,
      message: err.message,
      code: err.code,
      details: err.details,
      cause: err.cause ? { name: err.cause.name, message: err.cause.message, code: err.cause.code } : undefined
    }))
  };
}


// src/core/common/SystemConstants.js

/**
 * @file SystemConstants.js
 * @description Defines shared constants for system status and lifecycle.
 */

export const SYSTEM_STATUS = Object.freeze({
  CREATED: 'created',
  INITIALIZING: 'initializing',
  RUNNING: 'running',
  SHUTTING_DOWN: 'shutting_down',
  SHUTDOWN: 'shutdown',
  ERROR: 'error',
  DEGRADED: 'degraded', // For health checks
  HEALTHY: 'healthy',   // For health checks
  UNHEALTHY: 'unhealthy' // For health checks
});

export const LIFECYCLE_EVENTS = Object.freeze({
  INITIALIZING: 'system:initializing',
  INITIALIZED: 'system:initialized', // Or 'system:running'
  RUNNING: 'system:running',
  SHUTTING_DOWN: 'system:shutting_down',
  SHUTDOWN: 'system:shutdown',
  ERROR: 'system:error'
});

// Default configuration for common system aspects
export const DEFAULT_CONFIG = Object.freeze({
  MAX_ERROR_HISTORY: 100,
  DEFAULT_HEALTH_CHECK_INTERVAL: 30000, // ms
  DEFAULT_METRIC_FLUSH_INTERVAL: 60000 // ms (if applicable)
});


// src/core/common/index.js

/**
 * @file src/core/common/index.js
 * @description Barrel file for exporting common shared utilities and constants.
 */

export {
  SYSTEM_STATUS,
  LIFECYCLE_EVENTS,
  DEFAULT_CONFIG
} from './SystemConstants.js';

export {
  safeHandleError,
  createStandardHealthCheckResult
} from './ErrorUtils.js';


// src/core/common/utilities_and_definitions.md

# TSMIS Core Utilities and Definitions Documentation
Version: 1.0.0 (Aligned with Core System Refactor v2.0.0)

## Table of Contents

1.  [Introduction](#1-introduction)
    * [1.1. Purpose of these Foundational Files](#11-purpose-of-these-foundational-files)
    * [1.2. Location in Architecture](#12-location-in-architecture)
2.  [Component: `SystemConstants.js` - Shared System Constants](#2-component-systemconstantsjs---shared-system-constants)
    * [2.1. Overview & Purpose](#21-overview--purpose)
    * [2.2. Key Definitions](#22-key-definitions)
        * [2.2.1. `SYSTEM_STATUS`](#221-system_status)
        * [2.2.2. `LIFECYCLE_EVENTS`](#222-lifecycle_events)
        * [2.2.3. `DEFAULT_CONFIG`](#223-default_config)
    * [2.3. Usage Guidelines & Example](#23-usage-guidelines--example)
3.  [Component: `ErrorUtils.js` - Error Handling and Health Utilities](#3-component-errorutilsjs---error-handling-and-health-utilities)
    * [3.1. Overview & Purpose](#31-overview--purpose)
    * [3.2. Key Functions](#32-key-functions)
        * [3.2.1. `async safeHandleError(errorSystem, error, context = {})`](#321-async-safehandleerrorerrorsystem-error-context---)
        * [3.2.2. `createStandardHealthCheckResult(status, detail = {}, errors = [])`](#322-createstandardhealthcheckresultstatus-detail---errors---)
    * [3.3. Usage Guidelines & Examples](#33-usage-guidelines--examples)
4.  [Component: `ErrorCodes.js` - Standardized Error Identifiers](#4-component-errorcodesjs---standardized-error-identifiers)
    * [4.1. Overview & Purpose](#41-overview--purpose)
    * [4.2. Structure and Naming Convention](#42-structure-and-naming-convention)
    * [4.3. Usage Guidelines](#43-usage-guidelines)
    * [4.4. Integration with `CoreError` and `ErrorSystem`](#44-integration-with-coreerror-and-errorsystem)
    * [4.5. Example Snippet](#45-example-snippet)
5.  [Overall Integration and Importance](#5-overall-integration-and-importance)
6.  [Testing Strategy Notes (for Utilities)](#6-testing-strategy-notes-for-utilities)
7.  [Future Considerations](#7-future-considerations)

---

## 1. Introduction

### 1.1. Purpose of these Foundational Files
The TSMIS core architecture relies on a set of foundational utility files that provide shared constants, error handling helper functions, and a centralized registry of error codes. These files are essential for ensuring consistency, reducing redundancy, and promoting robust behavior across all core systems and business modules. This document details these key utilities: `SystemConstants.js`, `ErrorUtils.js`, and `ErrorCodes.js`.

### 1.2. Location in Architecture
* `SystemConstants.js` and `ErrorUtils.js` are typically located in `src/core/common/`.
* `ErrorCodes.js` is located in `src/core/errors/`.

These utilities are designed to have minimal dependencies and are used extensively by higher-level core systems and application modules.

## 2. Component: `SystemConstants.js` - Shared System Constants

### 2.1. Overview & Purpose
`SystemConstants.js` is the definitive source for shared, immutable constants that govern system-wide states (like component lifecycle statuses and health statuses), standard names for lifecycle events, and default fallback values for common configuration parameters. Using these centralized constants prevents "magic strings" or "magic numbers," reduces the risk of typos, and makes global adjustments to these standard values straightforward.

### 2.2. Key Definitions

All constant objects in this file are frozen using `Object.freeze()` to ensure their immutability.

#### 2.2.1. `SYSTEM_STATUS`
* **Definition**: An object containing standardized string values that represent the operational lifecycle status of core components (systems, modules) as well as the health status reported by health checks.
* **Key Values Examples**: `CREATED`, `INITIALIZING`, `RUNNING`, `SHUTTING_DOWN`, `SHUTDOWN`, `ERROR`, `HEALTHY`, `DEGRADED`, `UNHEALTHY`.
* **Primary Usage**:
    * Used within the `this.state.status` property of all core systems and `CoreModule` instances.
    * The health-related statuses (`HEALTHY`, `DEGRADED`, `UNHEALTHY`) are used by health check functions and the `createStandardHealthCheckResult` utility.

#### 2.2.2. `LIFECYCLE_EVENTS`
* **Definition**: An object that maps standard lifecycle phases of core components to consistent, globally unique event names.
* **Key Values Examples**: `INITIALIZING: 'system:initializing'`, `INITIALIZED: 'system:initialized'`, `RUNNING: 'system:running'`, `SHUTTING_DOWN: 'system:shutting_down'`, `SHUTDOWN: 'system:shutdown'`, `ERROR: 'system:error'`.
* **Primary Usage**:
    * Utilized by core systems and `CoreModule` instances when they emit events related to their own lifecycle transitions (e.g., `super.emit(LIFECYCLE_EVENTS.INITIALIZING, { system: this.constructor.name })`).
    * Modules also use these to create component-name-scoped lifecycle events (e.g., by appending their name: `LIFECYCLE_EVENTS.INITIALIZED + ':' + this.constructor.name.toLowerCase()`).

#### 2.2.3. `DEFAULT_CONFIG`
* **Definition**: An object providing default fallback values for common configurable parameters that might be used within core systems or modules if specific configuration is not explicitly provided by the application's configuration.
* **Key Values Examples**:
    * `MAX_ERROR_HISTORY: 100` (Default capacity for internal error logs within components' `this.state.errors` array).
    * `DEFAULT_HEALTH_CHECK_INTERVAL: 30000` (Default interval in milliseconds for periodic health checks, e.g., in `CoreModule.startHealthChecks()`).
* **Primary Usage**: Core systems and modules can refer to these constants as default values when a specific configuration is missing from `this.deps.config` or a module's `this.config`.

**SystemConstants.js**: Definitions

```javascript
// src/core/common/SystemConstants.js (Illustrative Content)

export const SYSTEM_STATUS = Object.freeze({
  CREATED: 'created',
  INITIALIZING: 'initializing',
  RUNNING: 'running',
  SHUTTING_DOWN: 'shutting_down',
  SHUTDOWN: 'shutdown',
  ERROR: 'error',
  DEGRADED: 'degraded', // For health checks
  HEALTHY: 'healthy',   // For health checks
  UNHEALTHY: 'unhealthy' // For health checks
});

export const LIFECYCLE_EVENTS = Object.freeze({
  INITIALIZING: 'system:initializing',
  INITIALIZED: 'system:initialized',
  RUNNING: 'system:running',
  SHUTTING_DOWN: 'system:shutting_down',
  SHUTDOWN: 'system:shutdown',
  ERROR: 'system:error'
});

// Default configuration for common system aspects
export const DEFAULT_CONFIG = Object.freeze({
  MAX_ERROR_HISTORY: 100,
  DEFAULT_HEALTH_CHECK_INTERVAL: 30000, // ms
  DEFAULT_METRIC_FLUSH_INTERVAL: 60000 // ms (if applicable for a metrics system)
});
```

### 2.3. Usage Guidelines & Example
* **Import**: Always import the required constants or the entire constant objects from `SystemConstants.js` rather than redefining similar values elsewhere.
* **Immutability**: Rely on the frozen nature of these objects; do not attempt to modify them at runtime.
* **Extensibility**: If new system-wide standard statuses, lifecycle event types, or common default configurations are needed, they should be added to this central file.

**Example**: Usage of SystemConstants.js

```javascript
// Example usage within a hypothetical core system component:
// import { SYSTEM_STATUS, LIFECYCLE_EVENTS, DEFAULT_CONFIG } from './src/core/common/SystemConstants.js'; // Adjust path

// class MySystem {
//   constructor(deps) {
//     this.deps = deps;
//     this.state = {
//       status: SYSTEM_STATUS.CREATED, // Using a constant for initial status
//       errors: [],
//       // ... other state properties
//     };
//     // Using a constant for a default configuration value
//     this.maxErrors = this.deps.config?.mySystem?.maxErrorHistory || DEFAULT_CONFIG.MAX_ERROR_HISTORY;
//   }

//   async initialize() {
//     if (this.state.status === SYSTEM_STATUS.RUNNING) return; // Comparing with a constant
//     this.state.status = SYSTEM_STATUS.INITIALIZING; // Setting status with a constant
//
//     // Emitting a standardized lifecycle event
//     // if (this.emit) { // Assuming 'this' is an EventEmitter
//     //   this.emit(LIFECYCLE_EVENTS.INITIALIZING, { system: this.constructor.name });
//     // }

//     // ... initialization logic ...

//     this.state.status = SYSTEM_STATUS.RUNNING;
//     // if (this.emit) {
//     //   this.emit(LIFECYCLE_EVENTS.INITIALIZED, { system: this.constructor.name });
//     //   this.emit(LIFECYCLE_EVENTS.RUNNING, { system: this.constructor.name });
//     // }
//   }

//   // ... other methods
// }
```

## 3. Component: `ErrorUtils.js` - Error Handling and Health Utilities

### 3.1. Overview & Purpose
`ErrorUtils.js` centralizes critical utility functions that support the standardized error handling and health reporting mechanisms of the TSMIS architecture. These utilities ensure consistency and robustness in these cross-cutting concerns.

### 3.2. Key Functions

#### 3.2.1. `async safeHandleError(errorSystem, error, context = {})`
* **Purpose**: To provide a resilient and safe way to report errors to the application's central `ErrorSystem`. Its primary safety feature is a fallback mechanism: if the provided `errorSystem` instance is unavailable, invalid, or if the `errorSystem.handleError()` call itself fails, `safeHandleError` guarantees that the error is still captured by logging it directly to `console.error` with comprehensive details. This prevents critical errors from being silently lost.
* **Parameters**:
    * `errorSystem: object | null | undefined`: An instance of the `ErrorSystem`.
    * `error: Error`: The error object to handle (ideally a `CoreError` instance).
    * `context: object` (optional, default: `{}`): Contextual information about the error (e.g., `source` component, operation name).
* **Returns**: `Promise<void>`.

#### 3.2.2. `createStandardHealthCheckResult(status, detail = {}, errors = [])`
* **Purpose**: A factory function used to construct standardized health check result objects. This ensures that all individual health checks throughout the application (whether in core systems or business modules) return their status information in a uniform structure. This uniformity is vital for consistent aggregation, monitoring, and automated processing of health data.
* **Parameters**:
    * `status: string`: The health status (must be one of `SYSTEM_STATUS.HEALTHY`, `SYSTEM_STATUS.UNHEALTHY`, `SYSTEM_STATUS.DEGRADED`).
    * `detail: object` (optional, default: `{}`): Specific, arbitrary details relevant to the health check performed.
    * `errors: Array<Error>` (optional, default: `[]`): An array of `Error` objects (preferably `CoreError` instances) encountered during the check that contributed to its status. The utility formats these into a serializable `ErrorSummary` structure.
* **Returns**: `object` - A health check result object: `{ status: string, detail: object, errors: Array<ErrorSummary> }`.

**ErrorUtils.js**: Key Function Definitions

```javascript
// src/core/common/ErrorUtils.js (Illustrative Content of the functions)

/**
 * Safely handles an error by attempting to forward it to the ErrorSystem.
 * If ErrorSystem is unavailable or fails, it logs the error to the console.
 */
export async function safeHandleError(errorSystem, error, context = {}) {
  const source = context.source || 'UnknownSystem';

  if (!errorSystem || typeof errorSystem.handleError !== 'function') {
    console.error(
      `[${new Date().toISOString()}] Unhandled error in ${source} (ErrorSystem unavailable/invalid):`,
      {
        errorCode: error.code,
        errorMessage: error.message,
        errorDetails: error.details,
        errorCause: error.cause,
        context,
        stack: error.stack
      }
    );
    return;
  }

  try {
    await errorSystem.handleError(error, context);
  } catch (forwardingError) {
    console.error(
      `[${new Date().toISOString()}] Failed to forward error from ${source} to ErrorSystem:`,
      {
        originalErrorCode: error.code,
        originalErrorMessage: error.message,
        forwardingErrorCode: forwardingError.code,
        forwardingErrorMessage: forwardingError.message,
        context,
        originalErrorStack: error.stack,
        forwardingErrorStack: forwardingError.stack
      }
    );
  }
}

/**
 * Creates a standardized health check result object.
 */
export function createStandardHealthCheckResult(status, detail = {}, errors = []) {
  return {
    status,
    detail,
    errors: errors.map(err => ({ // Store a serializable summary of the error
      name: err.name,
      message: err.message,
      code: err.code,
      details: err.details,
      cause: err.cause ? { name: err.cause.name, message: err.cause.message, code: err.cause.code } : undefined
    }))
  };
}
```

### 3.3. Usage Guidelines & Examples

* **`safeHandleError` Usage**: This should be the standard method by which core systems and `CoreModule` derivatives (typically within their `_handleInternalError` or public `handleError` methods) report errors to the central `ErrorSystem`. Always provide meaningful `context`.
* **`createStandardHealthCheckResult` Usage**: All individual health check functions (the `checkFn` passed to `registerHealthCheck`) must use this utility to format their return value.

**ErrorUtils.js**: Functions Usage

```javascript
// Example usage within a hypothetical core system or module:
// import { safeHandleError, createStandardHealthCheckResult } from '../common/ErrorUtils.js';
// import { SYSTEM_STATUS } from '../common/SystemConstants.js';
// import { CoreError } from '../errors/CoreError.js'; // Adjust path
// import { ErrorCodes } from '../errors/ErrorCodes.js'; // Adjust path


// class MyComponent {
//   constructor(deps) {
//     this.deps = deps; // Should include errorSystem, logger, etc.
//     this.state = { errors: [] }; // Simplified state for example
//   }

//   async _handleInternalError(error, context = {}) { // Example internal error handler
//       const internalError = !(error instanceof CoreError)
//         ? new CoreError(ErrorCodes.CORE.INTERNAL_ERROR, error.message, context, { cause: error })
//         : error;
//       this.state.errors.push({ error: internalError, timestamp: new Date().toISOString(), context });
//       // ... (error array capping logic) ...
//       // this.recordMetric('mycomponent.errors.internal', 1, { errorName: internalError.name });
//       await safeHandleError(this.deps.errorSystem, internalError, { source: this.constructor.name, ...context });
//   }


//   async checkMySpecificFeature() { // Example health check function
//     let isFeatureHealthy = true;
//     let featureDetails = { status: 'online', version: '1.2.3' };
//     let encounteredErrors = [];

//     try {
//       // if (await this.someDependency.is unresponsive()) {
//       //   isFeatureHealthy = false;
//       //   featureDetails.status = 'dependency_issue';
//       //   encounteredErrors.push(new ServiceError(ErrorCodes.SERVICE.UNAVAILABLE, 'Dependency X is unresponsive.'));
//       // }
//     } catch (error) {
//       isFeatureHealthy = false;
//       featureDetails.error = error.message;
//       encounteredErrors.push(error);
//     }

//     return createStandardHealthCheckResult(
//       isFeatureHealthy ? SYSTEM_STATUS.HEALTHY : SYSTEM_STATUS.UNHEALTHY,
//       featureDetails,
//       encounteredErrors
//     );
//   }
// }
```

## 4. Component: `ErrorCodes.js` - Standardized Error Identifiers

### 4.1. Overview & Purpose
`ErrorCodes.js` (located at `src/core/errors/ErrorCodes.js`) serves as the definitive, centralized registry for all standardized error code strings used within the TSMIS application. Its purpose is to provide a controlled and consistent vocabulary for uniquely identifying specific error conditions, which is fundamental for effective programmatic error handling, debugging, and monitoring.

### 4.2. Structure and Naming Convention
* **Main Export**: Exports a single, deeply frozen `ErrorCodes` object.
* **Domains/Categories**: Error codes are hierarchically organized under top-level keys representing major application domains or core systems (e.g., `CORE`, `CONFIG`, `MODULE`, `VALIDATION`, `EVENT`, `ROUTER`, and potentially business-module specific domains like `INVENTORY`). These domain keys are conventionally `PascalCase` or `UPPER_SNAKE_CASE`.
* **Specific Codes**: Within each domain, individual error identifiers are `UPPER_SNAKE_CASE` keys.
* **Value Format**: The string value assigned to each error code key is typically the key itself (e.g., `ErrorCodes.VALIDATION.INVALID_INPUT` would have the string value `'INVALID_INPUT'`).
    * **Note on Prefixes**: The `CoreError` subclasses (e.g., `ValidationError`, `ModuleError`) are responsible for prepending their domain prefix to this specific code part when an error instance is created. For example, `new ValidationError(ErrorCodes.VALIDATION.INVALID_INPUT, ...)` would result in an `error.code` of `'VALIDATION_INVALID_INPUT'`. If a base `CoreError` is thrown directly with a code from a specific domain, the prefix might need to be manually prepended to the code string from `ErrorCodes.js` to ensure global uniqueness and clarity, or `ErrorSystem.createError()` should be used.

**Example**: Snippet from ErrorCodes.js Structure

```javascript
// src/core/errors/ErrorCodes.js (Illustrative Snippet)

// export const ErrorCodes = Object.freeze({
//   CORE: Object.freeze({
//     UNKNOWN_ERROR: 'UNKNOWN_ERROR',
//     INTERNAL_ERROR: 'INTERNAL_ERROR',
//     NOT_IMPLEMENTED: 'NOT_IMPLEMENTED',
//     // ...
//   }),
//   CONFIG: Object.freeze({
//     LOAD_FAILED: 'LOAD_FAILED',
//     VALIDATION_FAILED: 'VALIDATION_FAILED',
//     // ...
//   }),
//   VALIDATION: Object.freeze({ // Specific codes for ValidationError instances
//     INVALID_INPUT: 'INVALID_INPUT',
//     SCHEMA_MISMATCH: 'SCHEMA_MISMATCH',
//     REQUIRED_FIELD: 'REQUIRED_FIELD',
//     // ...
//   }),
//   // ... other domains like MODULE, EVENT, ROUTER, SERVICE, NETWORK, AUTH, ACCESS ...
// });
```

### 4.3. Usage Guidelines
* **Import & Reference**: Always import the `ErrorCodes` object and use its constants when instantiating `CoreError` or its subclasses. This prevents typos and ensures use of defined codes.
* **Adding New Codes**: When a new distinct error condition is identified:
    1.  Determine the appropriate domain/category within `ErrorCodes.js`. Create a new domain object if necessary.
    2.  Add a new, descriptive `UPPER_SNAKE_CASE` key for the error within its domain.
    3.  Assign it a string value, typically matching the key (this is the unprefixed part).
    4.  Ensure all nested objects within `ErrorCodes` remain frozen with `Object.freeze()`.

### 4.4. Integration with `CoreError` and `ErrorSystem`
* **`CoreError` Subclasses**: Constructors of specialized error types (e.g., `ValidationError`) use a specific code from `ErrorCodes.DOMAIN.CODE_NAME` and prepend their domain (e.g., `VALIDATION_`) to form the final `error.code`.
* **`ErrorSystem`**:
    * The `createError(typeName, code, ...)` method expects the specific (unprefixed) `code` from `ErrorCodes.js` and uses the `typeName` to find the correct `CoreError` subclass (which then adds its domain prefix).
    * Custom handlers registered with `ErrorSystem.registerHandler()` can switch on the full, prefixed `error.code` (e.g., `'VALIDATION_INVALID_INPUT'`) to implement specific logic.
    * Framework integrations often map external error states to these internal `ErrorCodes` when creating `CoreError` instances.

## 5. Overall Integration and Importance
These common utilities (`SystemConstants.js`, `ErrorUtils.js`) and definitions (`ErrorCodes.js`) are not standalone systems but rather foundational building blocks.
* They are imported and used by all core systems (`ContainerSystem`, `ErrorSystem`, `EventBusSystem`, `ModuleSystem`, `RouterSystem`) and the base classes (`CoreModule`, `CoreError`).
* Their consistent use enforces the standardization pillars of the architecture, particularly around lifecycle management, error handling, and health monitoring.
* They contribute significantly to reducing boilerplate, improving code clarity, and enhancing the overall robustness and maintainability of TSMIS.

## 6. Testing Strategy Notes (for Utilities)
* **`SystemConstants.js`**:
    * Verify that the exported objects (`SYSTEM_STATUS`, `LIFECYCLE_EVENTS`, `DEFAULT_CONFIG`) are deeply frozen to ensure immutability.
    * Check that key constant values are correct and present.
* **`ErrorUtils.js`**:
    * **`safeHandleError`**: Test thoroughly with:
        * A valid, working `ErrorSystem` instance (ensure `errorSystem.handleError` is called).
        * A `null` or `undefined` `errorSystem` instance (ensure `console.error` is called with correct details).
        * An `errorSystem` instance where `handleError` itself throws an error (ensure `console.error` is called with both original and forwarding error details).
    * **`createStandardHealthCheckResult`**: Test that it produces objects with the correct structure (`{ status, detail, errors }`) and that the `errors` array contains correctly summarized error information.
* **`ErrorCodes.js`**:
    * Verify that the main `ErrorCodes` object and its nested domain objects are deeply frozen.
    * Check for uniqueness of error code string values (if feasible with tooling, otherwise by convention and review).
    * Ensure the structure is as expected.

## 7. Future Considerations
* **`ErrorCodes.js` Linting/Validation**: Implement automated checks to ensure uniqueness of error codes and adherence to naming conventions.
* **`SystemConstants.js` Expansion**: As new common states or event types emerge across multiple systems, they should be added here.
* **`ErrorUtils.js` Further Utilities**: Potentially add more error-related helper functions if common patterns emerge (e.g., more sophisticated error wrapping or formatting utilities, though much of this is handled by `CoreError` itself).


// src/core/container/ContainerSystem.js

/**
 * @file ContainerSystem.js
 * @description Dependency Injection (DI) and Inversion of Control (IoC) container.
 * Manages component lifecycles, dependencies, and system initialization.
 */

import { EventEmitter } from 'events';
import { ConfigError, ServiceError } from '../errors/index.js'; // Assuming errors/index.js exports these
import { ErrorCodes } from '../errors/ErrorCodes.js'; // Assuming ErrorCodes are in their own file
import { SYSTEM_STATUS, LIFECYCLE_EVENTS, DEFAULT_CONFIG } from '../common/SystemConstants.js';
import { safeHandleError, createStandardHealthCheckResult } from '../common/ErrorUtils.js';

// Node.js built-in modules for discovery
import { readdir, stat } from 'fs/promises'; // For scanDirectory
import { join, dirname, basename } from 'path'; // For scanDirectory and loadConfig
import { existsSync } from 'fs'; // For loadConfig

export class ContainerSystem extends EventEmitter {
  static dependencies = ['config', 'errorSystem']; // For its own config and error handling
  static version = '2.0.0'; // Example version bump

  /**
   * Creates a new ContainerSystem instance.
   * @param {object} [deps={}] - Dependencies for the ContainerSystem.
   * @param {object} [deps.config={}] - Configuration object for the container itself.
   * @param {object} [deps.errorSystem] - The ErrorSystem instance for centralized error reporting.
   */
  constructor(deps = {}) {
    super();
    this.deps = {
      config: deps.config || {},
      errorSystem: deps.errorSystem, // errorSystem might be a component it manages
                                     // so internal errors might need careful handling if errorSystem isn't resolved yet.
                                     // Using console for very early errors is an option.
    };

    this.components = new Map();
    this.instances = new Map();
    this.dependencies = new Map();
    this.manifests = new Map();
    // this.initialized is now driven by this.state.status

    this.state = {
      status: SYSTEM_STATUS.CREATED,
      startTime: null,
      errors: [], // For internal errors of ContainerSystem
      metrics: new Map(),
      healthChecks: new Map(),
    };

    this.registerHealthCheck('container.state', this.checkSystemState.bind(this));
    this.registerHealthCheck('container.components', this.checkComponentStatus.bind(this));
  }

  /**
   * Handles internal operational errors of the ContainerSystem.
   * Logs the error to internal state and forwards to ErrorSystem if available.
   * @private
   * @param {Error} error - The error object.
   * @param {object} [context={}] - Additional context.
   */
  async _handleInternalError(error, context = {}) {
    const errorToLog = !(error instanceof ConfigError || error instanceof ServiceError)
      ? new ServiceError(ErrorCodes.CORE.INTERNAL, error.message, context, { cause: error })
      : error;

    this.state.errors.push({ error: errorToLog, timestamp: new Date().toISOString(), context });
    if (this.state.errors.length > (this.deps.config?.container?.maxErrorHistory || DEFAULT_CONFIG.MAX_ERROR_HISTORY)) {
      this.state.errors.shift();
    }
    this.recordMetric('container.errors.internal', 1, { errorName: errorToLog.name, errorCode: errorToLog.code });

    // Use safeHandleError, which will use console if errorSystem is not ready/available
    await safeHandleError(this.deps.errorSystem, errorToLog, { source: 'ContainerSystem', ...context });
  }

  /**
   * Register a component manifest.
   * @param {string} type - Component type.
   * @param {object} manifest - Component manifest.
   */
  registerManifest(type, manifest) {
    if (this.state.status === SYSTEM_STATUS.SHUTDOWN || this.state.status === SYSTEM_STATUS.SHUTTING_DOWN) {
        const err = new ConfigError(ErrorCodes.CORE.INVALID_OPERATION, `Cannot register manifest on a shutdown container: ${type}`);
        this._handleInternalError(err, { type }); // Log, but rethrow as it's a programming error
        throw err;
    }
    if (this.manifests.has(type)) {
      throw new ConfigError( // This is an immediate operational error, throw directly
        ErrorCodes.CONFIG.DUPLICATE_MANIFEST, // Assuming an appropriate code
        `Manifest already registered for type: ${type}`
      );
    }
    this.manifests.set(type, manifest);
    this.recordMetric('container.manifests.registered', 1, { type });
    this.emit('manifest:registered', { type, manifest });
  }

  /**
   * Register a component with the container.
   * @param {string} name - Component name.
   * @param {Function|object} Component - Component constructor, factory function, or instance.
   * @param {object} [options={}] - Registration options (e.g., singleton: true).
   * @returns {ContainerSystem} This instance for chaining.
   */
  register(name, Component, options = {}) {
    if (this.state.status === SYSTEM_STATUS.SHUTDOWN || this.state.status === SYSTEM_STATUS.SHUTTING_DOWN) {
        const err = new ConfigError(ErrorCodes.CORE.INVALID_OPERATION, `Cannot register component on a shutdown container: ${name}`);
        this._handleInternalError(err, { name });
        throw err;
    }
    if (this.components.has(name)) {
      throw new ConfigError(
        ErrorCodes.CONFIG.DUPLICATE_COMPONENT, // [cite: 14]
        `Component ${name} is already registered` // [cite: 14]
      );
    }

    this.components.set(name, {
      Component,
      options: {
        singleton: true, // Default to singleton
        ...options,
      },
    });
    // Store dependencies if provided directly on the Component (static property)
    this.dependencies.set(name, Component.dependencies || []); // [cite: 16]

    this.recordMetric('container.components.registered', 1, { name });
    this.emit('component:registered', { name, Component }); // [cite: 16]
    return this;
  }

  /**
   * Discover components in a directory.
   * @param {string} type - Component type (must match a registered manifest).
   * @param {string} basePath - Base directory path to scan.
   * @returns {Promise<Map<string, object>>} A map of discovered components.
   */
  async discover(type, basePath) {
    if (!this.manifests.has(type)) {
      throw new ConfigError( // [cite: 17]
        ErrorCodes.CONFIG.INVALID_TYPE, // Assuming an appropriate code
        `No manifest registered for type: ${type}` // [cite: 17]
      );
    }

    this.recordMetric('container.discovery.started', 1, { type, basePath });
    try {
      const manifest = this.manifests.get(type);
      const componentPaths = await this.scanDirectory(basePath); // [cite: 18]
      const discoveredComponents = new Map(); // [cite: 19]

      for (const path of componentPaths) {
        try {
          const component = await this.loadComponent(path, manifest); // [cite: 19]
          if (component) { // [cite: 20]
            discoveredComponents.set(component.name, component); // [cite: 20]
          }
        } catch (error) {
          // Log individual component load errors but continue discovery
          const discoveryError = new ServiceError(
            ErrorCodes.SERVICE.LOAD_FAILED, // Assuming an appropriate code
            `Error loading component during discovery from ${path}`,
            { path, type, originalMessage: error.message },
            { cause: error }
          );
          await this._handleInternalError(discoveryError, { phase: 'discovery-load', path });
          this.emit('discovery:error', { path, error: discoveryError }); // [cite: 21]
        }
      }

      this.emit('discovery:completed', { type, components: discoveredComponents }); // [cite: 22]
      this.recordMetric('container.discovery.completed', 1, { type, count: discoveredComponents.size });
      return discoveredComponents;
    } catch (error) {
      const discoveryFailedError = new ServiceError(
        ErrorCodes.SERVICE.DISCOVERY_FAILED, // [cite: 23]
        `Failed to discover ${type} components from ${basePath}`, // [cite: 23]
        { type, basePath, originalMessage: error.message },
        { cause: error }
      );
      await this._handleInternalError(discoveryFailedError, { phase: 'discovery', type });
      this.recordMetric('container.discovery.failed', 1, { type });
      throw discoveryFailedError; // [cite: 24]
    }
  }

  /**
   * Load a component from a file path based on a manifest.
   * @private
   * @param {string} path - Path to the component file.
   * @param {object} manifest - The manifest for this component type.
   * @returns {Promise<object|null>} The loaded component or null if disabled/invalid.
   */
  async loadComponent(path, manifest) {
    try {
      const config = await this.loadConfig(path); // [cite: 24]
      if (config.enabled === false) return null; // [cite: 25]

      if (manifest.configSchema) {
        await this.validateConfig(config, manifest.configSchema); // [cite: 25]
      }
      const implementation = await this.loadImplementation(path); // [cite: 25]
      return { // [cite: 26]
        name: config.name,
        config,
        implementation,
      };
    } catch (error) {
      // Let discover method handle logging this error via _handleInternalError
      throw new ConfigError( // [cite: 27]
        ErrorCodes.CONFIG.LOAD_FAILED, // [cite: 27]
        `Failed to load component from ${path}`, // [cite: 27]
        { path, originalMessage: error.message },
        { cause: error } // [cite: 28]
      );
    }
  }

  /**
   * Get an instance of a component.
   * @param {string} name - Component name.
   * @param {object} [parentDepsStack=[]] - Used internally to detect circular dependencies.
   * @returns {Promise<any>} The resolved component instance.
   */
  async resolve(name, parentDepsStack = []) {
    if (!this.components.has(name)) {
      throw new ServiceError( // [cite: 28]
        ErrorCodes.SERVICE.UNKNOWN_COMPONENT, // [cite: 28]
        `Component ${name} is not registered.` // [cite: 29]
      );
    }

    if (parentDepsStack.includes(name)) {
        throw new ConfigError(
            ErrorCodes.CONFIG.CIRCULAR_DEPENDENCY,
            `Circular dependency detected: ${parentDepsStack.join(' -> ')} -> ${name}`
        );
    }

    const { Component, options } = this.components.get(name); // [cite: 29]

    if (options.singleton && this.instances.has(name)) { // [cite: 30]
      return this.instances.get(name); // [cite: 30]
    }

    const currentDepsStack = [...parentDepsStack, name];
    const componentDepsList = this.dependencies.get(name) || []; // [cite: 31]
    const resolvedDeps = {}; // [cite: 32]

    for (const dep of componentDepsList) {
      if (!this.components.has(dep)) {
        throw new ConfigError(
            ErrorCodes.CONFIG.MISSING_DEPENDENCY,
            `Dependency '${dep}' required by '${name}' is not registered.`
        );
      }
      resolvedDeps[dep] = await this.resolve(dep, currentDepsStack); // [cite: 32]
    }

    let instance;
    if (typeof Component === 'function') { // [cite: 34]
      // Check if it's a class constructor (has a prototype and is not an arrow function)
      if (Component.prototype && typeof Component.prototype.constructor === 'function') { // [cite: 34]
        instance = new Component(resolvedDeps); // [cite: 34]
      } else { // Factory function
        instance = await Promise.resolve(Component(resolvedDeps)); // [cite: 35]
      }
    } else { // Pre-resolved instance
      instance = Component; // [cite: 36]
    }

    // If container is already initialized and instance has an initialize method, call it.
    // This handles components resolved after global initialization.
    if (this.state.status === SYSTEM_STATUS.RUNNING && typeof instance.initialize === 'function') { // [cite: 37]
      await instance.initialize(); // [cite: 38]
    }

    if (options.singleton) {
      this.instances.set(name, instance); // [cite: 38]
    }

    this.recordMetric('container.components.resolved', 1, { name, singleton: !!options.singleton });
    this.emit('component:resolved', { name, instance }); // [cite: 39]
    return instance; // [cite: 40]
  }

  /**
   * Initialize all registered components in dependency order.
   * @returns {Promise<void>}
   */
  async initialize() {
    if (this.state.status === SYSTEM_STATUS.RUNNING || this.state.status === SYSTEM_STATUS.INITIALIZING) {
      const err = new ServiceError(ErrorCodes.SERVICE.ALREADY_INITIALIZED, 'ContainerSystem is already initialized or initializing.'); // [cite: 40]
      await this._handleInternalError(err);
      // Depending on strictness, you might re-throw or just return
      return;
    }

    this.emit(LIFECYCLE_EVENTS.INITIALIZING, { system: 'ContainerSystem' });
    this.state.status = SYSTEM_STATUS.INITIALIZING;
    const initStartTime = Date.now();
    this.state.startTime = initStartTime; // Mark start of initialization process

    try {
      const order = this.resolveDependencyOrder(); // [cite: 41]
      for (const name of order) { // [cite: 42]
        const instance = await this.resolve(name); // [cite: 42]
        // The initialize call during resolve handles already-initialized container state.
        // However, for the main init loop, we ensure it's called if not already.
        if (this.state.status !== SYSTEM_STATUS.RUNNING && typeof instance.initialize === 'function') { // [cite: 43]
          // Check instance.initialized or similar if components track their own init state
          // to avoid double initialization if resolve already did it.
          // For now, we assume resolve's initialize is for post-container-init resolutions.
          await instance.initialize(); // [cite: 43]
        }
      }

      //this.initialized = true; // Deprecated, use state.status
      this.state.status = SYSTEM_STATUS.RUNNING;
      const initTime = Date.now() - initStartTime;
      this.recordMetric('container.initialization.time', initTime);
      this.recordMetric('container.initialization.success', 1);
      this.emit(LIFECYCLE_EVENTS.INITIALIZED, { system: 'ContainerSystem', durationMs: initTime, timestamp: new Date().toISOString() }); // [cite: 44]
      this.emit(LIFECYCLE_EVENTS.RUNNING, { system: 'ContainerSystem', timestamp: new Date().toISOString() });


    } catch (error) {
      this.state.status = SYSTEM_STATUS.ERROR;
      this.recordMetric('container.initialization.failure', 1, { error: error.code });
      await this._handleInternalError(error, { phase: 'initialization' });
      throw error instanceof ServiceError || error instanceof ConfigError ? error : new ServiceError(
        ErrorCodes.SERVICE.INITIALIZATION_FAILED, // Generic initialization failure code
        'ContainerSystem failed to initialize.',
        { originalMessage: error.message },
        { cause: error }
      );
    }
  }

  /**
   * Resolve dependency order for initialization using topological sort.
   * @private
   * @returns {Array<string>} Ordered list of component names.
   */
  resolveDependencyOrder() {
    const visited = new Set(); // [cite: 45]
    const visiting = new Set(); // To detect circular dependencies [cite: 46]
    const order = []; // [cite: 46]

    const visit = (name) => {
      if (visited.has(name)) return; // [cite: 46]
      if (visiting.has(name)) { // [cite: 47]
        throw new ConfigError( // [cite: 47]
          ErrorCodes.CONFIG.CIRCULAR_DEPENDENCY, // [cite: 47]
          `Circular dependency detected involving: ${name}. Path: ${Array.from(visiting).join(' -> ')} -> ${name}` // [cite: 48]
        );
      }

      visiting.add(name); // [cite: 48]
      const componentDefinition = this.components.get(name);
      if (!componentDefinition) { // Should not happen if called after registration
          visiting.delete(name);
          throw new ConfigError(ErrorCodes.SERVICE.UNKNOWN_COMPONENT, `Component ${name} definition not found while resolving dependency order.`);
      }

      const deps = this.dependencies.get(name) || []; // [cite: 48]
      for (const dep of deps) { // [cite: 49]
        if (!this.components.has(dep)) { // [cite: 49]
          throw new ConfigError( // [cite: 49]
            ErrorCodes.CONFIG.MISSING_DEPENDENCY, // [cite: 49]
            `Dependency ${dep} required by ${name} is not registered.` // [cite: 50]
          );
        }
        visit(dep); // [cite: 50]
      }

      visiting.delete(name); // [cite: 51]
      visited.add(name); // [cite: 51]
      order.push(name); // [cite: 51]
    };

    // Prioritize specific core systems if they are present
    // This is a common pattern but can be made more dynamic if needed
    const prioritizedOrder = this.deps.config?.container?.initOrder || [ // [cite: 51]
      'errorSystem', // Error system should ideally be first
      'config',      // Config service if it's a component
      'eventBusSystem',
      'moduleSystem',
      'routerSystem'
      // other essential systems
    ];

    for (const name of prioritizedOrder) {
      if (this.components.has(name) && !visited.has(name)) { // [cite: 52]
        visit(name); // [cite: 53]
      }
    }

    // Visit any remaining components
    for (const name of this.components.keys()) { // [cite: 53]
      if (!visited.has(name)) { // Check !visited instead of !order.includes
        visit(name); // [cite: 54]
      }
    }
    return order; // [cite: 55]
  }

  /**
   * Shut down all initialized components in reverse dependency order.
   * @returns {Promise<void>}
   */
  async shutdown() {
    if (this.state.status === SYSTEM_STATUS.SHUTDOWN || this.state.status === SYSTEM_STATUS.SHUTTING_DOWN) {
      return;
    }
    this.emit(LIFECYCLE_EVENTS.SHUTTING_DOWN, { system: 'ContainerSystem' });
    this.state.status = SYSTEM_STATUS.SHUTTING_DOWN;
    const shutdownStartTime = Date.now();

    try {
      // Resolve order again in case components were added/removed, though ideally not after init.
      // It's safer to use the order from last successful initialization if available and unchanged.
      // For simplicity, we re-resolve. Or, store the init order.
      const order = this.resolveDependencyOrder().reverse(); // [cite: 55]

      for (const name of order) { // [cite: 56]
        const instance = this.instances.get(name); // [cite: 56]
        if (instance && typeof instance.shutdown === 'function') { // [cite: 57]
          try {
            await instance.shutdown(); // [cite: 57]
          } catch (error) {
            const shutdownError = new ServiceError(
                ErrorCodes.SERVICE.SHUTDOWN_FAILED, // Assuming an appropriate code
                `Error shutting down component ${name}`,
                { component: name, originalMessage: error.message },
                { cause: error }
            );
            await this._handleInternalError(shutdownError, { phase: 'shutdown-component', component: name });
            this.emit('shutdown:error', { component: name, error: shutdownError }); // [cite: 58]
            // Continue shutting down other components
          }
        }
      }

      this.instances.clear(); // [cite: 59]
      // this.components.clear(); // Typically components are not cleared on shutdown, only instances.
      // this.dependencies.clear();
      // this.manifests.clear();
      // this.initialized = false; // Deprecated
      this.state.status = SYSTEM_STATUS.SHUTDOWN;
      this.state.startTime = null; // Clear start time as it's no longer running
      const shutdownTime = Date.now() - shutdownStartTime;
      this.recordMetric('container.shutdown.time', shutdownTime);
      this.recordMetric('container.shutdown.success', 1);
      this.emit(LIFECYCLE_EVENTS.SHUTDOWN, { system: 'ContainerSystem', durationMs: shutdownTime, timestamp: new Date().toISOString() }); // [cite: 60]

    } catch (error) {
      this.state.status = SYSTEM_STATUS.ERROR;
      this.recordMetric('container.shutdown.failure', 1, { error: error.code });
      await this._handleInternalError(error, { phase: 'shutdown' });
      throw error instanceof ServiceError || error instanceof ConfigError ? error : new ServiceError(
        ErrorCodes.SERVICE.SHUTDOWN_FAILED,
        'ContainerSystem failed to shutdown.',
        { originalMessage: error.message },
        { cause: error }
      );
    }
  }

  // --- Discovery and Loading Methods (largely from original, with minor error handling adjustments) ---

  /**
   * Scan a directory for component files.
   * @private
   */
  async scanDirectory(basePath) { // [cite: 60]
    try {
      const entries = await readdir(basePath, { withFileTypes: true }); // [cite: 61]
      const files = []; // [cite: 62]

      for (const entry of entries) { // [cite: 62]
        const fullPath = join(basePath, entry.name); // [cite: 62]
        if (entry.isDirectory()) { // [cite: 63]
          files.push(...await this.scanDirectory(fullPath)); // [cite: 64]
        } else if (entry.isFile() && (entry.name.endsWith('.js') || entry.name.endsWith('.mjs') || entry.name.endsWith('.cjs'))) { // [cite: 64]
          files.push(fullPath); // [cite: 65]
        }
      }
      return files; // [cite: 66]
    } catch (error) {
      throw new ServiceError( // [cite: 66]
        ErrorCodes.SERVICE.DIRECTORY_SCAN_FAILED, // [cite: 66]
        `Failed to scan directory: ${basePath}`, // [cite: 67]
        { basePath, originalMessage: error.message },
        { cause: error } // [cite: 67]
      );
    }
  }

  /**
   * Load component configuration from a file path or embedded in component.
   * @private
   */
  async loadConfig(path) { // [cite: 67]
    try {
      const dir = dirname(path); // [cite: 68]
      const filename = basename(path, '.js'); // Assuming .js, adjust if other extensions are primary [cite: 68]
      // Consider .mjs, .cjs too if `filename` is used for more than just config name
      const configPathJs = join(dir, `${filename}.config.js`); // [cite: 69]
      // Add checks for .mjs, .cjs config files if needed
      // const configPathMjs = join(dir, `${filename}.config.mjs`);
      // const configPathCjs = join(dir, `${filename}.config.cjs`);

      let actualConfigPath;
      if (existsSync(configPathJs)) actualConfigPath = configPathJs;
      // else if (existsSync(configPathMjs)) actualConfigPath = configPathMjs;
      // else if (existsSync(configPathCjs)) actualConfigPath = configPathCjs;

      if (actualConfigPath) { // [cite: 69]
        const configModule = await import(actualConfigPath); // [cite: 69]
        return configModule.default || configModule; // [cite: 70]
      }

      // Fallback: try to extract config from the component file itself
      const componentModule = await import(path); // [cite: 70]
      if (componentModule.config) { // [cite: 71]
        return typeof componentModule.config === 'function'
          ? await Promise.resolve(componentModule.config()) // Handle async config functions [cite: 71]
          : componentModule.config; // [cite: 72]
      }

      return { name: filename, enabled: true }; // Default config [cite: 73]
    } catch (error) {
      throw new ConfigError( // [cite: 74]
        ErrorCodes.CONFIG.LOAD_FAILED, // [cite: 74]
        `Failed to load configuration from/for ${path}`, // [cite: 75]
        { path, originalMessage: error.message },
        { cause: error } // [cite: 75]
      );
    }
  }

  /**
   * Validate component configuration against a schema.
   * @private
   */
  async validateConfig(config, schema) { // [cite: 75]
    if (!schema) return true; // [cite: 75]

    try {
      if (!config || typeof config !== 'object') { // [cite: 76]
        throw new ConfigError(ErrorCodes.CONFIG.INVALID_CONFIG, 'Configuration must be an object.'); // [cite: 77]
      }

      for (const [key, fieldSchema] of Object.entries(schema)) { // [cite: 77]
        if (fieldSchema.required && (config[key] === undefined || config[key] === null)) { // [cite: 77]
          throw new ConfigError(ErrorCodes.CONFIG.MISSING_REQUIRED_FIELD, `Required field '${key}' is missing.`, { field: key }); // [cite: 78]
        }
        if (config[key] === undefined) continue; // [cite: 79]

        if (fieldSchema.type && typeof config[key] !== fieldSchema.type) { // [cite: 79]
          throw new ConfigError(ErrorCodes.CONFIG.INVALID_FIELD_TYPE, `Field '${key}' expects type '${fieldSchema.type}', got '${typeof config[key]}'.`, { field: key, expected: fieldSchema.type, actual: typeof config[key] }); // [cite: 80]
        }
        if (fieldSchema.enum && !fieldSchema.enum.includes(config[key])) { // [cite: 80]
          throw new ConfigError(ErrorCodes.CONFIG.INVALID_ENUM_VALUE, `Field '${key}' value '${config[key]}' not in enum [${fieldSchema.enum.join(', ')}].`, { field: key, expected: fieldSchema.enum, actual: config[key] }); // [cite: 81]
        }
        if (fieldSchema.pattern && !new RegExp(fieldSchema.pattern).test(config[key])) { // [cite: 81]
          throw new ConfigError(ErrorCodes.CONFIG.PATTERN_MISMATCH, `Field '${key}' does not match pattern '${fieldSchema.pattern}'.`, { field: key, pattern: fieldSchema.pattern, value: config[key] }); // [cite: 82]
        }
      }

      if (typeof schema._validate === 'function') { // [cite: 82]
        await schema._validate(config); // [cite: 83]
      }
      return true; // [cite: 84]
    } catch (error) {
      if (error instanceof ConfigError) throw error; // [cite: 84]
      throw new ConfigError( // [cite: 85]
        ErrorCodes.CONFIG.VALIDATION_FAILED, // [cite: 86]
        'Configuration validation failed.',
        { config, schemaExcerpt: Object.keys(schema), originalMessage: error.message },
        { cause: error } // [cite: 86]
      );
    }
  }

  /**
   * Load component implementation from a file path.
   * @private
   */
  async loadImplementation(path) { // [cite: 86]
    try {
      const module = await import(path); // [cite: 87]
      const filename = basename(path, '.js'); // [cite: 87] // Consider other extensions if needed

      if (module.default) return module.default; // [cite: 89]
      if (module[filename]) return module[filename]; // [cite: 90]

      for (const exportValue of Object.values(module)) { // Iterate values for broader check
        if (typeof exportValue === 'function') {
          // Prioritize classes or well-named factory functions
          if (exportValue.prototype || exportValue.name?.startsWith('create')) { // [cite: 91]
            return exportValue;
          }
        }
      }
      // If no clear main export, and only one export exists, return that.
      const exports = Object.values(module);
      if (exports.length === 1) return exports[0];

      return module; // Fallback to the whole module object [cite: 93]
    } catch (error) {
      throw new ServiceError( // [cite: 93]
        ErrorCodes.SERVICE.IMPLEMENTATION_LOAD_FAILED, // [cite: 94]
        `Failed to load implementation from ${path}`, // [cite: 94]
        { path, originalMessage: error.message },
        { cause: error } // [cite: 94]
      );
    }
  }

  // --- State, Health, Metrics Methods ---
  recordMetric(name, value, tags = {}) {
    this.state.metrics.set(name, { value, timestamp: Date.now(), tags });
  }

  getMetrics() {
    const metrics = {};
    for (const [name, data] of this.state.metrics) {
      metrics[name] = data;
    }
    return metrics;
  }

  registerHealthCheck(name, checkFn) {
    if (typeof checkFn !== 'function') {
        const err = new ConfigError(ErrorCodes.CORE.INVALID_HANDLER, `Health check '${name}' must be a function.`);
        this._handleInternalError(err); // Log, but rethrow as it's a programming error
        throw err;
    }
    this.state.healthChecks.set(name, checkFn);
  }

  async checkHealth() {
    const results = {};
    let overallStatus = SYSTEM_STATUS.HEALTHY;

    for (const [name, checkFn] of this.state.healthChecks) {
      try {
        const checkResult = await checkFn();
        results[name] = checkResult;
        if (checkResult.status !== SYSTEM_STATUS.HEALTHY) {
          overallStatus = (overallStatus === SYSTEM_STATUS.HEALTHY) ? SYSTEM_STATUS.DEGRADED : SYSTEM_STATUS.UNHEALTHY;
          if (checkResult.status === SYSTEM_STATUS.UNHEALTHY) overallStatus = SYSTEM_STATUS.UNHEALTHY;
        }
      } catch (error) {
        results[name] = createStandardHealthCheckResult(SYSTEM_STATUS.UNHEALTHY, { error: 'Health check threw an exception' }, [error]);
        overallStatus = SYSTEM_STATUS.UNHEALTHY;
      }
    }
    return {
      name: this.constructor.name,
      version: ContainerSystem.version,
      status: overallStatus,
      timestamp: new Date().toISOString(),
      uptime: this.state.startTime ? Date.now() - this.state.startTime : 0,
      errorCount: this.state.errors.length,
      checks: results,
    };
  }

  async checkSystemState() {
    return createStandardHealthCheckResult(
      this.state.status === SYSTEM_STATUS.RUNNING ? SYSTEM_STATUS.HEALTHY : SYSTEM_STATUS.UNHEALTHY,
      {
        currentStatus: this.state.status,
        uptime: this.state.startTime ? Date.now() - this.state.startTime : 0,
        internalErrorCount: this.state.errors.length
      }
    );
  }

  async checkComponentStatus() {
    return createStandardHealthCheckResult(SYSTEM_STATUS.HEALTHY, {
      registeredComponentCount: this.components.size,
      resolvedInstanceCount: this.instances.size,
      manifestCount: this.manifests.size,
      // Optionally list names if not too verbose for health check
      // registeredComponents: Array.from(this.components.keys()),
    });
  }

  getSystemStatus() {
    return {
        name: this.constructor.name,
        version: ContainerSystem.version,
        status: this.state.status,
        uptime: this.state.startTime ? Date.now() - this.state.startTime : 0,
        initialized: this.state.status === SYSTEM_STATUS.RUNNING,
        errorCount: this.state.errors.length,
        timestamp: new Date().toISOString()
    };
  }
}

/**
 * Factory function for creating a ContainerSystem instance.
 * @param {object} [deps={}] - Dependencies for the ContainerSystem.
 * @returns {ContainerSystem}
 */
export function createContainerSystem(deps = {}) {
  return new ContainerSystem(deps);
}


// src/core/container/container-system.md

# TSMIS ContainerSystem Documentation
Version: 2.0.0 (Refactored Core)

## Table of Contents

1.  [Introduction to the ContainerSystem](#1-introduction-to-the-containersystem)
    * [1.1. Purpose & Core Responsibilities](#11-purpose--core-responsibilities)
    * [1.2. Key Features](#12-key-features)
2.  [Core Concepts](#2-core-concepts)
    * [2.1. Dependency Injection (DI) & Inversion of Control (IoC)](#21-dependency-injection-di--inversion-of-control-ioc)
    * [2.2. Components (Definition and Types)](#22-components-definition-and-types)
    * [2.3. Manifests & Component Discovery](#23-manifests--component-discovery)
    * [2.4. Dependency Resolution & Order](#24-dependency-resolution--order)
    * [2.5. Singleton Scope](#25-singleton-scope)
3.  [API Reference (`ContainerSystem`)](#3-api-reference-containersystem)
    * [3.1. Constructor](#31-constructor)
    * [3.2. Component Registration Methods](#32-component-registration-methods)
        * [3.2.1. `register(name, Component, options)`](#321-registername-component-options)
        * [3.2.2. `registerManifest(type, manifest)`](#322-registermanifesttype-manifest)
    * [3.3. Component Discovery Methods](#33-component-discovery-methods)
        * [3.3.1. `async discover(type, basePath)`](#331-async-discovertype-basepath)
    * [3.4. Component Resolution Methods](#34-component-resolution-methods)
        * [3.4.1. `async resolve(name)`](#341-async-resolvename)
    * [3.5. Lifecycle Methods](#35-lifecycle-methods)
        * [3.5.1. `async initialize()`](#351-async-initialize)
        * [3.5.2. `async shutdown()`](#352-async-shutdown)
    * [3.6. Internal Utility Methods (Conceptual Overview)](#36-internal-utility-methods-conceptual-overview)
        * [`resolveDependencyOrder()`](#resolvedependencyorder)
        * [`loadComponent(path, manifest)`](#loadcomponentpath-manifest)
        * [`scanDirectory(basePath)`](#scandirectorybasepath)
        * [`loadConfig(path)`](#loadconfigpath)
        * [`validateConfig(config, schema)`](#validateconfigconfig-schema)
        * [`loadImplementation(path)`](#loadimplementationpath)
    * [3.7. Static Factory (`createContainerSystem`)](#37-static-factory-createcontainersystem)
4.  [State Management (`ContainerSystem` Specifics)](#4-state-management-containersystem-specifics)
5.  [Lifecycle Management (`ContainerSystem` Specifics)](#5-lifecycle-management-containersystem-specifics)
    * [5.1. `initialize()` Process Flow](#51-initialize-process-flow)
    * [5.2. `shutdown()` Process Flow](#52-shutdown-process-flow)
6.  [Error Handling within `ContainerSystem`](#6-error-handling-within-containersystem)
7.  [Event Integration (`ContainerSystem` Specifics)](#7-event-integration-containersystem-specifics)
8.  [Health Monitoring (`ContainerSystem` Specifics)](#8-health-monitoring-containersystem-specifics)
9.  [Metrics Tracking (`ContainerSystem` Specifics)](#9-metrics-tracking-containersystem-specifics)
10. [Integrations (ContainerSystem Level)](#10-integrations-containersystem-level)
11. [Usage Examples & Best Practices](#11-usage-examples--best-practices)
    * [11.1. Basic Registration and Resolution](#111-basic-registration-and-resolution)
    * [11.2. Registering Different Component Types (Class, Factory, Instance)](#112-registering-different-component-types-class-factory-instance)
    * [11.3. Defining Component Dependencies](#113-defining-component-dependencies)
    * [11.4. Using Manifests and Discovery](#114-using-manifests-and-discovery)
    * [11.5. Application Bootstrap Sequence](#115-application-bootstrap-sequence)
    * [11.6. Handling Circular Dependencies (Detection)](#116-handling-circular-dependencies-detection)
12. [Testing Strategy Notes (`ContainerSystem`)](#12-testing-strategy-notes-containersystem)
13. [Future Considerations & Potential Enhancements](#13-future-considerations--potential-enhancements)

---

## 1. Introduction to the ContainerSystem

### 1.1. Purpose & Core Responsibilities
The `ContainerSystem` is the heart of the TSMIS application's startup and runtime component management. It is a sophisticated Dependency Injection (DI) and Inversion of Control (IoC) container. Its primary responsibilities are:

* **Managing Component Lifecycles**: Orchestrating the creation, initialization, and eventual shutdown of registered application components (including other core systems, services, and business modules)[cite: 95].
* **Dependency Injection**: Automatically resolving and injecting declared dependencies into components when they are created or resolved[cite: 95].
* **Centralized Registry**: Acting as a central place where all major shared components of the application are registered and can be retrieved[cite: 96].
* **Facilitating Loose Coupling**: By managing dependencies, it allows components to be developed and tested more independently[cite: 96].
* **Component Discovery**: Optionally discovering and loading components from the filesystem based on predefined manifests[cite: 104, 143].

It ensures that the application is assembled correctly, dependencies are met, and components are started and stopped in a predictable and orderly fashion.

### 1.2. Key Features
* **Flexible Component Registration**: Supports registration of components as classes, factory functions, or pre-resolved instances[cite: 14, 16, 99, 100, 105, 106, 107, 109, 110, 111].
* **Automatic Dependency Resolution**: Analyzes `static dependencies` arrays on components to build a dependency graph and inject required instances.
* **Ordered Initialization & Shutdown**: Initializes components in a topologically sorted order respecting their dependencies, and shuts them down in reverse order.
* **Singleton Scope Management**: Primarily manages components as singletons, caching and reusing instances by default.
* **Manifest-Based Discovery**: Can scan directories for components, loading and validating them based on registered manifests.
* **Circular Dependency Detection**: Identifies and reports circular dependencies during the resolution or initialization phase, preventing an unstable application state[cite: 47, 48, 97, 131, 132].
* **Event Emission**: Emits various events related to its operations (e.g., `component:registered`, `initialized`) allowing other parts of the system to react[cite: 13, 16, 21, 22, 39, 44, 58, 59, 98, 139, 140, 141, 142].
* **Standardized Core Features**: Adheres to the TSMIS core standardization pillars for state management, error handling, lifecycle, health monitoring, and metrics.

## 2. Core Concepts

### 2.1. Dependency Injection (DI) & Inversion of Control (IoC)
* **IoC**: The `ContainerSystem` inverts the control of object creation and management. Instead of components creating their own dependencies, the container creates and provides them[cite: 95].
* **DI**: Components declare their dependencies (typically via a `static dependencies` array listing the names of other registered components). The container then "injects" instances of these dependencies into the component when it's created (usually via constructor arguments or arguments to a factory function).

### 2.2. Components (Definition and Types)
A "component" in the context of `ContainerSystem` is any piece of functionality that the container manages. This can be:
* **Classes**: JavaScript classes whose instances will be managed by the container. The container will call `new Component(resolvedDependencies)`[cite: 99, 108, 117].
* **Factory Functions**: Functions that return a component instance. The container will call `Component(resolvedDependencies)`. These can be synchronous or asynchronous[cite: 99, 109, 110, 118].
* **Instances**: Pre-existing objects that are registered directly with the container. The container will return this instance as-is when resolved[cite: 100, 111, 119].

### 2.3. Manifests & Component Discovery
* **Manifests**: A manifest (registered via `registerManifest`) defines a "type" of component and can include metadata like a configuration schema (`configSchema`). This schema is used to validate the configuration of components discovered on the filesystem.
* **Discovery**: The `discover(type, basePath)` method allows the container to automatically find and prepare components of a specific manifest type within a given directory structure. This involves scanning for files (`scanDirectory`), loading their configuration (`loadConfig`), validating that configuration against the manifest's schema (`validateConfig`), and loading the component's implementation (`loadImplementation`).

### 2.4. Dependency Resolution & Order
* When a component is resolved or when `ContainerSystem.initialize()` is called, the container builds a dependency graph.
* It uses a topological sort algorithm (`resolveDependencyOrder`) based on the `static dependencies` arrays to determine the correct order for initializing components, ensuring that a component's dependencies are initialized before the component itself.
* This same order (reversed) is used for shutting down components.
* Circular dependencies are detected during this process, leading to a `ConfigError`[cite: 47, 48, 131, 132].

### 2.5. Singleton Scope
By default, all components registered as classes or factory functions are treated as **singletons**[cite: 106]. This means the `ContainerSystem` creates only one instance of such a component. The first time it's resolved, the instance is created and cached in `this.instances`[cite: 30, 31, 113, 121]. Subsequent calls to `resolve()` for the same component name will return the cached instance[cite: 30, 31, 113]. Pre-resolved instances registered with the container are inherently singletons. While `options.singleton: false` can be specified[cite: 158, 159], the current refactored `resolve` method primarily focuses on singleton caching; full transient behavior (not caching if `singleton: false`) would be an enhancement.

## 3. API Reference (`ContainerSystem`)

### 3.1. Constructor
**`new ContainerSystem(deps = {})`**
* **`deps`**: `object` (optional)
    * `deps.config`: `object` (optional, default: `{}`) - Configuration specific to the `ContainerSystem`'s operation (e.g., `container.initOrder`, `container.maxErrorHistory`).
    * `deps.errorSystem`: `ErrorSystem` (optional) - An instance of `ErrorSystem` for reporting internal errors.

### 3.2. Component Registration Methods

#### 3.2.1. `register(name: string, Component: Function | object, options = {}): ContainerSystem`
Registers a component (class, factory, or instance) with the container.
* **`name`**: `string` - The unique name for the component.
* **`Component`**: `Function | object` - The component's constructor (class), factory function, or the instance itself.
* **`options.singleton`**: `boolean` (default: `true`) - If `false`, implies transient scope (currently, resolve still caches singletons primarily).
* **Returns**: `ContainerSystem` - The container instance for chaining.
* **Throws**: `ConfigError` for duplicate names or if called on a shutdown container.
* **Emits**: `component:registered` event.

#### 3.2.2. `registerManifest(type: string, manifest: object): void`
Registers a component manifest used for discovery.
* **`type`**: `string` - Unique name for the component type.
* **`manifest`**: `object` - Object containing manifest data (e.g., `configSchema`).
* **Throws**: `ConfigError` for duplicate types or if called on a shutdown container.
* **Emits**: `manifest:registered` event.

### 3.3. Component Discovery Methods

#### 3.3.1. `async discover(type: string, basePath: string): Promise<Map<string, object>>`
Discovers components in a directory based on a manifest type.
* **Returns**: A `Promise` resolving to a `Map` of discovered components (`{ name, config, implementation }`).
* **Throws**: `ConfigError` if manifest type not found; `ServiceError` for general discovery failure.
* **Emits**: `discovery:error` for individual load failures, `discovery:completed` on success.

### 3.4. Component Resolution Methods

#### 3.4.1. `async resolve(name: string): Promise<any>`
Resolves and returns a component instance by name, handling dependency injection and singleton caching.
* **Returns**: `Promise<any>` - The resolved component instance.
* **Throws**: `ServiceError` if component not registered; `ConfigError` for dependency issues (missing, circular).
* **Emits**: `component:resolved` event.

### 3.5. Lifecycle Methods

#### 3.5.1. `async initialize(): Promise<void>`
Initializes all registered singleton components in dependency order. Calls `initialize()` on components that have this method.
* **Throws**: `ServiceError` or `ConfigError` if initialization fails.
* **Emits**: `system:initializing`, `system:initialized`, `system:running`.

#### 3.5.2. `async shutdown(): Promise<void>`
Shuts down all initialized singleton components in reverse dependency order. Calls `shutdown()` on components that have this method.
* **Throws**: `ServiceError` if shutdown fails.
* **Emits**: `system:shutting_down`, `system:shutdown`. Also `shutdown:error` for individual component shutdown failures.

### 3.6. Internal Utility Methods (Conceptual Overview)
These private methods support the public API:
* **`resolveDependencyOrder(): string[]`**: Determines component initialization order using topological sort based on `static dependencies`.
* **`async loadComponent(path, manifest): Promise<object|null>`**: Loads a single component's configuration and implementation from a given path, using the provided manifest for guidance (e.g., config validation).
* **`async scanDirectory(basePath): Promise<string[]>`**: Recursively scans the `basePath` to find all potential component files (e.g., `.js`, `.mjs`, `.cjs`).
* **`async loadConfig(path): Promise<object>`**: Loads configuration for a component. It first checks for a dedicated `[filename].config.js` file. If not found, it attempts to extract a `config` property or call a `config()` method from the component file itself. Defaults to `{ name: [filename], enabled: true }` if no other configuration is found.
* **`async validateConfig(config, schema): Promise<boolean>`**: Validates the loaded `config` object against the provided `schema` (from the component's manifest). It checks for required fields, correct types, enum values, pattern matches, and can execute a custom `_validate` function if present in the schema.
* **`async loadImplementation(path): Promise<Function|Class|Object>`**: Imports the JavaScript module at the given `path`. It attempts to identify the main export by looking for `module.default`, then a named export matching the filename, then common factory function patterns (e.g., `createSomething`), or a class constructor. As a fallback, it returns the entire module object.

### 3.7. Static Factory (`createContainerSystem`)
**`createContainerSystem(deps = {}): ContainerSystem`**
A factory function for creating `ContainerSystem` instances, suitable for dependency injection setups.

## 4. State Management (`ContainerSystem` Specifics)

The `ContainerSystem` adheres to the standard `this.state` object pattern:

**ContainerSystem**: Standard 'this.state' Object Structure

```javascript
// this.state = {
//   status: SYSTEM_STATUS.CREATED,
//   startTime: null,
//   errors: [], // Stores { error: CoreError, timestamp: string, context: object } for ContainerSystem's internal errors
//   metrics: new Map(),
//   healthChecks: new Map()
// };
```

* `status`: Current lifecycle status (`CREATED`, `INITIALIZING`, `RUNNING`, `SHUTTING_DOWN`, `SHUTDOWN`, `ERROR`).
* `startTime`: Timestamp of when initialization started or completed.
* `errors`: Array storing internal operational errors of the `ContainerSystem` itself.
* `metrics`: Map for storing operational metrics.
* `healthChecks`: Map for storing health check functions.

In addition to the standard state, `ContainerSystem` manages these key internal data structures (not part of `this.state` but critical to its operation):
* **`this.components: Map<string, { Component: Function | object, options: object }>`**: Stores the definitions and registration options of all registered components[cite: 10, 15].
* **`this.instances: Map<string, any>`**: Acts as a cache for resolved singleton component instances[cite: 11, 30, 31, 38, 39].
* **`this.dependencies: Map<string, Array<string>>`**: Stores the declared dependency names for each component, derived from `Component.dependencies`[cite: 11, 16, 31, 48].
* **`this.manifests: Map<string, object>`**: Stores registered component manifests, keyed by type, used for the discovery process[cite: 11, 13].

## 5. Lifecycle Management (`ContainerSystem` Specifics)

The `ContainerSystem` orchestrates its own lifecycle and that of the components it manages. It adheres to the standardized lifecycle methods and event emissions.

### 5.1. `initialize()` Process Flow
1.  Checks if already initialized; if so, logs an error (via `_handleInternalError`) and may return or throw `ServiceError`.
2.  Sets `state.status` to `SYSTEM_STATUS.INITIALIZING` and records `state.startTime`. Emits `LIFECYCLE_EVENTS.INITIALIZING`[cite: 44].
3.  Calls `resolveDependencyOrder()` to determine the correct initialization sequence for all registered components[cite: 41]. This involves a topological sort based on `static dependencies` and detects circular dependencies.
4.  Iterates through the ordered component names:
    * Calls `await this.resolve(componentName)` to get/create the instance and its dependencies.
    * If the resolved instance has an `initialize()` method and the container itself is not yet fully `RUNNING` (to avoid double init if `resolve` initialized it post-container-init), its `initialize()` method is called and awaited.
5.  Upon successful initialization of all components:
    * Sets `state.status` to `SYSTEM_STATUS.RUNNING`.
    * Records success metrics (e.g., `container.initialization.time`, `container.initialization.success`).
    * Emits `LIFECYCLE_EVENTS.INITIALIZED` and `LIFECYCLE_EVENTS.RUNNING`.
6.  If any error occurs during this process (e.g., dependency resolution failure, error in a component's `initialize()`):
    * Sets `state.status` to `SYSTEM_STATUS.ERROR`.
    * Records a failure metric.
    * The error is processed by `_handleInternalError`.
    * A `ServiceError` or `ConfigError` (wrapping the original cause) is thrown, halting further initialization.

### 5.2. `shutdown()` Process Flow
1.  Checks if already shutdown; if so, returns.
2.  Sets `state.status` to `SYSTEM_STATUS.SHUTTING_DOWN`. Emits `LIFECYCLE_EVENTS.SHUTTING_DOWN`.
3.  Calculates the reverse dependency order using `resolveDependencyOrder().reverse()`.
4.  Iterates through the reverse-ordered component names:
    * Retrieves the cached singleton instance from `this.instances`.
    * If the instance exists and has a `shutdown()` method, it is called and awaited.
    * Errors from individual component `shutdown()` methods are caught, an `shutdown:error` event is emitted, the error is logged via `_handleInternalError`, but these errors do *not* typically stop the shutdown of other components.
5.  Clears `this.instances` (but usually not `this.components`, `this.dependencies`, or `this.manifests`, allowing for potential re-initialization if designed for it, though current refactor treats shutdown as final for an instance).
6.  Upon completion of all component shutdowns:
    * Sets `state.status` to `SYSTEM_STATUS.SHUTDOWN` and clears `state.startTime`.
    * Records success metrics (e.g., `container.shutdown.time`, `container.shutdown.success`).
    * Emits `LIFECYCLE_EVENTS.SHUTDOWN`.
7.  If an error occurs in `resolveDependencyOrder` itself during shutdown:
    * Sets `state.status` to `SYSTEM_STATUS.ERROR`.
    * Records a failure metric.
    * The error is processed by `_handleInternalError`.
    * A `ServiceError` is thrown.

## 6. Error Handling within `ContainerSystem`

* **Internal Errors**: `ContainerSystem` uses a private `async _handleInternalError(error, context)` method for its own operational errors that are not directly propagated as the primary outcome of a public API call. This includes errors during the processing of multiple items (like individual component load failures during discovery or individual component shutdown failures during system shutdown). This method:
    1.  Ensures the error is a `ConfigError` or `ServiceError` (wrapping if necessary).
    2.  Logs the error to `this.state.errors`.
    3.  Records an `container.errors.internal` metric.
    4.  Uses `safeHandleError(this.deps.errorSystem, error, { source: 'ContainerSystem', ...context })` to report the error to the configured `ErrorSystem`.
* **Directly Thrown Errors**: For issues that make a public API operation immediately invalid or impossible to proceed with (e.g., registering a duplicate component, resolving an unknown component, circular dependencies), `ContainerSystem` throws `ConfigError` or `ServiceError` instances directly to the caller. These errors usually contain codes from `ErrorCodes.CONFIG` or `ErrorCodes.SERVICE`.
    * `ConfigError` examples: `DUPLICATE_COMPONENT`, `DUPLICATE_MANIFEST`, `MISSING_DEPENDENCY`, `CIRCULAR_DEPENDENCY`, `INVALID_TYPE` (for manifests), `LOAD_FAILED` (for component config), `VALIDATION_FAILED` (for component config).
    * `ServiceError` examples: `UNKNOWN_COMPONENT`, `ALREADY_INITIALIZED`, `DISCOVERY_FAILED`, `IMPLEMENTATION_LOAD_FAILED`, `INITIALIZATION_FAILED` (overall container init), `SHUTDOWN_FAILED` (overall container shutdown).

## 7. Event Integration (`ContainerSystem` Specifics)

`ContainerSystem` is an `EventEmitter` and emits several operational events, allowing other parts of the application to monitor and react to its activities:
* **`manifest:registered`**: When `registerManifest()` is successfully called. Payload: `{ type: string, manifest: object }`.
* **`component:registered`**: When `register()` is successfully called. Payload: `{ name: string, Component: Function | object }`.
* **`discovery:error`**: When an error occurs loading an individual component during a `discover()` operation. Payload: `{ path: string, error: ServiceError }`.
* **`discovery:completed`**: When a `discover()` operation finishes scanning and processing files for a specific type. Payload: `{ type: string, components: Map<string, object> }`.
* **`component:resolved`**: When `resolve()` successfully provides a component instance (after creation and potential initialization if the container is already running). Payload: `{ name: string, instance: any }`.
* **`shutdown:error`**: When a managed component's `shutdown()` method throws an error during the global `ContainerSystem.shutdown()` process. Payload: `{ component: string, error: ServiceError }`.

It also emits standard system lifecycle events for itself: `system:initializing`, `system:initialized`, `system:running`, `system:shutting_down`, `system:shutdown`, as defined in `SystemConstants.LIFECYCLE_EVENTS`.

## 8. Health Monitoring (`ContainerSystem` Specifics)

`ContainerSystem` implements the standard `checkHealth()` method, which aggregates results from its registered health checks.
* **Default Health Checks Registered**:
    * **`container.state`**: Reports the `ContainerSystem`'s current lifecycle `status` (from `this.state.status`), its `uptime` since initialization (if running), and the count of its internal `errors` (from `this.state.errors`).
    * **`container.components`**: Reports key statistics about the components it manages:
        * `registeredComponentCount: this.components.size`
        * `resolvedInstanceCount: this.instances.size` (for singletons)
        * `manifestCount: this.manifests.size`
* **Output Format**: `checkHealth()` returns a standardized health object, using `createStandardHealthCheckResult` for each of its sub-checks.

**ContainerSystem**: Example checkHealth() Output

```json
// {
//   "name": "ContainerSystem",
//   "version": "2.0.0",
//   "status": "healthy", // Could be "degraded" or "unhealthy" based on checks
//   "timestamp": "2025-05-19T05:18:00.123Z", // Example ISO timestamp
//   "uptime": 3600000, // Example uptime in milliseconds (e.g., 1 hour)
//   "errorCount": 0,    // Number of errors in this.state.errors
//   "checks": {
//     "container.state": {
//       "status": "healthy",
//       "detail": {
//         "currentStatus": "running",
//         "uptime": 3600000,
//         "internalErrorCount": 0
//       },
//       "errors": []
//     },
//     "container.components": {
//       "status": "healthy",
//       "detail": {
//         "registeredComponentCount": 15,
//         "resolvedInstanceCount": 12,
//         "manifestCount": 3
//       },
//       "errors": []
//     }
//     // ... any other custom health checks registered with ContainerSystem ...
//   }
// }
```

## 9. Metrics Tracking (`ContainerSystem` Specifics)

`ContainerSystem` implements `recordMetric()` and `getMetrics()` adhering to the standard.
Key metrics automatically recorded:
* **Lifecycle**:
    * `container.initialization.success` / `container.initialization.failure` (Count: 1)
    * `container.initialization.time` (Value: duration in ms)
    * `container.shutdown.success` / `container.shutdown.failure` (Count: 1)
    * `container.shutdown.time` (Value: duration in ms)
* **Internal Errors**:
    * `container.errors.internal` (Count: 1). Tags: `errorName`, `errorCode`.
* **Operational Counts**:
    * `container.manifests.registered` (Count: 1). Tags: `type`.
    * `container.components.registered` (Count: 1). Tags: `name`.
    * `container.components.resolved` (Count: 1). Tags: `name`, `singleton` (boolean).
    * `container.discovery.started` (Count: 1). Tags: `type`, `basePath`.
    * `container.discovery.completed` (Count: 1). Tags: `type`, `count` (number of components discovered).
    * `container.discovery.failed` (Count: 1). Tags: `type`.

## 10. Integrations (ContainerSystem Level)

* **`ErrorSystem`**: If an `ErrorSystem` instance is provided in `deps.errorSystem` during construction, `ContainerSystem` uses it via the `safeHandleError` utility to report its own internal operational errors. This ensures container-related issues are centrally logged and managed.
* **Configuration (`deps.config`)**: The `ContainerSystem` can receive its own operational configuration via `deps.config`. Examples include:
    * `deps.config.container.initOrder: string[]`: An optional array of component names to prioritize during the `initialize()` sequence. This allows ensuring critical systems like `ErrorSystem` or `ConfigSystem` are initialized first.
    * `deps.config.container.maxErrorHistory: number`: To control the size of its internal `this.state.errors` buffer.
* **Application Components (Core Systems, Services, Business Modules)**: This is the primary and most crucial integration. `ContainerSystem`:
    * **Registers** these components via `register()` or `registerManifest()` + `discover()`.
    * **Resolves their dependencies** by looking up other components registered within itself based on `static dependencies` arrays.
    * **Injects these resolved dependencies** into components upon their creation (via constructor arguments for classes, or as arguments to factory functions).
    * **Manages their lifecycle** by calling their `initialize()` and `shutdown()` methods in the correct, dependency-aware order.
* **Node.js Filesystem (`fs/promises`, `path`, `fs`)**: These are used internally by the `discover()` related methods (`scanDirectory`, `loadConfig`, `loadImplementation`) for reading component files and their configurations from the disk. These are direct Node.js API usages rather than integrations with other TSMIS systems.
* **`EventBusSystem` (Indirectly)**: `ContainerSystem` itself emits events (e.g., `component:registered`, `initialized`). While it doesn't directly call `EventBusSystem`, these events can be listened to by any system that has access to the `ContainerSystem` instance and subscribes to its events. An `EventBusSystem` or a dedicated monitoring component could subscribe to these to log container activities or trigger other actions.

## 11. Usage Examples & Best Practices
### 11.1 "Basic Registration and Resolution"

**ContainerSystem**: Basic Component Registration and Resolution

```javascript
// Assuming ContainerSystem and createContainerSystem are imported
// import { createContainerSystem } from './core/container/ContainerSystem.js'; // Adjust path

// // 1. Create a ContainerSystem instance
// const container = createContainerSystem({
//   // Optional dependencies for the container itself (e.g., logger, global config)
//   // config: { container: { maxErrorHistory: 50 } },
//   // errorSystem: myErrorSystemInstance // if ErrorSystem is already created
// });

// // 2. Define a simple component (class)
// class SimpleLogger {
//   constructor() {
//     this.prefix = '[Logger]';
//     console.log('SimpleLogger instance created.');
//   }

//   log(message) {
//     console.log(`${this.prefix} ${message}`);
//   }

//   async initialize() {
//     console.log('SimpleLogger initialized.');
//   }

//   async shutdown() {
//     console.log('SimpleLogger shutdown.');
//   }
// }

// // 3. Register the component with the container
// container.register('logger', SimpleLogger);
// // 'logger' is the name used to resolve this component.
// // By default, it's registered as a singleton.

// // 4. Initialize the container (and all registered components)
// async function startApp() {
//   try {
//     await container.initialize(); // Calls SimpleLogger.initialize()
//     console.log('ContainerSystem initialized.');

//     // 5. Resolve the component instance
//     const loggerInstance = await container.resolve('logger');
//     loggerInstance.log('Hello from the resolved logger!');

//     // Subsequent resolves for a singleton return the same instance
//     const anotherLoggerInstance = await container.resolve('logger');
//     console.log('Are logger instances the same?', loggerInstance === anotherLoggerInstance); // true

//     // 6. Shutdown the container
//     await container.shutdown(); // Calls SimpleLogger.shutdown()
//     console.log('ContainerSystem shutdown complete.');

//   } catch (error) {
//     console.error('Application error:', error);
//     // In a real app, ensure errorSystem handles this if container init/shutdown fails
//   }
// }

// // startApp();
```

### 11.3 "Defining Component Dependencies

**ContainerSystem**: Defining and Resolving Component Dependencies

```javascript
// Assuming ContainerSystem and createContainerSystem are imported
// import { createContainerSystem } from './core/container/ContainerSystem.js';

// // 1. Define a LoggerService component (same as before or simpler)
// class LoggerService {
//   log(message) {
//     console.log(`[LoggerService] ${message}`);
//   }
//   async initialize() { console.log('LoggerService initialized.'); }
//   async shutdown() { console.log('LoggerService shutdown.'); }
// }

// // 2. Define a UserService that depends on LoggerService
// class UserService {
//   // Declare 'logger' (the registered name of LoggerService) as a dependency
//   static dependencies = ['logger']; // [cite: 101]

//   constructor(dependencies) {
//     // The container will inject an object where 'logger' is the resolved LoggerService instance
//     this.logger = dependencies.logger; // [cite: 101]
//     if (!this.logger) {
//       throw new Error("Logger dependency was not injected into UserService!");
//     }
//     console.log('UserService instance created, logger injected.');
//   }

//   async initialize() {
//     this.logger.log('UserService initializing...');
//     // ... other initialization logic for UserService ...
//     console.log('UserService initialized.');
//   }

//   createUser(name) {
//     this.logger.log(`Creating user: ${name}`);
//     // ... actual user creation logic ...
//     return { id: Date.now(), name };
//   }

//   async shutdown() {
//     this.logger.log('UserService shutting down...');
//     console.log('UserService shutdown.');
//   }
// }

// // 3. Create the container and register components
// const container = createContainerSystem();
// container.register('logger', LoggerService);
// container.register('userService', UserService); // ContainerSystem reads UserService.dependencies

// // 4. Initialize and use
// async function appWithDependencies() {
//   try {
//     await container.initialize(); // Initializes logger, then userService
//     console.log('ContainerSystem with dependencies initialized.');

//     const userServiceInstance = await container.resolve('userService');
//     const user = userServiceInstance.createUser('Alice');
//     console.log('User created:', user);

//     await container.shutdown(); // Shuts down userService, then logger
//     console.log('ContainerSystem with dependencies shutdown complete.');
//   } catch (error) {
//     console.error('Application error:', error);
//   }
// }

// // appWithDependencies();
```

### 11.2 Registering Different Component Types), specifically focusing on factory functions

**ContainerSystem**: Registering Components with Factory Functions

```javascript
// Assuming ContainerSystem, createContainerSystem are imported
// import { createContainerSystem } from './core/container/ContainerSystem.js';
// Assume LoggerService is defined and registered as 'logger'

// // --- Example 1: Synchronous Factory Function ---
// function createSimpleConfigService(dependencies) {
//   // dependencies.logger would be injected if 'logger' was in SimpleConfigService.dependencies
//   const logger = dependencies.logger || console; // Fallback if logger not a formal dependency
//   logger.log('[SimpleConfigService Factory] Creating SimpleConfigService instance.');
//   return {
//     appName: 'TSMIS App (via Sync Factory)',
//     getAppName: function() { return this.appName; },
//     async initialize() { logger.log('[SimpleConfigService] Initialized (Sync Factory).'); },
//     async shutdown() { logger.log('[SimpleConfigService] Shutdown (Sync Factory).'); }
//   };
// }
// // If the factory needs dependencies from the container:
// // createSimpleConfigService.dependencies = ['logger'];


// // --- Example 2: Asynchronous Factory Function ---
// async function createAsyncDatabaseService(dependencies) {
//   const logger = dependencies.logger; // Assuming 'logger' is a declared dependency
//   logger.log('[AsyncDatabaseService Factory] Starting to create AsyncDatabaseService instance...');

//   // Simulate async operation, e.g., connecting to a database
//   await new Promise(resolve => setTimeout(resolve, 50)); // Simulate delay

//   const dbInstance = {
//     connectionString: 'mydb://localhost/prod_db_async',
//     query: async function(sql) {
//       logger.log(`[AsyncDatabaseService] Executing query: ${sql}`);
//       return [{ id: 1, data: 'async_result' }];
//     },
//     async initialize() { logger.log('[AsyncDatabaseService] Initialized.'); },
//     async shutdown() { logger.log('[AsyncDatabaseService] Shutdown.'); }
//   };
//   logger.log('[AsyncDatabaseService Factory] AsyncDatabaseService instance created.');
//   return dbInstance;
// }
// // Declare dependencies for the factory function itself
// createAsyncDatabaseService.dependencies = ['logger'];


// // --- Example 3: Factory for a component that itself has dependencies (less common for factory to *define* a class this way)
// // More often, the factory *returns* an instance of an already defined class, or a simple object.
// function createComplexServiceFactory(deps) {
//     // deps.logger and deps.configService are injected into the factory
//     deps.logger.log('[ComplexService Factory] Creating ComplexService instance.');
//     class ComplexService {
//         constructor(innerDeps) { // This class's constructor doesn't get DI from container directly here
//             this.logger = innerDeps.logger;
//             this.configService = innerDeps.configService;
//             this.creationTimestamp = Date.now();
//         }
//         getInfo() {
//             this.logger.log(`[ComplexService] Info: AppName = ${this.configService.getAppName()}, CreatedAt = ${this.creationTimestamp}`);
//         }
//         async initialize() { this.logger.log('[ComplexService] Initialized.'); }
//         async shutdown() { this.logger.log('[ComplexService] Shutdown.'); }
//     }
//     // The factory provides the dependencies to the class it instantiates.
//     return new ComplexService({ logger: deps.logger, configService: deps.configService });
// }
// createComplexServiceFactory.dependencies = ['logger', 'configService']; // Dependencies for the factory


// // --- Registration and Usage ---
// async function appWithFactories() {
//   const container = createContainerSystem();

//   // Register LoggerService (as a class)
//   class LoggerService { log(m){console.log(m);} async initialize(){console.log('LoggerService Init');} async shutdown(){console.log('LoggerService Shutdown');}}
//   container.register('logger', LoggerService);

//   // Register components using their factory functions
//   container.register('configService', createSimpleConfigService);
//   container.register('dbService', createAsyncDatabaseService);
//   container.register('complexService', createComplexServiceFactory);


//   try {
//     await container.initialize(); // Initializes logger, then configService, dbService, complexService
//     console.log('ContainerSystem with factories initialized.');

//     const config = await container.resolve('configService');
//     console.log('App Name from ConfigService:', config.getAppName());

//     const db = await container.resolve('dbService');
//     const results = await db.query('SELECT * FROM users');
//     console.log('DB Query Results:', results);
    
//     const complexSvc = await container.resolve('complexService');
//     complexSvc.getInfo();

//     await container.shutdown();
//     console.log('ContainerSystem with factories shutdown complete.');

//   } catch (error) {
//     console.error('Application error with factories:', error);
//   }
// }

// // appWithFactories();
```

### 11.4 Using Manifests and Discovery

**ContainerSystem**: Using Manifests and Component Discovery

```javascript
// Assuming ContainerSystem, createContainerSystem are imported
// import { createContainerSystem } from './core/container/ContainerSystem.js';
// Assume the following directory structure and files for discovery:
//
// src/
// └── modules/
//     └── reporting/
//         ├── ReportGeneratorService.js
//         ├── ReportGeneratorService.config.js
//         └── DataAggregatorService.js
//             // (No .config.js, will use default or embedded config)

// --- File: src/modules/reporting/ReportGeneratorService.config.js ---
// // export default {
// //   name: 'reportGenerator', // Overrides filename-based naming
// //   enabled: true,
// //   outputFormat: 'pdf',
// //   schedule: 'daily'
// // };

// --- File: src/modules/reporting/ReportGeneratorService.js ---
// // export default class ReportGeneratorService {
// //   constructor(deps) { this.config = deps.config.moduleConfig; this.logger = deps.logger; }
// //   static dependencies = ['logger']; // Assuming logger is registered
// //   async initialize() { this.logger.log(`ReportGeneratorService (${this.config.name}) initialized. Format: ${this.config.outputFormat}`); }
// //   generate() { this.logger.log(`Generating ${this.config.outputFormat} report on schedule: ${this.config.schedule}`); }
// // }

// --- File: src/modules/reporting/DataAggregatorService.js ---
// // export const config = { // Embedded config
// //   name: 'dataAggregator',
// //   enabled: true,
// //   source: 'realtimeDB'
// // };
// //
// // export default class DataAggregatorService {
// //   constructor(deps) { this.config = deps.config.moduleConfig; this.logger = deps.logger; }
// //   static dependencies = ['logger'];
// //   async initialize() { this.logger.log(`DataAggregatorService (${this.config.name}) initialized. Source: ${this.config.source}`); }
// //   aggregate() { this.logger.log('Aggregating data...'); }
// // }


// --- Application Setup ---
// async function appWithDiscovery() {
//   const container = createContainerSystem();

//   // Register a simple logger for dependency injection
//   class Logger { log(m){console.log(m);} async initialize(){console.log('Logger for Discovery Init');} }
//   container.register('logger', Logger);

//   // 1. Register a manifest for 'service' components
//   container.registerManifest('service', {
//     configSchema: { // Schema to validate the .config.js or embedded config
//       name: { type: 'string', required: true },
//       enabled: { type: 'boolean', default: true },
//       outputFormat: { type: 'string', enum: ['pdf', 'csv', 'html'] }, // Example specific field
//       schedule: { type: 'string' },
//       source: { type: 'string' }
//     }
//   });
//   console.log("Manifest 'service' registered.");

//   // 2. Discover components of type 'service' from a base path
//   // Note: For real execution, ensure paths are correct and async import works in your environment.
//   // This example assumes files are structured as above relative to a base path.
//   // The actual file system scanning part would require running this in a Node.js environment
//   // with appropriate permissions and correct relative paths.
//   let discoveredServices;
//   try {
//     // Assuming this script is run from a directory where './src/modules/reporting' is a valid path
//     // For testing, you might mock the fs/promises and path modules used by scanDirectory.
//     const discoveryPath = './src_example/modules/reporting'; // Path to the 'reporting' directory
//     console.log(`Attempting to discover services in: ${discoveryPath}`);
//     discoveredServices = await container.discover('service', discoveryPath);
//     console.log(`Discovered ${discoveredServices.size} services.`);
//   } catch (error) {
//     console.error('Discovery process failed:', error);
//     // Handle discovery failure (e.g., path doesn't exist, manifest type unknown)
//     await container.shutdown();
//     return;
//   }

//   // 3. Register discovered components with the container
//   if (discoveredServices && discoveredServices.size > 0) {
//     for (const [name, componentDef] of discoveredServices.entries()) {
//       if (componentDef.config.enabled !== false) { // Check if enabled
//         console.log(`Registering discovered component: ${name}`);
//         container.register(
//           name, // Name comes from componentDef.name (from config or filename)
//           componentDef.implementation, // The loaded class/factory
//           { moduleConfig: componentDef.config } // Pass loaded config to the component instance via options
//                                                 // The component constructor would then access it via deps.config.moduleConfig
//         );
//       } else {
//         console.log(`Skipping registration of disabled component: ${name}`);
//       }
//     }
//   } else {
//     console.log('No services discovered or all were disabled.');
//   }

//   // 4. Initialize the container
//   try {
//     await container.initialize(); // Initializes logger, reportGenerator, dataAggregator
//     console.log('Container initialized with discovered services.');

//     // 5. Resolve and use a discovered service
//     if (container.components.has('reportGenerator')) {
//       const reportService = await container.resolve('reportGenerator');
//       reportService.generate();
//     }
//     if (container.components.has('dataAggregator')) {
//       const dataService = await container.resolve('dataAggregator');
//       dataService.aggregate();
//     }

//   } catch (error) {
//     console.error('Error during initialization or usage of discovered services:', error);
//   } finally {
//     await container.shutdown();
//     console.log('Container shutdown after discovery example.');
//   }
// }

// // appWithDiscovery();
// // Note: To run this fully, you'd need to create the example file structure and content
// // in a 'src_example/modules/reporting' directory relative to where this script runs,
// // and ensure your Node version supports dynamic import() used by container.loadImplementation().
```

### 11.5 Application Bootstrap Sequence

**ContainerSystem**: Example Application Bootstrap Sequence 

```javascript
// src/app.js (Conceptual Bootstrap File)

// import { createContainerSystem } from './core/container/ContainerSystem.js';
// import { createErrorSystem } from './core/errors/ErrorSystem.js';
// import { ErrorCodes } from './core/errors/ErrorCodes.js'; // For any direct error creation if needed
// import { createEventBusSystem } from './core/event/EventBusSystem.js';
// import { createModuleSystem } from './core/module/ModuleSystem.js';
// import { createRouterSystem } from './core/router/RouterSystem.js';

// // Example: Business module and service imports
// import { createInventoryService } from './modules/inventory/InventoryService.js';
// import { InventoryModule } from './modules/inventory/InventoryModule.js';
// import { FastifyAdapter } from './core/router/integrations/fastify/FastifyAdapter.js'; // Assuming Fastify
// import Fastify from 'fastify';

// async function bootstrapApplication() {
//   let container;
//   try {
//     console.log('[Bootstrap] Starting application bootstrap...');

//     // 1. Create the main ContainerSystem instance
//     container = createContainerSystem({
//       // Optional global config for the container itself
//       config: {
//         container: {
//           // Ensure critical systems are initialized in this order if they have inter-dependencies
//           // that are not solely managed by their static dependencies array.
//           initOrder: ['config', 'logger', 'errorSystem', 'eventBusSystem', 'moduleSystem', 'routerSystem'],
//           maxErrorHistory: 20, // Container's own internal error log size
//         }
//       }
//       // errorSystem is not available yet to pass to container's constructor,
//       // so container's _handleInternalError would use console.error for very early errors.
//     });
//     console.log('[Bootstrap] ContainerSystem created.');

//     // 2. Register Core Systems & Foundational Services
//     // These are critical for the application and other modules/services.
//     container.register('appConfig', () => ({ // Simple config component
//       appName: 'TSMIS Core Application',
//       port: process.env.PORT || 3000,
//       environment: process.env.NODE_ENV || 'development',
//       inventory: { lowStockThreshold: 10 }, // Module-specific config section
//       inventoryService: { allowNegativeStock: false } // Service-specific config section
//     }));
//     container.register('logger', () => console); // Basic logger, could be a more advanced LoggingSystem

//     // ErrorSystem depends on 'logger' and 'appConfig' (implicitly, via 'config' alias in its deps)
//     // For simplicity, assuming direct naming match for deps in createXSystem factories.
//     // If ErrorSystem explicitly depends on 'appConfig', it should be named 'appConfig' in its deps.
//     // Or, ContainerSystem can be enhanced to map 'config' to 'appConfig' for specific components.
//     // Let's assume createErrorSystem expects 'config' and 'logger'.
//     container.register('errorSystem', createErrorSystem);
//     container.register('eventBusSystem', createEventBusSystem); // Depends on errorSystem, config
//     container.register('moduleSystem', createModuleSystem);   // Depends on errorSystem, eventBusSystem, config
//     container.register('routerSystem', createRouterSystem);   // Depends on errorSystem, eventBusSystem, config
//     console.log('[Bootstrap] Core systems registered.');

//     // 3. Register Application-Specific Services
//     container.register('inventoryService', createInventoryService); // Depends on config, logger
//     console.log('[Bootstrap] Application services registered.');

//     // 4. Register Business Modules with ModuleSystem (after ModuleSystem is resolved)
//     // This step is often done after core systems are available but before full container.initialize()
//     // if module registration itself needs resolved core systems.
//     // Alternatively, ModuleSystem can be initialized first, then modules registered, then MS.initialize().
//     // For this example, we register modules before global container.initialize(),
//     // and ModuleSystem.initialize() (called by container.initialize()) will handle their init.
//     const moduleSystem = await container.resolve('moduleSystem'); // Resolve MS to register modules
//     await moduleSystem.register('inventory', InventoryModule, container.resolve('appConfig').inventory);
//     console.log('[Bootstrap] Business modules registered with ModuleSystem.');

//     // 5. Initialize the Container (and all registered components)
//     // This will initialize components in dependency order.
//     // ErrorSystem -> Config -> EventBusSystem -> ModuleSystem & RouterSystem (parallel if no direct dep) -> Services -> Modules
//     await container.initialize();
//     console.log('[Bootstrap] ContainerSystem and all components initialized successfully.');

//     // 6. Setup HTTP Server and Apply Routes (if applicable)
//     const routerSystem = await container.resolve('routerSystem');
//     const appConfig = await container.resolve('appConfig');
//     const errorSystem = await container.resolve('errorSystem'); // For Fastify error handler setup

//     const fastifyApp = Fastify({
//       logger: {
//         level: appConfig.environment === 'development' ? 'debug' : 'info',
//         // Serializer setup would use createFastifyLoggerErrorSerializer
//       }
//     });

//     // Setup Fastify error handling using ErrorSystem's integration
//     // This assumes ErrorSystem.registerIntegration was called or a helper is available
//     // This part needs the actual FastifyErrorHandler to be registered with ErrorSystem.
//     // For example, if ErrorSystem had a method: await errorSystem.setupFramework(fastifyApp, 'fastify');
//     // Or more directly:
//     // const feh = new FastifyErrorHandler();
//     // await errorSystem.registerIntegration('fastify', FastifyErrorHandler, fastifyApp, { errorSystem });
//     // The above line (registerIntegration) should ideally happen after errorSystem is initialized,
//     // often as part of an "api layer" setup module or right after container init.
//     // For simplicity, we'll assume it's configured.

//     routerSystem.registerAdapter('fastify', new FastifyAdapter({ logger: fastifyApp.log }));
//     await routerSystem.applyRoutes(fastifyApp, 'fastify');
//     console.log('[Bootstrap] Routes applied to Fastify.');

//     await fastifyApp.listen({ port: appConfig.port });
//     console.log(`[Bootstrap] Server listening on port ${appConfig.port} in ${appConfig.environment} mode.`);

//     return { container, fastifyApp }; // Return container and app for potential further use/testing

//   } catch (error) {
//     console.error('[Bootstrap] CRITICAL BOOTSTRAP FAILURE:', error.message, error.details, error.stack);
//     // Attempt to use logger if available, otherwise console
//     const logger = container?.instances.get('logger') || console;
//     const errorSystem = container?.instances.get('errorSystem');
//     if (errorSystem && errorSystem.handleError) {
//       await errorSystem.handleError(error, { phase: 'bootstrap', criticality: 'high' }).catch(e => console.error("Error handling the bootstrap error:", e));
//     } else if (logger) {
//       logger.error("CRITICAL BOOTSTRAP FAILURE (ErrorSystem unavailable):", error);
//     }
//     // Graceful shutdown attempt if container exists
//     if (container && container.state.status !== SYSTEM_STATUS.SHUTDOWN) {
//       try {
//         await container.shutdown();
//       } catch (shutdownError) {
//         console.error('[Bootstrap] Error during shutdown after bootstrap failure:', shutdownError);
//       }
//     }
//     process.exit(1); // Exit if bootstrap is critical
//   }
// }

// // bootstrapApplication();
```

* **Best Practices**:
    * **Central Instance**: Typically, a single `ContainerSystem` instance is created at the root of the application to manage all global/shared components.
    * **Register Core Systems First**: Ensure foundational systems like `ErrorSystem`, `ConfigSystem` (if you build one), and `EventBusSystem` are registered early, especially if other components depend on them.
    * **Declare Dependencies Explicitly**: Components should clearly declare their dependencies via a `static dependencies = ['depName1', 'depName2'];` array[cite: 101, 108, 175]. This is crucial for the container's dependency resolution and initialization ordering.
    * **Use Factory Functions for Complex Instantiation**: For components that require complex setup logic or have dependencies not managed by the container during their *own* construction, use a factory function. The factory function itself will receive its declared dependencies from the container.
    * **Manage Lifecycle in Components**: Components that require setup (e.g., establishing database connections, starting timers, subscribing to external events) or cleanup should implement `async initialize()` and `async shutdown()` methods for the container to call.
    * **Avoid Resolving Too Early or Manually**: Prefer dependency injection (having the container provide dependencies via constructor/factory) over manually calling `container.resolve()` within a component's constructor or early lifecycle methods. Let the container manage the wiring. Resolve components only when explicitly needed by application logic outside the DI flow, or during the bootstrap phase.
    * **Configuration**: Pass necessary configuration to components at registration time or ensure they can access a central configuration component that is also managed by the container.
    * **Manifests for Pluggable Components**: Leverage the manifest and discovery system for components that are designed to be pluggable or when dealing with a large number of similar components that can be discovered from the filesystem.

## 12. Testing Strategy Notes (`ContainerSystem`)
* **Registration**: Test `register()` with classes, factory functions (synchronous and asynchronous), and direct instances. Verify that `options` (like `singleton`) are correctly processed. Test `registerManifest()`. Ensure `ConfigError` is thrown for duplicate registrations.
* **Resolution**:
    * Verify correct instance creation and that constructor/factory functions are called with correctly resolved dependencies.
    * Test singleton behavior: multiple `resolve()` calls for the same component name (if registered as singleton) should return the exact same instance.
    * Test resolution of deeply nested dependencies.
    * Test for `ServiceError` (unknown component) and `ConfigError` (missing dependency).
* **Dependency Order & Circularity**: Test `resolveDependencyOrder()` logic with various dependency graphs. Crucially, test that `ConfigError` is thrown when circular dependencies are present between components.
* **Lifecycle Management**:
    * Mock components with `initialize()` and `shutdown()` methods (some succeeding, some throwing errors).
    * Verify `ContainerSystem.initialize()` calls component `initialize()` methods in the correct dependency-aware order.
    * Verify `ContainerSystem.shutdown()` calls component `shutdown()` methods in the correct reverse dependency order.
    * Test error handling during component init/shutdown (e.g., ensure `ContainerSystem.initialize()` fails if a critical component fails to initialize; ensure `ContainerSystem.shutdown()` continues with other components if one fails, and emits `shutdown:error`).
* **Discovery (`discover`, `loadComponent`, etc.)**:
    * Mock filesystem interactions (`fs/promises`, `fs`, `path`) extensively.
    * Test with various file structures: valid components, components with missing or invalid `*.config.js` files, components that are marked `enabled: false` in their config.
    * Test `validateConfig` with valid and invalid schemas.
    * Test `loadImplementation` with different module export styles (`default`, named exports).
    * Verify correct emission of `discovery:error` and `discovery:completed`.
* **State, Health, Metrics**: Ensure `this.state` (status, errors, metrics, healthChecks) is updated correctly throughout the container's operations. Test `checkHealth()` output for accuracy and completeness based on the container's state. Verify that all documented metrics are recorded with correct tags and values.
* **Event Emission**: Mock event listeners to verify that all documented operational and lifecycle events are emitted by `ContainerSystem` with the correct payloads at the appropriate times.

## 13. Future Considerations & Potential Enhancements
(Adapted from original documentation)
* **Scoped/Child Containers**: Introduce support for hierarchical or scoped containers. This would allow for more granular dependency management, such as creating a new scope per HTTP request or for specific application features, enabling request-specific services or overriding global services within a limited scope.
* **Advanced Component Discovery**: Enhance discovery with features like:
    * Dynamic reloading/unloading of components or modules at runtime (hot-swapping).
    * More sophisticated file watching or plugin mechanisms.
    * Support for component versioning during discovery and resolution.
* **Lazy Initialization**: Provide an option for components to be fully initialized only when they are first resolved via `container.resolve()`, rather than all components being initialized upfront during `container.initialize()`. This could significantly improve application startup time if many components are registered but not immediately needed.
* **Dependency Graph Visualization**: Develop or integrate tooling to visualize the dependency graph of registered components. This would be invaluable for understanding complex application structures, debugging dependency issues, and architectural analysis.
* **Asynchronous Registration**: Consider allowing the `register()` method to accept a Promise if the component definition or its factory function itself needs to perform asynchronous operations before it can be fully defined or made available to the container.
* **Enhanced Configuration Injection**: Explore more direct or typed ways to inject specific configuration values into components, potentially with more sophisticated schema validation and type coercion at the point of injection, beyond just passing the entire `config` object as a dependency.
* **Full Transient Component Support**: Modify the `resolve` method to fully support transient scope by not caching instances if `options.singleton` is explicitly set to `false`. This would create a new instance every time `resolve()` is called for such a component.
* **Conditional Registration**: Allow components to be registered based on certain conditions or environment flags.


// src/core/container/index.js

/**
 * @file src/core/container/index.js
 * @description Barrel file for exporting the ContainerSystem and its factory.
 */

import { ContainerSystem, createContainerSystem } from './ContainerSystem.js';

export {
  ContainerSystem,
  createContainerSystem,
};

// Optional default export if preferred for commonJS-style imports or specific bundling strategies
// export default {
//   ContainerSystem,
//   createContainerSystem,
// };


// src/core/core_architecture.md

# TSMIS Core Architecture Guide
Version: 2.0.0 (Refactored Core)

## Table of Contents

1.  [Introduction to the TSMIS Core Architecture](#1-introduction-to-the-tsmis-core-architecture)
    * [1.1. Purpose of this Guide](#11-purpose-of-this-guide)
    * [1.2. What is TSMIS? (System Overview)](#12-what-is-tsmis-system-overview)
    * [1.3. Goals of the Core Architecture](#13-goals-of-the-core-architecture)
    * [1.4. Key Architectural Principles Driving TSMIS](#14-key-architectural-principles-driving-tsmis)
2.  [Naming Conventions](#2-naming-conventions)
    * [2.1. File Naming](#21-file-naming)
    * [2.2. Class & Constructor Naming](#22-class--constructor-naming)
    * [2.3. Method & Function Naming](#23-method--function-naming)
    * [2.4. Variable Naming](#24-variable-naming)
    * [2.5. Constant Naming](#25-constant-naming)
    * [2.6. Event Naming](#26-event-naming)
    * [2.7. Error Code Naming](#27-error-code-naming)
    * [2.8. Metric Naming](#28-metric-naming)
    * [2.9. Configuration Key Naming](#29-configuration-key-naming)
3.  [Core Foundational Pillars](#3-core-foundational-pillars)
    * [3.1. Standard `this.state` Object](#31-standard-thisstate-object)
    * [3.2. Standardized Error Handling Framework](#32-standardized-error-handling-framework)
    * [3.3. Standardized Lifecycle Management](#33-standardized-lifecycle-management)
    * [3.4. Standardized Health Monitoring](#34-standardized-health-monitoring)
    * [3.5. Standardized Metrics Tracking](#35-standardized-metrics-tracking)
    * [3.6. Standardized Factory Functions](#36-standardized-factory-functions)
    * [3.7. Shared Utilities Overview](#37-shared-utilities-overview)
4.  [Overview of Core Systems](#4-overview-of-core-systems)
    * [4.1. The Core Systems Landscape](#41-the-core-systems-landscape)
    * [4.2. Holistic System Interaction Diagram](#42-holistic-system-interaction-diagram)
5.  [Deep Dive into Core Systems (Summaries)](#5-deep-dive-into-core-systems-summaries)
    * [5.1. `ContainerSystem`](#51-containersystem)
        * [5.1.1. Primary Responsibility](#511-primary-responsibility)
        * [5.1.2. Key Functionalities & API Summary](#512-key-functionalities--api-summary)
        * [5.1.3. Adherence to Standardization Pillars](#513-adherence-to-standardization-pillars)
        * [5.1.4. Key Integrations](#514-key-integrations)
    * [5.2. `ErrorSystem` & `CoreError`](#52-errorsystem--coreerror)
        * [5.2.1. Primary Responsibility](#521-primary-responsibility)
        * [5.2.2. Key Functionalities & API Summary](#522-key-functionalities--api-summary)
        * [5.2.3. Adherence to Standardization Pillars](#523-adherence-to-standardization-pillars)
        * [5.2.4. Key Integrations](#524-key-integrations)
    * [5.3. `EventBusSystem` & `CoreEventBus`](#53-eventbussystem--coreeventbus)
        * [5.3.1. Primary Responsibility](#531-primary-responsibility)
        * [5.3.2. Key Functionalities & API Summary](#532-key-functionalities--api-summary)
        * [5.3.3. Adherence to Standardization Pillars](#533-adherence-to-standardization-pillars)
        * [5.3.4. Key Integrations](#534-key-integrations)
    * [5.4. `ModuleSystem` & `CoreModule`](#54-modulesystem--coremodule)
        * [5.4.1. Primary Responsibility](#541-primary-responsibility)
        * [5.4.2. Key Functionalities & API Summary](#542-key-functionalities--api-summary)
        * [5.4.3. Adherence to Standardization Pillars](#543-adherence-to-standardization-pillars)
        * [5.4.4. Key Integrations](#544-key-integrations)
    * [5.5. `RouterSystem` & `CoreRouter` & `RoutableModule`](#55-routersystem--corerouter--routablemodule)
        * [5.5.1. Primary Responsibility](#551-primary-responsibility)
        * [5.5.2. Key Functionalities & API Summary](#552-key-functionalities--api-summary)
        * [5.5.3. Adherence to Standardization Pillars](#553-adherence-to-standardization-pillars)
        * [5.5.4. Key Integrations](#554-key-integrations)
6.  [Key System Workflows (with Visuals)](#6-key-system-workflows-with-visuals)
    * [6.1. Application Startup & Initialization Sequence](#61-application-startup--initialization-sequence)
    * [6.2. Typical HTTP API Request Flow](#62-typical-http-api-request-flow)
    * [6.3. Event Propagation within the System](#63-event-propagation-within-the-system)
    * [6.4. Centralized Error Reporting in Action](#64-centralized-error-reporting-in-action)
    * [6.5. Conceptual Health & Metrics Aggregation Flow](#65-conceptual-health--metrics-aggregation-flow)
7.  [Developing Business Modules: A Practical Guide](#7-developing-business-modules-a-practical-guide)
    * [7.1. Guiding Principles for Module Design](#71-guiding-principles-for-module-design)
    * [7.2. Extending `CoreModule` or `RoutableModule`](#72-extending-coremodule-or-routablemodule)
    * [7.3. Example Module: `InventoryModule`](#73-example-module-inventorymodule)
        * [7.3.1. Recommended Directory Structure](#731-recommended-directory-structure)
        * [7.3.2. Defining Routes and Handlers (within the RoutableModule)](#732-defining-routes-and-handlers-within-the-routablemodule)
        * [7.3.3. Defining Module-Specific Errors (`inventory.errors.js`)](#733-defining-module-specific-errors-inventoryerrorsjs)
        * [7.3.4. Defining Module-Specific Events (`inventory.events.js`)](#734-defining-module-specific-events-inventoryeventsjs)
        * [7.3.5. Implementing the Business Logic Service (`InventoryService.js`)](#735-implementing-the-business-logic-service-inventoryservicejs)
        * [7.3.6. Defining API Schemas (`schemas/addItem.schema.js`)](#736-defining-api-schemas-schemasadditemschemajs)
        * [7.3.7. Implementing the Main Module Class (`InventoryModule.js`)](#737-implementing-the-main-module-class-inventorymodulejs)
    * [7.4. Registering the Module & Its Services with the Core](#74-registering-the-module--its-services-with-the-core)
    * [7.5. Module-specific Configuration Details](#75-module-specific-configuration-details)
    * [7.6. Unit Testing Modules (Using Jest)](#76-unit-testing-modules-using-jest)
8.  [Shared Utilities Reference](#8-shared-utilities-reference)
    * [8.1. `SystemConstants.js`](#81-systemconstantsjs)
        * [8.1.1. Purpose & Key Definitions](#811-purpose--key-definitions)
        * [8.1.2. Usage Example](#812-usage-example)
    * [8.2. `ErrorUtils.js`](#82-errorutilsjs)
        * [8.2.1. Purpose & Key Functions](#821-purpose--key-functions)
        * [8.2.2. Usage Examples](#822-usage-examples)
9.  [Conclusion & Future Directions](#9-conclusion--future-directions)
    * [9.1. Summary of Achievements](#91-summary-of-achievements)
    * [9.2. Reinforcing the Standardization Pillars](#92-reinforcing-the-standardization-pillars)
    * [9.3. Future Directions & Potential Enhancements](#93-future-directions--potential-enhancements)

---

## 1. Introduction to the TSMIS Core Architecture

### 1.1. Purpose of this Guide

This document serves as the definitive technical guide and "source of truth" for the refactored core architecture of the Toro_SM Information System (TSMIS). It outlines the design, functionalities, naming conventions, and interaction patterns of the core foundational systems. Its goal is to ensure consistency in development, improve maintainability, and provide a clear understanding of how the system is built and operates, especially for junior to mid-level programmers.

This guide synthesizes the principles applied during the core refactoring process and should be used by all developers working on or integrating with the TSMIS core systems and business modules. While more exhaustive, standalone documentation files may exist for each individual core system class, this document focuses on providing clear summaries, the overarching architecture, cross-component standards, and their interplay.

### 1.2. What is TSMIS? (System Overview)

The Toro_SM Information System (TSMIS) is an enterprise-level application built on Node.js, designed to be modular, scalable, and maintainable. It supports a variety of business functionalities through a collection of:
* **Core Infrastructure Systems**: These provide fundamental services like dependency management, error handling, event communication, module orchestration, and request routing.
* **Specialized Business Modules**: These encapsulate specific business domain logic and functionalities, building upon the services provided by the core systems.

The architecture is built with a strong emphasis on clear separation of concerns. This allows different parts of the system to be developed, tested, and potentially deployed with a degree of independence, fostering agility and reducing the complexity of managing a large application.

### 1.3. Goals of the Core Architecture

The refactored core architecture of TSMIS was undertaken with several key goals in mind, aiming to create a more robust and developer-friendly platform:

* **Uniformity & Consistency**: To establish and enforce consistent patterns across all core components and for the development of new modules. This includes consistent approaches to naming, state management, error handling, component lifecycle, health monitoring, and metrics collection.
* **Enhanced Observability**: To build in capabilities for comprehensive monitoring of the system's health, performance metrics, and operational status from the ground up.
* **Improved Maintainability**: To make the codebase clearer, better organized, and easier to understand, debug, and extend through standardized interfaces and practices.
* **Increased Testability**: To design components with clear responsibilities and decoupled interfaces, facilitating effective unit and integration testing.
* **Greater Robustness**: To implement comprehensive and consistent error handling and reporting mechanisms that improve the system's resilience to failures.
* **Effective Decoupling**: To promote loose coupling between different parts of the system, primarily achieved through Dependency Injection (DI) and an Event-Driven Architecture (EDA).
* **Better Developer Experience**: To provide clear guidelines, reusable base classes (like `CoreModule` and `RoutableModule`), and a predictable framework that streamlines the development of new business logic and features.

### 1.4. Key Architectural Principles Driving TSMIS

The TSMIS core architecture is guided by several fundamental software engineering principles:

* **Modularity & Separation of Concerns (SoC)**: The system is broken down into distinct modules and systems, each with a well-defined responsibility. This limits the impact of changes and makes the system easier to reason about.
* **Dependency Injection (DI)**: Components do not create their own dependencies; instead, dependencies are "injected" into them by the `ContainerSystem`. This promotes loose coupling, making components easier to test in isolation and reuse.
* **Event-Driven Architecture (EDA)**: Asynchronous communication through events (managed by the `EventBusSystem`) is favored for many interactions, especially between different business domains (modules). This further reduces direct coupling and can improve system responsiveness and scalability.
* **Standardization Pillars**: Common cross-cutting concerns like state management, error handling, lifecycle, health checks, and metrics are addressed using a predefined set of patterns and utilities across all core systems. This ensures consistency and predictability.
* **Centralized Configuration**: Systems and modules are designed to be configurable, with configurations managed and supplied in a consistent manner (with the potential for a dedicated `ConfigSystem` in the future).
* **Layered Design**: The architecture promotes a logical layering (e.g., API/Routing Layer, Business Logic/Module Layer, Service Layer, Core Infrastructure Layer) to organize responsibilities.
* **Clear Naming Conventions**: A consistent set of naming standards for files, classes, functions, etc., is applied to improve code readability and maintainability.
* **Observability by Design**: Health monitoring, metrics collection, and structured error reporting are built into the core components, not added as an afterthought.

---
## 2. Naming Conventions

To ensure consistency, readability, and maintainability across the TSMIS codebase, the following naming conventions should be adhered to for all new development and refactoring efforts.

### 2.1. File Naming

* **JavaScript Class Files**: `PascalCase.js` (e.g., `ContainerSystem.js`, `CoreModule.js`, `FastifyAdapter.js`).
* **JavaScript Utility/Helper Files**: `camelCase.js` or `PascalCase.js` if they primarily export a class/constructor (e.g., `ErrorUtils.js`). Use `camelCase.js` if it's a collection of functions (e.g., `inventoryHelpers.js`).
* **JavaScript Configuration Files**: `camelCase.config.js` or `kebab-case.config.js` (e.g., `database.config.js`).
* **Interface Definitions (JS Classes used as Interfaces)**: `IPascalCase.js` (e.g., `IRouterAdapter.js`, `IFrameworkIntegration.js`).
* **Test Files**: `PascalCase.test.js` or `camelCase.test.js` (e.g., `ContainerSystem.test.js`, `errorUtils.test.js`).
* **Markdown Documentation Files**: `kebab-case.md` or `snake_case.md` (e.g., `container-system-docs.md`, `developing-modules.md`).
* **Directory Names**: `camelCase` or `kebab-case`. Prefer `kebab-case` for general directories (e.g., `business-modules`, `error-integrations`) and `camelCase` if the directory name directly corresponds to a primary class/namespace it contains (e.g., `core/errors`, `core/errors/types`).

### 2.2. Class & Constructor Naming

* **Classes**: `PascalCase` (e.g., `CoreModule`, `ErrorSystem`, `InventoryService`).
* **Interfaces (JS Classes used as Interfaces)**: `IPascalCase` (e.g., `IRouterAdapter`).
* **Abstract Classes (Conceptual)**: `PascalCase` with JSDoc indicating it's abstract or intended for extension (e.g., `CoreModule`).

### 2.3. Method & Function Naming

* **Public Methods/Functions**: `camelCase` (e.g., `initialize`, `handleError`, `createInventoryItem`).
* **Private/Internal Methods/Functions (by convention)**: `_camelCase` (e.g., `_handleInternalError`, `_validateDependencies`). The underscore prefix signals internal use.
* **Factory Functions**: `createPascalCaseEntity` or `createCamelCaseUtility` (e.g., `createContainerSystem`, `createInventoryModule`).

### 2.4. Variable Naming

* **Local Variables & Parameters**: `camelCase` (e.g., `let itemCount = 0;`, `function processUserData(userRecord) {}`).
* **Instance Properties**: `camelCase` (e.g., `this.registeredModules = new Map();`).
* **Private/Internal Instance Properties (by convention)**: `_camelCase` (e.g., `this._internalCache = {};`).
* **Boolean Variables/Properties**: Often prefixed with `is`, `has`, `should`, `can` (e.g., `isEnabled`, `hasPendingRequests`).

### 2.5. Constant Naming

* **General Constants**: `UPPER_SNAKE_CASE` (e.g., `MAX_RETRIES`, `DEFAULT_TIMEOUT`).
* **Exported Constant Objects/Namespaces**: `PascalCase` for the main exported object, with `UPPER_SNAKE_CASE` for its keys if it's an enum-like structure.
    * Example: `SystemConstants.SYSTEM_STATUS.RUNNING`, `SystemConstants.LIFECYCLE_EVENTS.INITIALIZED`.
    * Example: `ErrorCodes.CORE.UNKNOWN_ERROR`.

### 2.6. Event Naming

* **Format**: `domain.entity.action` (lowercase, dot-separated) for business events. `system:scope:action` (lowercase, colon-separated) for core system lifecycle or operational events.
    * Business Examples: `user.created`, `order.item.shipped`, `inventory.item.stock_low`.
    * System Lifecycle: `system:initializing`, `system:running` (from `SystemConstants.LIFECYCLE_EVENTS`).
    * Module Lifecycle: `module:initialized`, `module:shutdown` (emitted by `CoreModule`).
    * Scoped System Lifecycle: `system:initialized:containersystem`, `system:initialized:inventorymodule`.
* **Tense**:
    * **Past Tense** for events describing facts (something that has happened): `user.created`, `payment.processed`.
    * **Present Tense** for commands or state changes being announced (less common for pure events, more for command patterns): `inventory.check_stock` (if it were a command event). For general eventing, past tense is preferred.

### 2.7. Error Code Naming

* **Format in `ErrorCodes.js`**: Keys are `UPPER_SNAKE_CASE` representing the specific error (e.g., `ITEM_NOT_FOUND`). String values are also typically `UPPER_SNAKE_CASE` and are the *specific part* of the code.
* **Structure in `ErrorCodes.js`**: Grouped by domain/system under `PascalCase` or `UPPER_SNAKE_CASE` keys (e.g., `ErrorCodes.CORE`, `ErrorCodes.INVENTORY`).
* **`error.code` Property**: On an instantiated `CoreError` subclass, the `code` property will be a fully prefixed string like `DOMAIN_SPECIFIC_CODE` (e.g., `INVENTORY_ITEM_NOT_FOUND`). The subclass constructor prepends its domain.

### 2.8. Metric Naming

* **Format**: `domain_or_component.object_or_feature.specific_action_or_state` (lowercase, dot-separated).
    * Examples: `corerouter.routes.registered`, `inventorymodule.api.items_added`, `system.errors.internal`.
* **Tags**: Use `camelCase` for tag keys (e.g., `eventName`, `moduleId`).

### 2.9. Configuration Key Naming

* **Format**: `camelCase` for keys within JavaScript configuration objects as accessed by `this.config` or `deps.config`.
    * Examples: `maxErrorHistory`, `defaultHealthCheckInterval`, `dbHost`, `dbPort`.
* If loading from external sources (like environment variables `DB_HOST` or JSON/YAML files `db_host`), the loading mechanism should ideally normalize these to `camelCase` when populating the JavaScript `config` object used by the application.

Adherence to these naming conventions is crucial for code consistency, readability, and long-term maintainability of the TSMIS platform.

---
## 3. Core Foundational Pillars

The TSMIS core architecture is built upon several standardization pillars that ensure consistency, reliability, and observability across all core systems and derived business modules. These pillars define common patterns for essential cross-cutting concerns.

### 3.1. Standard `this.state` Object

Every core system component (`ContainerSystem`, `ErrorSystem`, `EventBusSystem`, `ModuleSystem`, `RouterSystem`) and base classes like `CoreModule` and `CoreEventBus` maintain a standardized internal `state` object. This provides a consistent way to inspect the internal condition and operational status of any component.

**Core Systems**: Standard `this.state` Object Structure

```javascript
// Generic example of the 'this.state' object within a Core System component
// import { SystemConstants } from './SystemConstants.js'; // Assuming SystemConstants is available

this.state = {
  status: SystemConstants.SYSTEM_STATUS.CREATED,
  startTime: null,
  errors: [], // Stores { error: CoreError, timestamp: string, context: object }
  metrics: new Map(), // Stores { metricName: { value, timestamp, tags } }
  healthChecks: new Map(), // Stores { healthCheckName: asyncFunction }
  // ... component-specific state properties might be added here
};
```

**Key Properties within `this.state`:**
* **`status: string`**: The current lifecycle status of the component (e.g., `'created'`, `'initializing'`, `'running'`). Values are drawn from `SystemConstants.SYSTEM_STATUS`.
* **`startTime: number | null`**: A timestamp (`Date.now()`) indicating when the component's `initialize()` method began or when it successfully transitioned to the `'running'` state. Cleared or set to `null` on shutdown.
* **`errors: Array<{error: CoreError, timestamp: string, context: object}>`**: A circular buffer (size configurable, e.g., via `DEFAULT_CONFIG.MAX_ERROR_HISTORY`) storing a log of *internal operational errors* encountered by the component itself. This is for component self-diagnostics, not for errors it processes from other parts of the application (which `ErrorSystem` handles).
* **`metrics: Map<string, {value: any, timestamp: number, tags?: object}>`**: A collection of performance and operational metrics recorded by the component.
* **`healthChecks: Map<string, Function>`**: A map of registered asynchronous health check functions specific to this component (name -> `async checkFn()`).

Components may extend this base `state` object with additional properties relevant to their specific domain (e.g., `ModuleSystem.state.moduleHealth`, `CoreRouter.state.routes`).

### 3.2. Standardized Error Handling Framework

A unified approach to error handling enhances robustness and debuggability:
* **`CoreError` Hierarchy**: All application-specific errors MUST extend `CoreError` or one of its domain-specific subclasses (e.g., `ModuleError`). Errors are structured with a `code`, `message`, `details`, `timestamp`, and optional `cause`.
* **`ErrorCodes.js`**: A central enum-like object (`src/core/errors/ErrorCodes.js`) defines all standard error codes, categorized by domain (e.g., `ErrorCodes.CORE.UNKNOWN_ERROR`).
* **`ErrorSystem`**: The central service for processing all reported errors. Components report errors to `ErrorSystem` rather than logging them directly for external concerns.
* **`safeHandleError` Utility**: A shared utility (`src/core/common/ErrorUtils.js`) used by components to reliably report errors to `ErrorSystem`, with a console fallback if `ErrorSystem` is unavailable.
* **Internal Error Methods (e.g., `_handleInternalError`)**: Core systems typically have a private method to manage their own operational errors, which involves logging to their `this.state.errors`, recording a metric, and using `safeHandleError`.
* **Public `handleError` Methods**: Components like `CoreModule` or `CoreEventBus` (for listener errors) provide a public `handleError` method to process errors related to their domain, usually also leveraging `safeHandleError`.

### 3.3. Standardized Lifecycle Management

Core systems and modules share a consistent lifecycle:
* **Core Methods**: Each component implements `async initialize(deps)` for setup and `async shutdown()` for graceful cleanup.
* **State Transitions**: The `this.state.status` property is managed using statuses from `SystemConstants.SYSTEM_STATUS` (e.g., `INITIALIZING`, `RUNNING`, `SHUTDOWN`).
* **Lifecycle Events**: Standardized events (from `SystemConstants.LIFECYCLE_EVENTS`, e.g., `system:initializing`, `system:running`) are emitted by each component for its own lifecycle, typically using `super.emit()`. Name-scoped versions are also used (e.g., `system:initialized:mycomponentname`).
* **Idempotency**: `initialize()` and `shutdown()` are generally designed to be idempotent.

### 3.4. Standardized Health Monitoring

Components are designed to be observable for their health:
* **`registerHealthCheck(name: string, checkFn: Function)`**: Method to add specific health check functions to a component.
* **`async checkHealth(): Promise<object>`**: Executes all registered checks and returns an aggregated, standard health report. The report includes component `name`, `version`, overall `status`, `timestamp`, `uptime`, `errorCount` (from `this.state.errors`), and a `checks` object with individual check results.
* **`createStandardHealthCheckResult(status, detail = {}, errors = [])`**: Shared utility (`src/core/common/ErrorUtils.js`) for formatting the output of individual `checkFn`s consistently: `{ status: string, detail: object, errors: Array<ErrorSummary> }`.
* **Default Health Checks**: Each component provides at least a default check for its own `state.status`.

### 3.5. Standardized Metrics Tracking

For performance and operational insights:
* **`recordMetric(name: string, value: any, tags = {}): void`**: Method to record a metric, stored in `this.state.metrics`. `name` uses dot-notation (e.g., `component.operation.result`).
* **`getMetrics(): object`**: Retrieves all metrics: `{ metricName: { value, timestamp, tags } }`.
* **Standard Metrics**: Core components automatically record key metrics for lifecycle events, internal errors, and critical operations.

### 3.6. Standardized Factory Functions

* Each primary core system class and base module class is accompanied by an exported factory function: `create[ComponentName](deps = {})`.
* These simplify instantiation, especially for DI via `ContainerSystem`, and can provide default dependencies for testing.

### 3.7. Shared Utilities Overview
Key shared utilities in `src/core/common/` underpin these pillars:
* **`SystemConstants.js`**: Defines `SYSTEM_STATUS`, `LIFECYCLE_EVENTS`, `DEFAULT_CONFIG`.
* **`ErrorUtils.js`**: Provides `safeHandleError()` and `createStandardHealthCheckResult()`.

These pillars ensure that TSMIS core systems are developed and operate in a consistent, robust, and observable manner, forming a reliable foundation for business modules.

---
## 4. Overview of Core Systems

The TSMIS architecture is built around a set of specialized core systems that provide foundational services and manage different aspects of the application's operation.

### 4.1. The Core Systems Landscape

* **`ContainerSystem`**: The Dependency Injection (DI) / Inversion of Control (IoC) container. Manages component registration, dependency resolution, and lifecycle orchestration.
* **`ErrorSystem`**: Centralizes error handling, processing reported errors, managing custom error handlers, and integrating with frameworks for error responses. Relies on `CoreError` and `ErrorCodes.js`.
* **`EventBusSystem`**: Manages the `CoreEventBus` to facilitate asynchronous, event-driven communication between decoupled components, especially business modules.
* **`ModuleSystem`**: Orchestrates the lifecycle, registration, and dependencies of all business logic modules (which extend `CoreModule`). It also aggregates module health.
* **`RouterSystem`**: Manages the `CoreRouter` for defining HTTP routes (often defined in `RoutableModule` extensions), integrating with web frameworks via adapters, and handling middleware.

These systems are designed to work together, often with `ContainerSystem` instantiating and providing them as dependencies to each other and to business modules.

### 4.2. Holistic System Interaction Diagram

This diagram illustrates the primary relationships and dependencies between the core TSMIS systems and how they typically interact with business modules and the external environment (e.g., HTTP requests).

**Holistic Core System Interactions**: 

```mermaid
graph TD
    A[Web Framework (e.g., Fastify)] <--> RS[RouterSystem]
    RS -- Manages --> CR[CoreRouter]
    CR -- Listens for route events via --> EBS[EventBusSystem]
    
    subgraph ModulesAndContainer [Application Logic & Orchestration]
        CS[ContainerSystem]
        MS[ModuleSystem]
        BMs["Business Modules<br>(RoutableModule/CoreModule)"]
    end

    CS -- Initializes & Injects Deps --> ES[ErrorSystem]
    CS -- Initializes & Injects Deps --> EBS
    CS -- Initializes & Injects Deps --> MS
    CS -- Initializes & Injects Deps --> RS
    CS -- Initializes & Injects Deps --> BMs
    CS -- Initializes & Injects Deps --> AppServices[Application Services]

    MS -- Manages Lifecycle of --> BMs
    BMs -- Emit route definitions to --> EBS
    BMs -- Emit/Subscribe to business events via --> EBS
    BMs -- Report errors to --> ES
    BMs -- Use --> AppServices
    
    AppServices -- Report errors to --> ES
    AppServices -- Use --> EBS

    ES -- Used by All --> AllSystems["All Core Systems & Modules"]
    
    RS -- Applies routes to --> A
    CR -- Stores routes defined by --> BMs

    EBS -- Manages --> CEB[CoreEventBus]

    classDef core fill:#D6EAF8,stroke:#5DADE2,stroke-width:2px;
    classDef app fill:#E8F8F5,stroke:#76D7C4,stroke-width:2px;
    class CS, ES, EBS, MS, RS, CR, CEB core;
    class BMs, AppServices app;
```

**Key Interaction Paths:**
* **Application Bootstrap**: `ContainerSystem` initializes all other core systems and then `ModuleSystem` initializes business modules. `RouterSystem` applies routes defined by modules to the web framework.
* **HTTP Request**: Web Framework -> `RouterSystem` (Adapter -> `CoreRouter`) -> `RoutableModule` Handler -> Business Services -> Response. Errors are channeled through `ErrorSystem`.
* **Event Communication**: Module A -> `EventBusSystem` (`CoreEventBus`) -> Module B.
* **Error Reporting**: Any Component -> `ErrorSystem`.
* **Dependency Provision**: `ContainerSystem` -> All other Systems/Modules/Services.

---
## 5. Deep Dive into Core Systems (Summaries)

This section provides a summary overview of each core system, highlighting its primary responsibility, key APIs, adherence to standardization pillars, and crucial integrations. For exhaustive details, refer to the individual standalone documentation file for each system.

### 5.1. `ContainerSystem`

#### 5.1.1. Primary Responsibility
The `ContainerSystem` is the application's DI/IoC container. It manages component registration, dependency resolution, and lifecycle orchestration (initialization and shutdown) for all major components.

#### 5.1.2. Key Functionalities & API Summary
* **Registration**: `register(name, Component, options)`, `registerManifest(type, manifest)`.
* **Resolution**: `async resolve(name)` – provides dependency-injected instances (singletons by default).
* **Discovery**: `async discover(type, basePath)` – loads components from filesystem based on manifests.
* **Lifecycle**: `async initialize()` (initializes components in dependency order), `async shutdown()` (shuts down in reverse order).
* **Dependency Logic**: Uses `static dependencies` arrays; `resolveDependencyOrder()` for sequencing and circular dependency detection.

#### 5.1.3. Adherence to Standardization Pillars
* **State**: Standard `this.state`; manages internal maps for `components`, `instances`, `dependencies`, `manifests`.
* **Errors**: Uses `_handleInternalError` (reporting to `ErrorSystem` via `safeHandleError`); throws `ConfigError` or `ServiceError` for operational/setup issues.
* **Lifecycle**: Standard `initialize`/`shutdown`; emits lifecycle and operational events (e.g., `component:registered`, `discovery:completed`).
* **Health**: Default checks `container.state`, `container.components` (counts).
* **Metrics**: For registrations, resolutions, discovery, lifecycle, internal errors.
* **Factory**: `createContainerSystem(deps = {})`.

#### 5.1.4. Key Integrations
* **ErrorSystem**: Reports its internal errors to a configured `ErrorSystem`.
* **Configuration (`deps.config`)**: Can use global config for its own settings (e.g., `initOrder`).
* **Application Components**: Its primary role is to instantiate, configure (by injecting global config if components depend on it), inject dependencies into, and manage the lifecycle of all other registered core systems, services, and business modules.
* **EventBusSystem (Indirectly)**: Emits operational events that can be consumed system-wide.

**Container system**: Key Operational Flows Summary

```mermaid
graph TD
    subgraph ContainerSystem_Operations
        direction LR
        Register["register(name, Comp)"]
        Resolve["resolve(name)"]
        Initialize["initialize()"]
        Discover["discover(type, path)"]
    end

    subgraph ContainerSystem_Internal_State
        ComponentsMap["Components Registry"]
        InstancesCache["Singleton Instances Cache"]
        DependencyGraph["Dependency Graph"]
        ManifestsStore["Manifests Store"]
    end

    Register --> ComponentsMap;
    Register --> DependencyGraph;
    
    Resolve -- Reads --> ComponentsMap;
    Resolve -- Reads/Writes --> InstancesCache;
    Resolve -- Uses --> DependencyGraph;
    Resolve --> InstantiatedComponent["Instantiated Component"];
    
    Initialize -- Uses --> DependencyGraph;
    Initialize -- Calls --> Resolve;
    Initialize -- Calls --> ComponentInit["component.initialize()"];
    
    Discover -- Uses --> ManifestsStore;
    Discover -- Scans --> FileSystem["File System"];
    Discover -- Loads & Validates --> DiscoveredComponents["Discovered Component Definitions"];
    
    classDef op fill:#c9daf8,stroke:#333,stroke-width:1px;
    classDef state fill:#e6f2ff,stroke:#333,stroke-width:1px;
    class Register,Resolve,Initialize,Discover op;
    class ComponentsMap,InstancesCache,DependencyGraph,ManifestsStore state;
```

### 5.2. `ErrorSystem` & `CoreError`

#### 5.2.1. Primary Responsibility
`ErrorSystem` centralizes error handling. It processes errors reported from anywhere in the application, allows custom handling based on error type, and integrates with frameworks (like Fastify) for consistent HTTP error responses. It relies on `CoreError` as the base for all structured application errors and `ErrorCodes.js` for standardized error identification.

#### 5.2.2. Key Functionalities & API Summary
* **`CoreError`**: Base class with `code`, `message`, `details`, `timestamp`, `cause`, `toJSON()`, `static fromJSON()`. Specialized types (e.g., `ValidationError`) extend it.
* **`ErrorCodes.js`**: Centralized, categorized error code strings.
* **`ErrorSystem`**:
    * `async handleError(error, context)`: Main entry point for reported errors.
    * `registerHandler(errorTypeName, handler)`: For custom error processing logic.
    * `async registerIntegration(name, IntegrationClass, frameworkInstance, options)`: For web framework error response handling.
    * `createError(typeName, code, ...)`: Factory for `CoreError` instances.

#### 5.2.3. Adherence to Standardization Pillars
* **State**: Standard `this.state`; `ErrorSystem` also manages `errorTypes`, `customHandlers`, `integrations` maps.
* **Errors**: `ErrorSystem` uses `_handleInternalError` for its own issues. Its main job is to process errors reported *to* it.
* **Lifecycle**: Standard `initialize`/`shutdown`; emits lifecycle and error processing events (e.g., `error:handled`).
* **Health**: Default checks `errorsystem.state`, `errorsystem.handlers` (count), `errorsystem.integrations` (count).
* **Metrics**: For lifecycle, errors received/processed, handlers/integrations registered.
* **Factory**: `createErrorSystem(deps = {})`.

#### 5.2.4. Key Integrations
* **All Components**: Report errors to `ErrorSystem` via `safeHandleError`.
* **Logger & Config**: Injected dependencies for `ErrorSystem`'s operation.
* **Framework Integrations (e.g., `FastifyErrorHandler`)**: Managed by `ErrorSystem` to bridge between framework error capture and centralized processing/response generation.

**Error system**: Error Processing Flow Summary

```mermaid
graph TD
    A[Error Reported (CoreError instance + context)] --> ES_HandleError["ErrorSystem.handleError()"];
    
    subgraph ErrorSystem_Processing
        direction TB
        ES_HandleError --> ValidateError["Ensure/Wrap to CoreError"];
        ValidateError --> LookupHandler["Lookup Specific/Default Handler"];
        LookupHandler --> InvokeHandler["Invoke Handler (Custom or Default)"];
        InvokeHandler --> LogNotify["Handler Actions (Logging, Notifications, etc.)"];
        InvokeHandler --> EmitEvent["Emit 'error:handled' or 'error:handler_failed'"];
    end

    subgraph Framework_Integration (Optional)
        direction TB
        FwError["Framework Catches Error"] --> MapError["Integration.mapError()"];
        MapError --> FwInt_Calls_ESHandle["Calls ErrorSystem.handleError()"];
        ES_HandleError --> SerializeError["Integration.serializeError()"];
        SerializeError --> HttpResponse["Send HTTP Error Response"];
    end

    FwError --> MapError;
    InvokeHandler -.-> SerializeError; %% If error was processed and needs HTTP response

    classDef entry fill:#f9e79f,stroke:#333,stroke-width:1px;
    classDef process fill:#d6eaf8,stroke:#333,stroke-width:1px;
    classDef framework fill:#e8f8f5,stroke:#333,stroke-width:1px;
    class A entry;
    class ES_HandleError,ValidateError,LookupHandler,InvokeHandler,LogNotify,EmitEvent process;
    class FwError,MapError,FwInt_Calls_ESHandle,SerializeError,HttpResponse framework;
```

### 5.3. `EventBusSystem` & `CoreEventBus`

#### 5.3.1. Primary Responsibility
`EventBusSystem` manages the `CoreEventBus`, which provides the application's central mechanism for asynchronous, event-driven communication, promoting decoupling between components.

#### 5.3.2. Key Functionalities & API Summary
* **`EventBusSystem`**: `initialize()`, `shutdown()`, `getEventBus()`.
* **`CoreEventBus`**:
    * `async emit(eventName, data, options)`: Publishes events (standard structure: `id`, `name`, `data`, `timestamp`, `metadata`), supports queuing.
    * `subscribe(pattern, handler, options)`: For exact, pattern (`user.*`), or wildcard (`*`) subscriptions. Handlers always receive the full event object.
    * `unsubscribe(subscriptionId)`.
    * Queuing (`queueEvent`, `processQueue`, `processAllQueues`).
    * History (`trackEvent`, `getHistory`).
    * `async handleError(error, context)`: For listeners to report their errors.

#### 5.3.3. Adherence to Standardization Pillars
* **State**: Standard `this.state` for both. `CoreEventBus` also manages `queues`, `subscriptions`, `history`.
* **Errors**: Both use `_handleInternalError`; `CoreEventBus` has public `handleError` for listeners. Both throw `EventError`.
* **Lifecycle**: `EventBusSystem` manages `CoreEventBus` lifecycle. Both emit standard events.
* **Health**: `EventBusSystem` aggregates `CoreEventBus` health. `CoreEventBus` checks its state, queues, subscriptions.
* **Metrics**: `CoreEventBus` has detailed metrics on events, queues, subs. `EventBusSystem` for its own lifecycle.
* **Factory**: `createEventBusSystem(deps = {})`, `createEventBus(deps = {})`.

#### 5.3.4. Key Integrations
* **ErrorSystem & Config**: Dependencies for both `EventBusSystem` and `CoreEventBus`.
* **Application Modules & Services**: Primary users, obtaining `CoreEventBus` via `eventBusSystem.getEventBus()` for pub/sub.
* **Other Core Systems**: Can use `CoreEventBus` for asynchronous notifications (e.g., `RouterSystem` listens for route registration events).

**EventBus system**: Event Flow Summary

```mermaid
graph TD
    Publisher["Component/Module (Publisher)"] -- "1. getEventBus().emit('eventName', data, opts)" --> CEBus["CoreEventBus"];
    
    subgraph CoreEventBus_Processing
        direction TB
        CEBus --> CreateEvent["Create Standard Event Obj"];
        CreateEvent --> TrackHistory["Track in History"];
        TrackHistory --> CheckQueue{"options.queue?"};
        CheckQueue -- Yes --> QueueEvent["Queue Event"];
        CheckQueue -- No --> FindSubscribers["Find Subscribers (Exact, Pattern, Wildcard)"];
        QueueEvent -- Later via processQueue() --> FindSubscribers;
        FindSubscribers --> InvokeHandler["Invoke Handler(s)"];
    end
    
    InvokeHandler --> Subscriber["Component/Module (Subscriber)"];
    Subscriber -- "Processes event" --> SubscriberLogic["Subscriber Logic"];
    SubscriberLogic -- Optional: Error --> CEBus_HandleError["CoreEventBus.handleError()"];
    CEB_HandleError -- Reports to --> ErrorSystemGlobal["ErrorSystem"];

    EventBusSystem["EventBusSystem"] -- Manages/Provides --> CEBus;
    
    classDef component fill:#D6EAF8,stroke:#5DADE2,stroke-width:2px;
    classDef appComp fill:#E8F8F5,stroke:#76D7C4,stroke-width:1px;
    classDef process fill:#FEF9E7,stroke:#F7DC6F,stroke-width:1px;

    class EventBusSystem, CEBus component;
    class Publisher, Subscriber, SubscriberLogic, ErrorSystemGlobal appComp;
    class CreateEvent, TrackHistory, CheckQueue, QueueEvent, FindSubscribers, InvokeHandler, CEBus_HandleError process;
```

### 5.4. `ModuleSystem` & `CoreModule`

#### 5.4.1. Primary Responsibility
`ModuleSystem` orchestrates business logic modules (`CoreModule` extensions). `CoreModule` provides a standardized base for these modules, handling lifecycle, DI, config, errors, events, health, and metrics.

#### 5.4.2. Key Functionalities & API Summary
* **`ModuleSystem`**: `register(name, ModuleClass, config)`, `resolve(name)`, `initialize()` (orders module init), `shutdown()` (orders module shutdown), `getSystemModulesHealth()`, `handleModuleError()`.
* **`CoreModule`**:
    * Constructor `(deps)` receives injected dependencies.
    * Lifecycle Hooks: `onInitialize`, `onShutdown`, `onValidateConfig`, `onConfigure`, `setupEventHandlers`, `onSetupHealthChecks`.
    * Utilities: `handleError()`, `emit()`, `recordMetric()`, `checkHealth()`, `registerHealthCheck()`.
    * `this.config` for module-specific configuration.
    * `this.eventBus` for event communication.

#### 5.4.3. Adherence to Standardization Pillars
* **State**: Standard `this.state` for both. `ModuleSystem` adds `modules`, `moduleHealth`. `CoreModule` adds `lastHealthCheck`.
* **Errors**: Both use `_handleInternalError`. `CoreModule` has public `handleError`. `ModuleSystem` has `handleModuleError`. Both throw `ModuleError`/`ValidationError`.
* **Lifecycle**: `ModuleSystem` orchestrates `CoreModule` lifecycles based on `static dependencies`. Both emit standard/scoped events.
* **Health**: `ModuleSystem` aggregates health from all managed modules (`getSystemModulesHealth`) and has its own checks. `CoreModule` provides `checkHealth` with a default state check and allows custom checks. `ModuleSystem` manages periodic health polling for modules.
* **Metrics**: Both record relevant metrics.
* **Factory**: `createModuleSystem(deps = {})`, `createModule(deps = {})`.

#### 5.4.4. Key Integrations
* **ContainerSystem**: `ModuleSystem` is usually managed by it. `ModuleSystem` uses `ContainerSystem` (via its injected `deps`) to resolve *additional* dependencies for the `CoreModule` instances it creates.
* **EventBusSystem**: `ModuleSystem` provides `CoreEventBus` (via `EventBusSystem`) to modules for inter-communication. `ModuleSystem` itself emits module lifecycle events.
* **ErrorSystem**: Both `ModuleSystem` and `CoreModule`s report errors to `ErrorSystem`.
* **Business Modules**: `ModuleSystem`'s primary role is to manage these.

**Module system**: Architecture & Module Management Summary

```mermaid
graph TD
    MS["ModuleSystem"] -- Manages Lifecycle & Dependencies --> ModulesMap["Registered Modules Map<name, CoreModuleInstance>"];
    
    subgraph ModuleSystem_Operations
        direction TB
        Register["register(name, Class, config)"]
        Initialize["initialize()"]
        Shutdown["shutdown()"]
        GetHealth["getSystemModulesHealth()"]
    end

    Register --> CreateInstance["Instantiate CoreModule Subclass"];
    CreateInstance -- Injects Deps (ErrorSys, EventBusSys, Config, Custom) --> ModulesMap;
    Initialize --> ResolveOrder["Resolve Dependency Order"];
    ResolveOrder --> InitLoop["For each module in order: module.initialize()"];
    InitLoop --> Monitor["Start Periodic Health Monitoring for Module"];
    
    Monitor -- Periodically Calls --> ModCheckHealth["module.checkHealth()"];
    ModCheckHealth -- Reports Status --> ModuleHealthState["ModuleSystem.state.moduleHealth"];
    
    GetHealth -- Aggregates from --> ModuleHealthState;

    ModulesMap -- Errors Reported/Detected --> HandleModError["ModuleSystem.handleModuleError()"];
    HandleModError -- Uses safeHandleError --> ErrorSystemGlobal["ErrorSystem"];

    classDef system fill:#D6EAF8,stroke:#5DADE2,stroke-width:2px;
    classDef module fill:#E8F8F5,stroke:#76D7C4,stroke-width:1px;
    classDef state fill:#f9f,stroke:#333,stroke-width:1px;
    class MS, Register, Initialize, Shutdown, GetHealth, ResolveOrder, InitLoop, Monitor, HandleModError system;
    class ModulesMap, ModuleHealthState state;
    class CreateInstance, ModCheckHealth, ErrorSystemGlobal module;
```

**CoreModule**: Internal Initialization Sequence Summary (Called by ModuleSystem)

```mermaid
sequenceDiagram
    participant MS as ModuleSystem
    participant CM as CoreModule Instance
    participant Cfg as CM.config
    participant EvBus as CM.eventBus
    
    MS->>CM: module.initialize()
    CM->>CM: _validateDependencies()
    CM->>CM: (Re-fetch this.eventBus from this.deps.eventBusSystem)
    CM->>CM: validateConfig() --> calls onValidateConfig()
    CM->>CM: onConfigure()
    CM->>CM: setupEventHandlers()
        Note over CM,EvBus: (Subscribes to events on EvBus)
    CM->>CM: setupHealthChecks() --> calls onSetupHealthChecks()
        Note over CM: Registers health checks (e.g., this.registerHealthCheck(...))
    CM->>CM: onInitialize()
        Note over CM: (Module-specific core initialization logic)
    CM->>CM: startHealthChecks()
        Note over CM: (Initiates periodic self-health check)
    CM->>CM: Emit 'module:initialized' & 'system:initialized:modulename'
    CM-->>MS: Initialization Successful / Error
```

### 5.5. `RouterSystem` & `CoreRouter` & `RoutableModule`

#### 5.5.1. Primary Responsibility
Provide a framework-agnostic system for defining, managing, and serving HTTP routes.
* **`RouterSystem`**: Manages `CoreRouter`, provides high-level API.
* **`CoreRouter`**: Engine for route registry, adapter/middleware management, processing route events.
* **`RoutableModule`**: `CoreModule` extension for modules to define their routes via events.

#### 5.5.2. Key Functionalities & API Summary
* **`RouterSystem`**: `initialize()` (creates/inits `CoreRouter`), `shutdown()`, `getRouter()`, delegates most operations like `registerAdapter`, `applyRoutes`, `generateOpenApiDoc` to `CoreRouter`.
* **`CoreRouter`**: `initialize()` (subscribes to route events), internal `registerRoute` (handles conflicts), `registerAdapter`, `registerMiddleware`, `applyRoutes` (uses adapter and resolved middleware), `generateOpenApiDoc`. Listens for `router.route.register`, `router.module.unregister`, etc.
* **`RoutableModule`**: `registerRoute(method, path, handler, options)`, `registerVersionedRoute(...)`. `onInitialize` emits route definitions; `onShutdown` emits module unregistration.

#### 5.5.3. Adherence to Standardization Pillars
* **State**: Standard `this.state` for all three. `RouterSystem` holds `router` instance. `CoreRouter` holds `routes`, `adapters`, `middleware` maps. `RoutableModule` holds local `routes` definitions.
* **Errors**: All use `_handleInternalError` (or inherited `handleError`). All throw `RouterError`. `RouterSystem` handles errors from `CoreRouter` delegation.
* **Lifecycle**: `RouterSystem` manages `CoreRouter` lifecycle. `CoreRouter` manages event subscriptions. `RoutableModule` hooks into `CoreModule` lifecycle for route event emissions. All emit standard/scoped lifecycle events.
* **Health**: All provide `checkHealth()`. `RouterSystem` aggregates `CoreRouter`'s health. `CoreRouter` checks its registries. `RoutableModule` adds a `modulename.routes` check.
* **Metrics**: All record relevant metrics (lifecycle, routes registered/applied, errors).
* **Factory**: `createRouterSystem(deps = {})`, `createRoutableModule(deps = {})`.

#### 5.5.4. Key Integrations
* **EventBusSystem/CoreEventBus**: `CoreRouter` subscribes to route events emitted by `RoutableModule`s.
* **HTTP Web Frameworks**: `CoreRouter` uses `IRouterAdapter` (e.g., `FastifyAdapter`) to apply routes.
* **ErrorSystem**: All routing components report errors to `ErrorSystem`.
* **ModuleSystem/CoreModule**: `RoutableModule` is a `CoreModule` managed by `ModuleSystem`.
* **ContainerSystem**: Manages `RouterSystem` and its dependencies.

**Router system**: Overall Routing Flow Summary

```mermaid
graph TD
    subgraph RoutableModule_Defines [RoutableModule: Defines Routes]
        RM_OnInit["onInitialize()"] -- calls --> RM_RegAll["registerAllRoutes()"]
        RM_RegAll -- emits --> Event_RouteRegister["'router.route.register'<br>(via CoreEventBus)"]
    end

    subgraph CoreRouter_Processes [CoreRouter: Processes & Stores Routes]
        CR_Sub["Subscribes to 'router.route.register'"] --> CR_Handler["handleRouteRegistration()"]
        CR_Handler --> CR_Registry["Route Registry (Map)"]
        CR_Registry -- Stores --> RouteDef["{method, path, handler, options}"]
    end
    
    subgraph App_Applies_Routes [Application: Applies Routes]
        AppCode["Application Code"] -- "routerSystem.applyRoutes(fw, adapterName)" --> RSSys["RouterSystem"]
        RSSys -- Delegates to --> CR_Apply["CoreRouter.applyRoutes()"]
        CR_Apply -- Uses --> Adapter["IRouterAdapter (e.g., FastifyAdapter)"]
        Adapter -- Configures --> WebFw["HTTP Web Framework"]
    end

    Event_RouteRegister --> CR_Sub;
    
    classDef module fill:#E8F8F5,stroke:#76D7C4,stroke-width:1px;
    classDef router fill:#D6EAF8,stroke:#5DADE2,stroke-width:1px;
    classDef app fill:#FEF9E7,stroke:#F7DC6F,stroke-width:1px;

    class RM_OnInit, RM_RegAll, RM_Emit module;
    class CR_Sub, CR_Handler, CR_Registry, RouteDef, CR_Apply router;
    class AppCode, RSSys, Adapter, WebFw app;
    class Event_RouteRegister bus;
```

---
## 6. Key System Workflows (with Visuals)

This section details how the core TSMIS systems interact during key application processes. Understanding these flows is essential for grasping the overall operational dynamics of the architecture.

### 6.1. Application Startup & Initialization Sequence

This flow describes the typical startup process of a TSMIS application, from creating the main container to having all systems and modules initialized and ready to serve.

**Application Startup & Initialization Sequence**: 

```mermaid
sequenceDiagram
    participant AppEntry as Application Entry Point (e.g., app.js/server.js)
    participant CS as ContainerSystem
    participant ES as ErrorSystem
    participant Config as ConfigurationComponent
    participant EBSys as EventBusSystem
    participant CEBus as CoreEventBus
    participant MS as ModuleSystem
    participant ModA as BusinessModuleA (Routable)
    participant ModB as BusinessModuleB
    participant RSSys as RouterSystem
    participant CRtr as CoreRouter
    participant Fw as HTTP Framework (e.g., Fastify)

    AppEntry->>CS: new ContainerSystem(globalDeps)
    AppEntry->>CS: register('errorSystem', createErrorSystem, {...})
    AppEntry->>CS: register('config', createConfigComponent, {...})
    AppEntry->>CS: register('eventBusSystem', createEventBusSystem, {...})
    AppEntry->>CS: register('moduleSystem', createModuleSystem, {...})
    AppEntry->>CS: register('routerSystem', createRouterSystem, {...})
    %% Potentially register other core services here

    AppEntry->>CS: initialize()
    Note over CS: Sets status: INITIALIZING, emits system:initializing
    CS->>ES: (via resolve) new ErrorSystem(deps)
    CS->>ES: initialize()
    ES-->>CS: Initialization complete
    Note over ES: Sets status: RUNNING, emits system:initialized

    CS->>Config: (via resolve) new ConfigComponent(deps)
    CS->>Config: initialize()
    Config-->>CS: Initialization complete

    CS->>EBSys: (via resolve) new EventBusSystem(deps including ErrorSystem, Config)
    CS->>EBSys: initialize()
    EBSys->>CEBus: new CoreEventBus(deps)
    EBSys->>CEBus: initialize()
    CEBus-->>EBSys: Init complete
    EBSys-->>CS: Initialization complete
    Note over EBSys, CEBus: Set status: RUNNING, emit system:initialized

    CS->>MS: (via resolve) new ModuleSystem(deps including ErrorSystem, EventBusSystem, Config)
    CS->>MS: initialize()
    MS->>MS: (App code would have called MS.register('moduleA', ModuleAClass, modAConfig))
    MS->>MS: (App code would have called MS.register('moduleB', ModuleBClass, modBConfig))
    Note over MS: Resolves module dependency order
    MS->>ModA: new ModuleAClass(deps)
    MS->>ModA: initialize()
    ModA->>ModA: onInitialize() (defines routes)
    ModA-->>EBSys: (via CoreEventBus) emit('router.route.register', routeDefA)
    ModA-->>MS: Init complete
    MS->>ModB: new ModuleBClass(deps)
    MS->>ModB: initialize()
    ModB-->>MS: Init complete
    MS-->>CS: Initialization complete
    Note over MS: Sets status: RUNNING, emits system:initialized, starts module health monitoring

    CS->>RSSys: (via resolve) new RouterSystem(deps including ErrorSystem, EventBusSystem, Config)
    CS->>RSSys: initialize()
    RSSys->>CRtr: new CoreRouter(deps)
    RSSys->>CRtr: initialize()
    CRtr-->>EBSys: (via CoreEventBus) subscribe('router.route.register', ...)
    CRtr-->>RSSys: Init complete
    RSSys-->>CS: Initialization complete
    Note over RSSys, CRtr: Set status: RUNNING, emit system:initialized

    CS-->>AppEntry: Container Initialization Complete
    Note over CS: Sets status: RUNNING, emits system:initialized

    %% Route processing by CoreRouter (happens as events arrive)
    EBSys-->>CRtr: Delivers 'router.route.register' event (for routeDefA)
    CRtr->>CRtr: handleRouteRegistration(event)
    Note over CRtr: Adds route to its internal registry

    AppEntry->>RSSys: registerAdapter('fastify', FastifyAdapterInstance)
    AppEntry->>Fw: new Fastify()
    AppEntry->>RSSys: applyRoutes(FastifyInstance, 'fastify')
    RSSys->>CRtr: applyRoutes(FastifyInstance, 'fastify')
    CRtr->>Fw: (Adapter applies routes)
    
    AppEntry->>Fw: fastify.listen()
    Note right of Fw: Server Starts
```

**Step-by-Step Explanation:** *(Refer to previously generated detailed steps)*

### 6.2. Typical HTTP API Request Flow

This flow outlines the journey of an HTTP request from its arrival at the web server to the point a response is sent back, highlighting the roles of the `RouterSystem`, `CoreRouter`, `RoutableModule`, and `ErrorSystem`.

**Typical HTTP API Request Flow**: 

```mermaid
sequenceDiagram
    participant Client as HTTP Client
    participant Fw as HTTP Web Framework (e.g., Fastify)
    participant Adapter as Router Adapter (e.g., FastifyAdapter)
    participant CRtr as CoreRouter
    participant RM as RoutableModule Instance
    participant Service as Business Service (Optional)
    participant ESysInt as ErrorSystem Framework Integration
    participant ESys as ErrorSystem

    Client->>+Fw: HTTP Request (e.g., GET /api/v1/products/123)
    Fw->>Fw: Match Route (using routes applied by Adapter)
    Note over Fw,RM: Framework invokes the specific handler function associated with the matched route. This handler was originally defined in a RoutableModule and bound to its instance.
    Fw->>+RM: Call routeHandler(request, reply)
    RM->>RM: (Optional) Validate request parameters/body
    alt Request Validation Fails
        RM->>RM: throw new ValidationError(...)
        RM-->>-Fw: Returns/Throws ValidationError
    else Request Validation Succeeds
        RM->>+Service: (Optional) Call service.getProductById(request.params.id)
        Service->>Service: Perform business logic (e.g., DB query)
        Service-->>-RM: Return result (e.g., product data or error)
        
        alt Service Operation Fails
            RM->>RM: (Catches error from Service)
            RM->>RM: this.handleError(serviceError, context)
            RM-->>-Fw: Returns/Throws ServiceError (or other CoreError)
        else Service Operation Succeeds
            RM->>RM: Prepare success response data
            RM-->>-Fw: Return response data (e.g., product object)
        end
    end

    alt Unhandled Error in RM or Fw directly
        Fw->>+ESysInt: Framework's Global Error Handler Invoked
        ESysInt->>ESysInt: mapErrorToCoreError(rawError)
        ESysInt->>ESys: handleError(mappedCoreError, requestContext)
        ESys->>ESys: (Processes error, invokes specific/default handlers)
        ESysInt->>ESysInt: serializeErrorForHttpResponse(mappedCoreError)
        ESysInt-->>-Fw: Serialized error payload & status code
    end
    
    Fw-->>-Client: HTTP Response (Success Data or Error Payload)
```

**Step-by-Step Explanation:** *(Refer to previously generated detailed steps)*

### 6.3. Event Propagation within the System

This flow describes how events are emitted by one component, processed by the `CoreEventBus`, and delivered to subscribed listener components. This mechanism enables decoupled, asynchronous communication.

**Event Propagation Flow**: 

```mermaid
sequenceDiagram
    participant CompA as Component A (Emitter, e.g., Module/Service)
    participant EBSys as EventBusSystem
    participant CEBus as CoreEventBus
    participant CompB as Component B (Subscriber)
    participant CompC as Component C (Pattern/Wildcard Subscriber)
    participant ESys as ErrorSystem (via safeHandleError)

    CompA->>EBSys: getEventBus()
    EBSys-->>CompA: Returns CoreEventBus instance

    CompA->>+CEBus: emit("user:created", userData, { metadata: {...}, queue: false })
    CEBus->>CEBus: Create Standard Event Object (id, name, data, timestamp, metadata)
    CEBus->>CEBus: trackEvent(eventObject)
    CEBus->>CEBus: Record 'eventbus.events.emitted' metric

    alt options.queue is true
        CEBus->>CEBus: queueEvent(eventObject, options)
        Note over CEBus: Event added to queue.
        opt options.immediate is true
            CEBus->>CEBus: processQueue("user:created")
            %% Simplified queue processing for this diagram
            %% Actual processQueue involves batching & emitting to listeners
        end
    else options.queue is false (Direct Emission)
        Note over CEBus: Identify matching subscribers for "user:created"
        CEBus->>CompB: (Invoke CompB.handler(eventObject))
        CompB->>CompB: Process event "user:created"
        alt Error in CompB handler
            CompB->>CEBus: handleError(handlerError, context)
            CEBus->>ESys: (via safeHandleError) report error
        end

        Note over CEBus: Check for pattern/wildcard subscribers
        opt Wildcard Forwarding Active
            CEBus->>CompC: (Invoke CompC.handler(eventObject) if pattern matches or is '*')
            CompC->>CompC: Process event (e.g., "user:created" for "user.*" or "*")
             alt Error in CompC handler
                CompC->>CEBus: handleError(handlerError, context)
                CEBus->>ESys: (via safeHandleError) report error
            end
        end
    end
    CEBus-->>-CompA: Returns boolean (emit result)
```

**Step-by-Step Explanation:** *(Refer to previously generated detailed steps)*

### 6.4. Centralized Error Reporting in Action

This flow describes how errors, once they occur in any part of the application (business modules, services, or even core systems themselves), are processed through a standardized pathway leading to the `ErrorSystem`.

**Centralized Error Reporting Flow**: 

```mermaid
sequenceDiagram
    participant OriginComp as Error Origin (e.g., Business Module, Service)
    participant CoreModBase as CoreModule (if Origin is a module)
    participant ErrorUtil as ErrorUtils (safeHandleError)
    participant ErrSys as ErrorSystem
    participant CustomErrHndlr as Custom Error Handler (Optional)
    participant DefaultErrHndlr as Default CoreError Handler
    participant Logger as Logger (via ErrorSystem)
    participant FrameworkInt as Framework Integration (e.g., FastifyErrorHandler, if HTTP context)
    participant HTTPFw as HTTP Framework

    OriginComp->>OriginComp: Error Occurs (e.g., DB_CONNECTION_FAILED)
    OriginComp->>OriginComp: Create CoreError subclass instance (e.g., new ServiceError(DB_FAIL, ...))
    
    alt Error in CoreModule derivative
        OriginComp->>CoreModBase: this.handleError(error, context)
        CoreModBase->>CoreModBase: Log to this.state.errors & record metric
        CoreModBase->>ErrorUtil: safeHandleError(this.deps.errorSystem, error, moduleContext)
    else Direct use of safeHandleError (e.g., from a non-CoreModule service)
        OriginComp->>ErrorUtil: safeHandleError(errorSystemInstance, error, context)
    end

    ErrorUtil->>+ErrSys: errorSystem.handleError(error, context)
    ErrSys->>ErrSys: Record 'errorsystem.errors.received' metric
    ErrSys->>ErrSys: Ensure error is CoreError (wrap if necessary)
    ErrSys->>ErrSys: Lookup specific handler for error.constructor.name
    
    alt Specific Handler Registered (e.g., for ServiceError)
        ErrSys->>+CustomErrHndlr: customHandler(error, context)
        CustomErrHndlr->>CustomErrHndlr: Perform specific actions (e.g., notify, custom log)
        CustomErrHndlr-->>-ErrSys: Processing complete
        ErrSys->>ErrSys: Emit 'error:handled' event
    else No Specific Handler (or handler re-throws/fails)
        ErrSys->>+DefaultErrHndlr: defaultCoreErrorHandler(error, context)
        DefaultErrHndlr->>Logger: logger.error(error.toJSON(), context)
        DefaultErrHndlr-->>-ErrSys: Processing complete
        ErrSys->>ErrSys: Emit 'error:handled' event (or 'error:handler_failed' if custom handler failed)
    end
    ErrSys-->>-ErrorUtil: (handleError completes)

    opt Error occurred in HTTP Request Context & Framework Integration exists
        ErrorUtil-->>FrameworkInt: (Error propagates back to framework's error handler, which uses FrameworkInt)
        FrameworkInt->>FrameworkInt: mapErrorToCoreError(originalErrorIfNotCoreError)
        FrameworkInt->>ErrSys: (Potentially) errorSystem.handleError(mappedCoreError, reqContext)
        FrameworkInt->>FrameworkInt: serializeErrorForHttpResponse(processedError)
        FrameworkInt->>HTTPFw: reply.status(code).send(serializedError)
        HTTPFw-->>Client: HTTP Error Response
    end
```

**Step-by-Step Explanation:** *(Refer to previously generated detailed steps)*

### 6.5. Conceptual Health & Metrics Aggregation Flow

This flow outlines how a dedicated Monitoring Layer or Admin Interface could collect and aggregate health status and performance metrics from the various TSMIS core systems.

**Conceptual Health & Metrics Aggregation Flow**: 

```mermaid
graph TD
    A[Monitoring Layer / Admin Interface] -- Periodically or On-Demand --> Polls;

    subgraph Polls
        direction LR
        A --> CS[ContainerSystem.checkHealth() / .getMetrics()];
        A --> ES[ErrorSystem.checkHealth() / .getMetrics()];
        A --> EBSys[EventBusSystem.checkHealth() / .getMetrics()];
        A --> MS[ModuleSystem.checkHealth() / .getMetrics()];
        A --> RS[RouterSystem.checkHealth() / .getMetrics()];
    end

    EBSys -- Internally Calls --> CEB[CoreEventBus.checkHealth() / .getMetrics()];
    MS -- Internally Calls --> Mods["For each Module:<br>module.checkHealth() / .getMetrics()"];
    RS -- Internally Calls --> CR[CoreRouter.checkHealth() / .getMetrics()];
    
    CS --> B[Standardized Health/Metrics Response];
    ES --> B;
    EBSys --> B;
    MS --> B;
    RS --> B;
    
    B --> A;
    A --> Display[Unified Dashboard / Alerting System];

    classDef monitor fill:#E6E6FA,stroke:#9370DB,stroke-width:2px;
    classDef system fill:#D6EAF8,stroke:#5DADE2,stroke-width:2px;
    classDef internal fill:#E8F8F5,stroke:#76D7C4,stroke-width:1px;
    class A,Display monitor;
    class CS,ES,EBSys,MS,RS system;
    class CEB,Mods,CR internal;
```

**Step-by-Step Explanation:** *(Refer to previously generated detailed steps)*

---
## 7. Developing Business Modules: A Practical Guide

This section provides a comprehensive guide for developers on creating new business logic modules within the TSMIS application. All business modules must extend `CoreModule` or its specialized subclass `RoutableModule` to ensure they integrate seamlessly with the core architecture's lifecycle, error handling, eventing, health monitoring, and metrics systems. Adhering to these patterns will lead to consistent, maintainable, and robust application features.

### 7.1. Guiding Principles for Module Design

When developing new business modules for TSMIS, the following principles should be observed:
* **Single Responsibility & Cohesion**.
* **Loose Coupling** (via Events and DI).
* **Clear Interfaces**.
* **Configuration Driven**.
* **Leverage `CoreModule` Features** (Lifecycle hooks, `handleError`, `emit`, health, metrics).
* **Service Layer Separation** (Recommended for complex logic).
* **Testability**.

### 7.2. Extending `CoreModule` or `RoutableModule`

* **`CoreModule`**: For business logic not directly exposing HTTP endpoints.
* **`RoutableModule`**: For modules that need to define and handle HTTP API routes (extends `CoreModule`).

### 7.3. Example Module: `InventoryModule`

Illustrates creating a module extending `RoutableModule`.

#### 7.3.1. Recommended Directory Structure

**Example**: 

```text
src/
└── modules/
    └── inventory/
        ├── InventoryModule.js        # The main module class, extends RoutableModule
        ├── InventoryService.js       # Contains the core business logic/rules for inventory
        ├── inventory.errors.js       # (Optional) Custom ErrorTypes or specific ErrorCodes
        ├── inventory.events.js       # (Optional) Constants for event names specific to inventory
        ├── schemas/                  # (Optional) Validation schemas for API requests/responses
        │   ├── addItem.schema.js
        │   └── updateStock.schema.js
        └── tests/
            ├── InventoryModule.test.js   # Unit tests for the module class
            └── InventoryService.test.js  # Unit tests for the service logic
```

#### 7.3.2. Defining Routes and Handlers (within the RoutableModule)
Routes (`this.registerRoute()`) are typically defined in `onInitialize()`. Handlers are methods of the module class.

**Inventory module**: Example Route Definitions in onInitialize


```javascript
// Inside InventoryModule.js
// async onInitialize() {
//   await super.onInitialize(); // Important! This calls RoutableModule's onInitialize, which triggers registerAllRoutes

//   // Define API routes
//   this.registerVersionedRoute(1, 'POST', '/items', this.handleAddItem, {
//     schema: addItemSchema, // Reference to an imported schema object
//   });
//   this.registerVersionedRoute(1, 'GET', '/items/:sku', this.handleGetItem);
//   // ... other route definitions
// }

// // Handler methods also within InventoryModule.js
// async handleAddItem(request, reply) { /* ... handler logic ... */ }
// async handleGetItem(request, reply) { /* ... handler logic ... */ }
```

#### 7.3.3. Defining Module-Specific Errors (`inventory.errors.js`)
Define custom `InventoryError` (extending `ModuleError`) and `InventoryErrorCodes`.

**Example**: 

```javascript
// src/modules/inventory/inventory.errors.js
import { ModuleError } from '../../core/errors/index.js'; // Assuming CoreError, ModuleError are exported from here
import { ErrorCodes as CoreErrorCodes } from '../../core/errors/ErrorCodes.js'; // Assuming ErrorCodes.js is directly accessible

/**
 * Custom error class for inventory-specific operational errors.
 * Extends ModuleError to indicate its origin within a module.
 */
export class InventoryError extends ModuleError {
  /**
   * Creates a new InventoryError instance.
   * @param {string} specificCode - The specific inventory error code (e.g., 'ITEM_NOT_FOUND').
   * @param {string} message - Human-readable error message.
   * @param {object} [details={}] - Additional error details.
   * @param {object} [options={}] - Options, including 'cause'.
   */
  constructor(specificCode, message, details = {}, options = {}) {
    // The constructor of InventoryError will prepend "INVENTORY_" to the specificCode
    // and then call super (ModuleError) which will prepend "MODULE_".
    // So, the final code will be "MODULE_INVENTORY_SPECIFIC_CODE".
    // This was decided to allow ModuleError to have its prefix.
    // If direct "INVENTORY_SPECIFIC_CODE" is desired, then ModuleError's constructor
    // should not add a prefix, or InventoryError should inherit directly from CoreError.
    // For consistency with the refactored CoreModule expecting specific codes and adding its own prefix:
    super(`INVENTORY_${specificCode}`, message, details, options);
    this.name = 'InventoryError'; // Explicitly set name
  }
}

// Define specific error codes for the Inventory domain
export const InventoryErrorCodes = Object.freeze({
  ITEM_NOT_FOUND: 'ITEM_NOT_FOUND',
  INSUFFICIENT_STOCK: 'INSUFFICIENT_STOCK',
  INVALID_SKU_FORMAT: 'INVALID_SKU_FORMAT',
  NEGATIVE_STOCK_UNSUPPORTED: 'NEGATIVE_STOCK_UNSUPPORTED',
  ITEM_ALREADY_EXISTS: 'ITEM_ALREADY_EXISTS',
  INVALID_CONFIG_VALUE: 'INVALID_CONFIG_VALUE', // Added from InventoryModule.onValidateConfig example
  INVALID_QUANTITY_CHANGE: 'INVALID_QUANTITY_CHANGE', // Added from InventoryService.updateStock example
  // Add other inventory-specific error codes here
});

// Merge with core error codes for convenience if this module needs to throw
// or reference error codes from other domains (e.g., a generic CORE.VALIDATION_FAILED).
// This is optional; the module can also import CoreErrorCodes directly if needed.
export const ErrorCodes = Object.freeze({
  ...CoreErrorCodes, // Includes CORE, MODULE, VALIDATION, CONFIG, etc.
  INVENTORY: InventoryErrorCodes, // Nests inventory-specific codes
});
```

#### 7.3.4. Defining Module-Specific Events (`inventory.events.js`)
Define constants for event names (e.g., `INVENTORY_EVENTS.ITEM_ADDED`).

**Example**: 

```javascript
// src/modules/inventory/inventory.events.js

/**
 * Defines standardized event names related to the Inventory module.
 * Using constants helps prevent typos and ensures consistency when emitting
 * or subscribing to these events.
 */
export const INVENTORY_EVENTS = Object.freeze({
  // Events emitted by InventoryModule
  ITEM_ADDED: 'inventory.item.added',               // When a new item is added to inventory
  ITEM_REMOVED: 'inventory.item.removed',           // When an item is removed from inventory (if applicable)
  ITEM_UPDATED: 'inventory.item.updated',           // When general item details (name, price, etc.) are updated
  STOCK_UPDATED: 'inventory.item.stock_updated',    // When the stock quantity of an item changes
  STOCK_LOW: 'inventory.item.stock_low',            // When an item's stock drops below a defined threshold
  STOCK_OUT_OF_STOCK: 'inventory.item.out_of_stock',// When an item's stock reaches zero (or below if allowed)
  BULK_STOCK_ADJUSTED: 'inventory.bulk_stock_adjusted', // When multiple items' stock levels are adjusted

  // Example of events InventoryModule might listen to from other modules
  // (These would typically be defined in the emitting module's events file,
  // but are included here for illustrative purposes of what Inventory might consume)
  ORDER_ITEM_ALLOCATED: 'order.item.allocated',     // From an OrderModule, indicating stock needs to be reduced
  ORDER_ITEM_RETURNED: 'order.item.returned',       // From an OrderModule, indicating stock needs to be increased
  PRODUCT_DISCONTINUED: 'product.discontinued',   // From a ProductCatalogModule, might trigger inventory removal
});
```

#### 7.3.5. Implementing the Business Logic Service (`InventoryService.js`)
Encapsulates core business rules and data interaction. Declares `static dependencies` for DI.

**Example**: 

```javascript
// src/modules/inventory/InventoryService.js
import { InventoryError, InventoryErrorCodes } from './inventory.errors.js';
// For a real application, you would import your database abstraction/service here
// import { DatabaseService } from '../../core/services/DatabaseService'; // Example

export class InventoryService {
  // Declare dependencies that ContainerSystem should inject
  static dependencies = ['config', 'logger' /*, 'databaseService' */]; // Add 'databaseService' if using a real one

  /**
   * Creates an instance of InventoryService.
   * @param {object} deps - Dependencies injected by the ContainerSystem.
   * @param {object} [deps.config={}] - Application configuration.
   * @param {object} [deps.logger=console] - Logger instance.
   * @param {object} [deps.databaseService] - Database service instance (if used).
   */
  constructor(deps) {
    // Get module-specific config, falling back to an empty object
    this.config = deps.config?.inventory?.service || deps.config?.inventoryService || {};
    this.logger = deps.logger || console;
    // this.db = deps.databaseService; // If using a real database service

    // Using an in-memory store for this example for simplicity
    this._stock = new Map(); // Map<sku, { name, description, quantity, price, supplierId, ... }>
    this.logger.info(`[InventoryService] Initialized. Allow Negative Stock: ${!!this.config.allowNegativeStock}`);
  }

  /**
   * Adds a new item to the inventory.
   * @param {object} itemData - Data for the new item.
   * @param {string} itemData.sku - Stock Keeping Unit (unique identifier).
   * @param {string} itemData.name - Name of the item.
   * @param {number} itemData.quantity - Initial quantity.
   * @param {number} itemData.price - Price per unit.
   * @param {string} [itemData.description] - Optional description.
   * @param {string} [itemData.supplierId] - Optional supplier ID.
   * @returns {Promise<object>} The added item.
   * @throws {InventoryError} If item data is invalid or SKU already exists.
   */
  async addItem(itemData) {
    if (!itemData || !itemData.sku || !itemData.name || typeof itemData.quantity !== 'number' || typeof itemData.price !== 'number') {
      throw new InventoryError(
        InventoryErrorCodes.INVALID_SKU_FORMAT, // Using a more specific code from our inventory.errors.js
        'Item data is invalid. SKU, name, quantity, and price are required.',
        { providedSku: itemData?.sku, providedName: itemData?.name }
      );
    }
    if (this._stock.has(itemData.sku)) {
      throw new InventoryError(
        InventoryErrorCodes.ITEM_ALREADY_EXISTS,
        `Item with SKU '${itemData.sku}' already exists in inventory.`,
        { sku: itemData.sku }
      );
    }

    const newItem = { ...itemData };
    this._stock.set(itemData.sku, newItem);
    this.logger.info(`[InventoryService] Item added: SKU='${itemData.sku}', Name='${itemData.name}', Quantity=${itemData.quantity}`);
    return { ...newItem }; // Return a copy
  }

  /**
   * Retrieves an item from inventory by its SKU.
   * @param {string} sku - The SKU of the item to retrieve.
   * @returns {Promise<object|null>} The item data, or null if not found.
   */
  async getItemBySku(sku) {
    if (!sku) {
      // Or throw new InventoryError(InventoryErrorCodes.INVALID_SKU_FORMAT, 'SKU must be provided.');
      this.logger.warn('[InventoryService] Attempted to get item with empty SKU.');
      return null;
    }
    const item = this._stock.get(sku);
    return item ? { ...item } : null; // Return a copy
  }

  /**
   * Updates the stock quantity for a given SKU.
   * @param {string} sku - The SKU of the item to update.
   * @param {number} quantityChange - The change in quantity (can be positive or negative).
   * @returns {Promise<object>} The updated item data.
   * @throws {InventoryError} If item not found, or if stock becomes negative and it's not allowed.
   */
  async updateStock(sku, quantityChange) {
    if (typeof quantityChange !== 'number' || isNaN(quantityChange)) {
        throw new InventoryError(InventoryErrorCodes.INVALID_QUANTITY_CHANGE || 'INVALID_QUANTITY_CHANGE', 'Quantity change must be a valid number.', { sku, quantityChange });
    }

    const item = this._stock.get(sku);
    if (!item) {
      throw new InventoryError(InventoryErrorCodes.ITEM_NOT_FOUND, `Item with SKU '${sku}' not found for stock update.`, { sku });
    }

    const newQuantity = item.quantity + quantityChange;

    if (newQuantity < 0 && !(this.config.allowNegativeStock === true)) {
      throw new InventoryError(
        InventoryErrorCodes.INSUFFICIENT_STOCK,
        `Insufficient stock for SKU '${sku}'. Change: ${quantityChange}, Current: ${item.quantity}, Attempted New: ${newQuantity}.`,
        { sku, currentQuantity: item.quantity, requestedChange: quantityChange, newQuantity }
      );
    }

    item.quantity = newQuantity;
    // item.lastUpdated = new Date().toISOString(); // Example additional field
    this._stock.set(sku, item);
    this.logger.info(`[InventoryService] Stock updated for SKU='${sku}'. Quantity change: ${quantityChange}, New quantity: ${newQuantity}.`);
    return { ...item }; // Return a copy
  }

  /**
   * Gets the current stock level for a given SKU.
   * @param {string} sku - The SKU of the item.
   * @returns {Promise<number>} The current stock quantity, or 0 if item not found.
   */
  async getStockLevel(sku) {
    const item = await this.getItemBySku(sku);
    return item ? item.quantity : 0;
  }

  /**
   * Lists all items currently in inventory.
   * @returns {Promise<Array<object>>} An array of all inventory items.
   */
  async listItems() {
    return Array.from(this._stock.values()).map(item => ({ ...item })); // Return copies
  }

  /**
   * Example health check for the InventoryService.
   * For a service with external dependencies (like a database), this would check those connections.
   * @returns {Promise<{status: string, detail: object, errors?: Array<Error>}>} Standardized health check result.
   */
  async checkHealth() {
    // For an in-memory service, its "health" is generally tied to the application's health.
    // If it had a database connection, you'd check `this.db.isConnected()` or similar.
    const detail = {
      itemCount: this._stock.size,
      allowsNegativeStock: !!this.config.allowNegativeStock,
      // Add other relevant operational details if any
    };
    // This simple service is considered healthy if it's running.
    // In a real scenario, you might check for memory limits if the in-memory store grows too large.
    return { status: 'healthy', detail }; // Uses createStandardHealthCheckResult implicitly via CoreModule
  }
}

/**
 * Factory function for creating an InventoryService instance.
 * This is useful for registering the service with the ContainerSystem.
 * @param {object} deps - Dependencies to be passed to the InventoryService constructor.
 * @returns {InventoryService}
 */
export function createInventoryService(deps) {
  return new InventoryService(deps);
}
```

#### 7.3.6. Defining API Schemas (`schemas/addItem.schema.js`)
Use JSON Schema for request/response validation, passed in `registerRoute` options.

**Example**: 

```javascript
// src/modules/inventory/schemas/addItem.schema.js

/**
 * JSON Schema for validating the request body when adding a new inventory item
 * and for defining the expected response structure on successful creation.
 * This schema can be used by Fastify for automatic request validation and response serialization.
 */
export const addItemSchema = {
  // Schema for the request body
  body: {
    type: 'object',
    required: ['sku', 'name', 'quantity', 'price'],
    properties: {
      sku: {
        type: 'string',
        minLength: 1,
        description: 'Stock Keeping Unit (unique identifier for the item).',
        examples: ['TSHIRT-RED-L']
      },
      name: {
        type: 'string',
        minLength: 1,
        maxLength: 255,
        description: 'Name of the inventory item.',
        examples: ['Red Cotton T-Shirt - Large']
      },
      description: {
        type: 'string',
        description: 'Optional detailed description of the item.',
        examples: ['A comfortable large red t-shirt made of 100% cotton.']
      },
      quantity: {
        type: 'integer',
        minimum: 0, // Assuming stock cannot be negative initially
        description: 'Initial stock quantity of the item.',
        examples: [100]
      },
      price: {
        type: 'number',
        minimum: 0,
        description: 'Price per unit of the item.',
        examples: [19.99]
      },
      supplierId: {
        type: 'string',
        nullable: true, // Making it optional
        description: 'Optional identifier for the item supplier.',
        examples: ['SUPPLIER-XYZ']
      },
      attributes: {
        type: 'object',
        nullable: true,
        description: 'Optional key-value pairs for custom item attributes (e.g., size, color).',
        additionalProperties: true, // Allows any properties within the attributes object
        examples: [{ size: 'Large', color: 'Red', material: 'Cotton' }]
      }
    },
  },
  // Schema for the successful response (e.g., HTTP 201 Created)
  response: {
    201: { 
      description: 'Item created successfully.',
      type: 'object',
      properties: {
        // Typically, you return the created resource, possibly with server-generated fields like an ID
        id: { type: 'string', format: 'uuid', description: 'System-generated unique ID for the inventory item entry (if different from SKU).' },
        sku: { type: 'string' },
        name: { type: 'string' },
        description: { type: 'string', nullable: true },
        quantity: { type: 'integer' },
        price: { type: 'number' },
        supplierId: { type: 'string', nullable: true },
        attributes: { type: 'object', nullable: true, additionalProperties: true },
        createdAt: { type: 'string', format: 'date-time', description: 'Timestamp of item creation.' },
        // Ensure this matches what your handler actually returns
      },
    },
    // You can define other response schemas for error codes too (e.g., 400, 409)
    // though error responses are often handled globally by the ErrorSystem's framework integration.
  },
};
```

#### 7.3.7. Implementing the Main Module Class (`InventoryModule.js`)
Extends `RoutableModule`, injects `InventoryService`, implements lifecycle hooks, defines route handlers, uses `this.handleError`, `this.emit`, `this.recordMetric`.

**Example**: 

```javascript
// src/modules/inventory/InventoryModule.js
import { RoutableModule } from '../../core/router/RoutableModule.js';
import { ErrorCodes as CoreErrorCodes } from '../../core/errors/ErrorCodes.js';
import { InventoryError, InventoryErrorCodes } from './inventory.errors.js';
import { INVENTORY_EVENTS } from './inventory.events.js';
import { addItemSchema } from './schemas/addItem.schema.js';
// import { updateStockSchema } from './schemas/updateStock.schema.js'; // Assuming this schema exists
import { SYSTEM_STATUS } from '../../core/common/SystemConstants.js';
import { createStandardHealthCheckResult } from '../../core/common/ErrorUtils.js';
import { ValidationError, CoreError } from '../../core/errors/index.js';


export class InventoryModule extends RoutableModule {
  static dependencies = [...RoutableModule.dependencies, 'inventoryService'];
  static version = '1.0.0';

  constructor(deps) {
    super(deps);
    this.inventoryService = deps.inventoryService;
    this.lowStockThreshold = 10; // Default
    this.subscriptions = [];
    this.deps.logger.info(`[${this.constructor.name}] Constructed.`);
  }

  async onValidateConfig() {
    await super.onValidateConfig();
    if (this.config.lowStockThreshold !== undefined) {
      if (typeof this.config.lowStockThreshold !== 'number' || this.config.lowStockThreshold < 0) {
        throw new InventoryError(
          InventoryErrorCodes.INVALID_CONFIG_VALUE || 'INVALID_CONFIG_VALUE',
          "Configuration 'lowStockThreshold' for InventoryModule must be a non-negative number.",
          { field: 'lowStockThreshold', providedValue: this.config.lowStockThreshold }
        );
      }
    }
    this.recordMetric(`${this.constructor.name.toLowerCase()}.config.validated`, 1);
    return true;
  }

  async onConfigure() {
    await super.onConfigure();
    if (this.config.lowStockThreshold !== undefined) {
      this.lowStockThreshold = this.config.lowStockThreshold;
    }
    this.recordMetric(`${this.constructor.name.toLowerCase()}.configured`, 1, { lowStockThreshold: this.lowStockThreshold });
    this.deps.logger.info(`[${this.constructor.name}] Configured. Low stock threshold: ${this.lowStockThreshold}`);
  }

  async setupEventHandlers() {
    await super.setupEventHandlers();
    if (!this.eventBus) {
        this.deps.logger.warn(`[${this.constructor.name}] EventBus not available during setupEventHandlers. Skipping event subscriptions.`);
        return;
    }
    this.subscriptions.push(
      this.eventBus.subscribe(INVENTORY_EVENTS.ORDER_ITEM_ALLOCATED, this.handleOrderItemAllocated.bind(this))
    );
    this.deps.logger.info(`[${this.constructor.name}] Event handlers set up. Subscribed to: ${this.subscriptions.map(s => (this.eventBus.subscriptions.get(s)?.pattern || 'unknown')).join(', ')}`);
  }

  async onSetupHealthChecks() {
    await super.onSetupHealthChecks(); 
    
    if (this.inventoryService && typeof this.inventoryService.checkHealth === 'function') {
      this.registerHealthCheck('inventorymodule.service.dependency', async () => {
        try {
          const serviceHealth = await this.inventoryService.checkHealth();
          return createStandardHealthCheckResult(serviceHealth.status, serviceHealth.detail, serviceHealth.errors);
        } catch (error) {
          const serviceHealthError = error instanceof CoreError ? error : new ModuleError(CoreErrorCodes.MODULE.HEALTH_CHECK_FAILED, error.message, {}, {cause: error});
          return createStandardHealthCheckResult(SYSTEM_STATUS.UNHEALTHY, { error: 'InventoryService health check failed or threw an exception.' }, [serviceHealthError]);
        }
      });
    } else {
       this.registerHealthCheck('inventorymodule.service.dependency', async () => 
        createStandardHealthCheckResult(SYSTEM_STATUS.UNHEALTHY, { reason: 'InventoryService not available or does not implement checkHealth().' })
       );
    }
    this.deps.logger.info(`[${this.constructor.name}] Custom health checks registered.`);
  }

  async onInitialize() {
    this.deps.logger.info(`[${this.constructor.name}] Defining routes...`);
    this.registerVersionedRoute(1, 'POST', '/items', this.handleAddItem, {
      schema: addItemSchema,
    });
    this.registerVersionedRoute(1, 'GET', '/items/:sku', this.handleGetItem);
    this.registerVersionedRoute(1, 'PUT', '/items/:sku/stock', this.handleUpdateStock, {
      // schema: updateStockSchema,
    });
    this.registerVersionedRoute(1, 'GET', '/items', this.handleListItems);
    
    await super.onInitialize(); 

    this.deps.logger.info(`[${this.constructor.name}] Initialized and routes defined for registration.`);
  }

  async onShutdown() {
    this.deps.logger.info(`[${this.constructor.name}] Shutting down...`);
    if (this.eventBus && this.subscriptions) {
      for (const subId of this.subscriptions) {
        this.eventBus.unsubscribe(subId);
      }
      this.deps.logger.info(`[${this.constructor.name}] Unsubscribed ${this.subscriptions.length} event listeners.`);
    }
    this.subscriptions = [];
    
    await super.onShutdown();
    this.deps.logger.info(`[${this.constructor.name}] Shutdown complete.`);
  }

  async handleAddItem(request, reply) {
    let itemData; 
    try {
      itemData = request.body;
      const newItem = await this.inventoryService.addItem(itemData);
      await this.emit(INVENTORY_EVENTS.ITEM_ADDED, { item: newItem, byUser: request.user?.id || 'system' });
      this.recordMetric('inventorymodule.api.items_added', 1, { result: 'success' });
      reply.code(201);
      return newItem;
    } catch (error) {
      this.recordMetric('inventorymodule.api.items_added', 1, { result: 'failure', errorCode: error.code });
      await this.handleError(error, {
        operation: 'handleAddItem',
        endpoint: `${request.method} ${request.url}`,
        requestBodySummary: itemData ? Object.keys(itemData) : (request.body ? Object.keys(request.body) : null)
      });
      throw error;
    }
  }

  async handleGetItem(request, reply) {
    const { sku } = request.params;
    try {
      const item = await this.inventoryService.getItemBySku(sku);
      if (!item) {
        throw new InventoryError(InventoryErrorCodes.ITEM_NOT_FOUND, `Item with SKU ${sku} not found.`, { sku });
      }
      this.recordMetric('inventorymodule.api.items_fetched', 1, { result: 'success', sku });
      return item;
    } catch (error) {
      this.recordMetric('inventorymodule.api.items_fetched', 1, { result: 'failure', errorCode: error.code, sku });
      await this.handleError(error, { operation: 'handleGetItem', sku });
      throw error;
    }
  }

  async handleUpdateStock(request, reply) {
    const { sku } = request.params;
    const { quantityChange, reason } = request.body;
    try {
      if (typeof quantityChange !== 'number') {
        throw new ValidationError(CoreErrorCodes.VALIDATION.INVALID_INPUT, 'Field \'quantityChange\' must be a number.', { field: 'quantityChange' });
      }
      const updatedItem = await this.inventoryService.updateStock(sku, quantityChange);
      await this.emit(INVENTORY_EVENTS.STOCK_UPDATED, { 
        item: { sku: updatedItem.sku, newQuantity: updatedItem.quantity }, 
        change: quantityChange, 
        reason: reason || 'N/A',
        byUser: request.user?.id || 'system' 
      });
      
      if (updatedItem.quantity < this.lowStockThreshold && updatedItem.quantity > 0) {
        await this.emit(INVENTORY_EVENTS.STOCK_LOW, { item: updatedItem, threshold: this.lowStockThreshold });
      } else if (updatedItem.quantity <= 0 && !(this.inventoryService.config.allowNegativeStock === true) ) {
        await this.emit(INVENTORY_EVENTS.STOCK_OUT_OF_STOCK, { item: updatedItem });
      }

      this.recordMetric('inventorymodule.api.stock_updated', 1, { result: 'success', sku });
      return updatedItem;
    } catch (error) {
      this.recordMetric('inventorymodule.api.stock_updated', 1, { result: 'failure', errorCode: error.code, sku });
      await this.handleError(error, { operation: 'handleUpdateStock', sku, requestBody: request.body });
      throw error;
    }
  }

  async handleListItems(request, reply) {
    try {
        const items = await this.inventoryService.listItems();
        this.recordMetric('inventorymodule.api.items_listed', 1, { result: 'success', count: items.length });
        return items;
    } catch (error) {
        this.recordMetric('inventorymodule.api.items_listed', 1, { result: 'failure', errorCode: error.code });
        await this.handleError(error, { operation: 'handleListItems' });
        throw error;
    }
  }

  async handleOrderItemAllocated(event) {
    const { itemId, quantityAllocated } = event.data;
    try {
      this.deps.logger.info(`[${this.constructor.name}] Received ${INVENTORY_EVENTS.ORDER_ITEM_ALLOCATED} for item SKU ${itemId}, quantity: ${quantityAllocated}. Updating stock...`);
      await this.inventoryService.updateStock(itemId, -quantityAllocated);
      this.recordMetric('inventorymodule.event.order_item_allocated_handled', 1, { itemId, quantity: quantityAllocated });
    } catch (error) {
      await this.handleError(error, {
        eventName: event.name,
        eventId: event.id,
        handler: 'handleOrderItemAllocated',
        payloadSummary: { itemId, quantityAllocated },
        criticality: 'high'
      });
    }
  }
}

export function createInventoryModule(deps) {
  return new InventoryModule(deps);
}
```

### 7.4. Registering the Module & Its Services with the Core
1. Register services (e.g., `InventoryService`) with `ContainerSystem`.
2. Register module class (e.g., `InventoryModule`) with `ModuleSystem`, passing module-specific config.

**Example**: Module and Service Registration

```javascript
// In your application bootstrap file (e.g., src/app.js or a dedicated setup file)

// Assume 'container' is your main ContainerSystem instance, already created.
// import { container } from './setupContainer.js'; // Example import

// Assume 'createInventoryService' is imported from your InventoryService.js
// import { createInventoryService } from './modules/inventory/InventoryService.js';

// Assume 'InventoryModule' class is imported (not its factory, as ModuleSystem takes the class)
// import { InventoryModule } from './modules/inventory/InventoryModule.js';


// async function setupApplicationModulesAndServices(container) {
//   // --- 1. Register Module-Specific Services with ContainerSystem ---
//   // Services like InventoryService are typically registered as components directly
//   // with the main application container so they can be injected into modules
//   // or even other services if needed.

//   container.register(
//     'inventoryService',         // Unique name for this service component in the container
//     createInventoryService,     // The factory function for InventoryService
//     {                           // Options for registration (e.g., singleton is usually default)
//       singleton: true,
//       // If InventoryService needed specific config passed at registration by the container,
//       // it would be structured based on how createInventoryService or its constructor handles it.
//       // Typically, services fetch their own config section from the global 'config' dependency.
//     }
//   );
//   // Example: this.deps.config.inventoryService in InventoryService constructor.

//   // ... register other application-specific services here ...


//   // --- 2. Get ModuleSystem instance ---
//   // ModuleSystem itself should have been registered with the ContainerSystem earlier
//   // (e.g., container.register('moduleSystem', createModuleSystem);)
//   // and is now resolved to be used.
//   let moduleSystem;
//   try {
//     moduleSystem = await container.resolve('moduleSystem');
//   } catch (error) {
//     console.error('Failed to resolve ModuleSystem from container:', error);
//     // Handle critical failure: application cannot proceed without ModuleSystem
//     throw error;
//   }


//   // --- 3. Register Business Modules with ModuleSystem ---
//   // ModuleSystem will use the container (passed as part of its own 'deps')
//   // to resolve 'inventoryService' when it instantiates InventoryModule.

//   try {
//     await moduleSystem.register(
//       'inventory',                // Unique name for this module instance within ModuleSystem
//       InventoryModule,            // The module class (not its factory)
//       {                           // Module-specific configuration for this instance of InventoryModule
//         lowStockThreshold: 5,     // This becomes `this.config.lowStockThreshold` in InventoryModule
//         // Other InventoryModule specific configurations...
//         // Note: Configuration for 'inventoryService' is typically handled when 'inventoryService'
//         // itself is created/configured, often by accessing a global config object
//         // (e.g., this.deps.config.inventoryService inside the service).
//       }
//     );
//     console.log('InventoryModule registered with ModuleSystem.');
//   } catch (error) {
//     console.error('Failed to register InventoryModule:', error);
//     // Handle module registration failure
//     throw error;
//   }

//   // ... register other business modules with moduleSystem ...


//   // --- 4. Application Initialization Cascade ---
//   // At a later point in your bootstrap, after all core systems, services,
//   // and modules are registered, you would call:
//   // await container.initialize();

//   // This single call to container.initialize() will:
//   //   a. Initialize all registered components in dependency order, including ErrorSystem, EventBusSystem,
//   //      ModuleSystem itself, RouterSystem, InventoryService, etc.
//   //   b. When ModuleSystem.initialize() is called by the container, it will in turn call
//   //      initialize() on all its registered modules (like InventoryModule) in their dependency order.
//   //   c. InventoryModule.initialize() will then run its 'onInitialize' hook,
//   //      registering its routes via events, etc.

//   console.log('Module and service registration phase complete. Container ready for initialization.');
// }

// // Example of how this setup function might be called:
// //
// // import { createContainerSystem } from './core/container/ContainerSystem.js';
// // import { createErrorSystem } from './core/errors/ErrorSystem.js';
// // import { createEventBusSystem } from './core/event/EventBusSystem.js';
// // import { createModuleSystem } from './core/module/ModuleSystem.js';
// // // ... other necessary imports ...

// // async function bootstrap() {
// //   const container = createContainerSystem();
// //
// //   // Register core systems
// //   container.register('config', () => ({ /* global app config here */ }));
// //   container.register('logger', () => console); // Simple logger
// //   container.register('errorSystem', createErrorSystem);
// //   container.register('eventBusSystem', createEventBusSystem);
// //   container.register('moduleSystem', createModuleSystem);
// //   container.register('routerSystem', createRouterSystem); // Assuming this exists
// //
// //   // Setup application-specific modules and services
// //   await setupApplicationModulesAndServices(container);
// //
// //   // Initialize the entire application
// //   await container.initialize();
// //
// //   console.log('Application bootstrapped and all systems initialized.');
// //   // ... start HTTP server or other application entry points ...
// // }
// //
// // bootstrap().catch(err => {
// //   console.error("Critical bootstrap failure:", err);
// //   process.exit(1);
// // });
```

### 7.5. Module-specific Configuration Details
Module config passed to `ModuleSystem.register()` is available as `this.config` in the module. Services access their config via the global `config` object injected by `ContainerSystem`.

**(Refer to code examples for `InventoryModule` constructor, `InventoryService` constructor, and global config structure provided earlier)**

**Example**: Passing Configuration during `moduleSystem.register()`

```javascript
// Example:
// Assuming 'moduleSystem' is an instance of ModuleSystem
// and 'InventoryModule' is the class definition.

// moduleSystem.register(
//   'inventory', // Module instance name
//   InventoryModule, // Module class
//   { // This is the module-specific config object for this 'inventory' instance
//     lowStockThreshold: 5,
//     defaultSupplier: 'SUP-001',
//     featureFlags: { enableAdvancedAnalytics: true }
//   }
// );
```

**Example**: Accessing `this.config` in `InventoryModule.js`

```javascript
// Example within InventoryModule.js:
// class InventoryModule extends RoutableModule {
//   constructor(deps) {
//     super(deps);
//     // 'this.config' is automatically set by CoreModule's constructor
//     // to the config object passed during moduleSystem.register().
//     // So, this.config would be:
//     // { lowStockThreshold: 5, defaultSupplier: 'SUP-001', featureFlags: { enableAdvancedAnalytics: true } }

//     this.lowStockThreshold = this.config.lowStockThreshold || 10; // Use default if not provided
//     this.defaultSupplierId = this.config.defaultSupplier;
//     this.analyticsEnabled = this.config.featureFlags?.enableAdvancedAnalytics || false;
//   }

//   async onConfigure() {
//      await super.onConfigure();
//      this.deps.logger.info(`[${this.constructor.name}] Low stock threshold set to: ${this.lowStockThreshold}`);
//   }
// }
```

**Example**: InventoryService Accessing its Configuration Section from Global Config

```javascript
// Example within InventoryService.js:
// class InventoryService {
//   static dependencies = ['config', 'logger']; // Expects global 'config' and 'logger'

//   constructor(deps) {
//     // deps.config here is the global application config object.
//     // The service looks for its specific section within this global config.
//     this.serviceConfig = deps.config?.inventoryService || {}; // Accessing 'inventoryService' section
//     this.logger = deps.logger || console;

//     this.allowNegativeStock = this.serviceConfig.allowNegativeStock === true;
//     this.dbPoolSize = this.serviceConfig.databasePoolSize || 5;

//     this.logger.info(`[InventoryService] Configured. Allow Negative Stock: ${this.allowNegativeStock}, DB Pool: ${this.dbPoolSize}`);
//   }
// }
```

**Example**: Structure of a Global Application Configuration Object

```javascript
// Example structure for a global application configuration object
// (e.g., loaded from a file, environment variables, and registered as 'config' in ContainerSystem)
// const globalAppConfig = {
//   appName: 'TSMIS App',
//   port: 3000,
//   environment: 'development',

//   logger: {
//     level: 'info',
//     prettyPrint: true,
//   },

//   eventBusSystem: {
//     // Configurations specific to EventBusSystem
//   },
//   coreEventBus: { // Configurations specific to CoreEventBus
//     maxHistorySize: 500,
//     queueBatchSize: 50,
//   },

//   moduleSystem: { // Configurations for ModuleSystem itself
//     defaultHealthCheckIntervalMs: 60000,
//   },

//   // Section specifically for the 'inventory' module instance
//   inventory: { 
//     lowStockThreshold: 5,
//     defaultSupplier: 'AcmeCorp',
//     featureFlags: {
//       enableAdvancedAnalytics: true,
//       enableAutoReorder: false,
//     }
//   },

//   // Section specifically for the 'inventoryService' component/service
//   inventoryService: { 
//     allowNegativeStock: false,
//     databasePoolSize: 10,
//     // Potentially database connection details if not handled by a separate db service config
//   },

//   // Configuration for other modules and services...
//   // userModule: { ... },
//   // databaseService: { host: 'localhost', user: 'tsmis_user', ... },
// };
```

### 7.6. Unit Testing Modules (Using Jest)
Mock dependencies, test business logic, lifecycle hooks, event/route handlers, error reporting, and metric recording. Recommended framework: Jest.

**Example**: 

```javascript
// src/modules/inventory/tests/InventoryModule.test.js
import { InventoryModule, createInventoryModule } from '../InventoryModule.js';
import { RoutableModule } from '../../../core/router/RoutableModule.js'; // To spy on its prototype
import { CoreModule } from '../../../core/module/CoreModule.js'; // For instanceof checks
import { InventoryError, InventoryErrorCodes } from '../inventory.errors.js';
import { INVENTORY_EVENTS } from '../inventory.events.js';
import { SYSTEM_STATUS } from '../../../core/common/SystemConstants.js';
import { ValidationError } from '../../../core/errors/index.js'; // Assuming index.js exports ValidationError
import { ErrorCodes as CoreErrorCodes } from '../../../core/errors/ErrorCodes.js';


describe('InventoryModule', () => {
  let mockDeps;
  let inventoryModule;
  let mockEventBus;

  beforeEach(() => {
    // Mock CoreEventBus instance methods
    mockEventBus = {
      emit: jest.fn().mockResolvedValue(true),
      subscribe: jest.fn().mockReturnValue('sub123-inventory-module-test'),
      unsubscribe: jest.fn(),
      subscriptions: new Map(), // Add a mock subscriptions map for get(s)?.pattern to work
    };
    // Mock get on the map for the logger call in setupEventHandlers
    mockEventBus.subscriptions.get = jest.fn().mockReturnValue({ pattern: INVENTORY_EVENTS.ORDER_ITEM_ALLOCATED });


    mockDeps = {
      errorSystem: {
        handleError: jest.fn().mockResolvedValue(undefined),
      },
      eventBusSystem: {
        getEventBus: jest.fn().mockReturnValue(mockEventBus),
      },
      config: { // This is the module-specific config passed to InventoryModule constructor
        lowStockThreshold: 7,
      },
      inventoryService: { // Mocked InventoryService
        addItem: jest.fn(),
        getItemBySku: jest.fn(),
        updateStock: jest.fn(),
        listItems: jest.fn(),
        checkHealth: jest.fn().mockResolvedValue({ status: SYSTEM_STATUS.HEALTHY, detail: { itemCount: 0 } }),
      },
      logger: { 
        info: jest.fn(),
        warn: jest.fn(),
        error: jest.fn(),
        debug: jest.fn(),
      },
    };

    inventoryModule = createInventoryModule(mockDeps);
  });

  afterEach(() => {
    jest.clearAllMocks(); 
  });

  test('constructor should correctly initialize properties and dependencies', () => {
    expect(inventoryModule).toBeInstanceOf(InventoryModule);
    expect(inventoryModule).toBeInstanceOf(RoutableModule); 
    expect(inventoryModule).toBeInstanceOf(CoreModule);
    expect(inventoryModule.inventoryService).toBe(mockDeps.inventoryService);
    expect(inventoryModule.lowStockThreshold).toBe(7); 
    expect(inventoryModule.deps.logger).toBe(mockDeps.logger);
    expect(inventoryModule.deps.errorSystem).toBe(mockDeps.errorSystem); 
    expect(inventoryModule.deps.eventBusSystem).toBe(mockDeps.eventBusSystem); 
  });

  describe('Lifecycle Hooks', () => {
    test('onValidateConfig should validate lowStockThreshold', async () => {
      await expect(inventoryModule.onValidateConfig()).resolves.toBe(true);

      inventoryModule.config.lowStockThreshold = -1; 
      await expect(inventoryModule.onValidateConfig()).rejects.toThrow(InventoryError); 

      inventoryModule.config.lowStockThreshold = 'not-a-number'; 
      await expect(inventoryModule.onValidateConfig()).rejects.toThrow(InventoryError);
    });

    test('onConfigure should set lowStockThreshold and record metric', async () => {
      inventoryModule.config.lowStockThreshold = 15;
      inventoryModule.recordMetric = jest.fn(); 

      await inventoryModule.onConfigure();

      expect(inventoryModule.lowStockThreshold).toBe(15);
      expect(inventoryModule.recordMetric).toHaveBeenCalledWith('inventorymodule.configured', 1, { lowStockThreshold: 15 });
      expect(inventoryModule.deps.logger.info).toHaveBeenCalledWith(expect.stringContaining('Configured. Low stock threshold: 15'));
    });

    test('setupEventHandlers should subscribe to events if eventBus is available', async () => {
      inventoryModule.eventBus = mockEventBus; // Ensure eventBus is explicitly set for the test
      await inventoryModule.setupEventHandlers();
      expect(mockEventBus.subscribe).toHaveBeenCalledWith(INVENTORY_EVENTS.ORDER_ITEM_ALLOCATED, expect.any(Function));
    });

    test('setupEventHandlers should warn if eventBus is not available', async () => {
      inventoryModule.eventBus = null; 
      await inventoryModule.setupEventHandlers();
      expect(inventoryModule.deps.logger.warn).toHaveBeenCalledWith(expect.stringContaining('EventBus not available during setupEventHandlers'));
      expect(mockEventBus.subscribe).not.toHaveBeenCalled();
    });
    
    test('onSetupHealthChecks should register service dependency health check', async () => {
      inventoryModule.registerHealthCheck = jest.fn(); 
      const superSpy = jest.spyOn(RoutableModule.prototype, 'onSetupHealthChecks').mockResolvedValue();

      await inventoryModule.onSetupHealthChecks(); // This calls the method on inventoryModule
      
      expect(superSpy).toHaveBeenCalled();
      expect(inventoryModule.registerHealthCheck).toHaveBeenCalledWith('inventorymodule.service.dependency', expect.any(Function));
      superSpy.mockRestore();
    });

    test('onInitialize should define routes and call super.onInitialize', async () => {
      const superOnInitializeSpy = jest.spyOn(RoutableModule.prototype, 'onInitialize').mockResolvedValue();
      inventoryModule.registerVersionedRoute = jest.fn(); 
      inventoryModule._validateDependencies = jest.fn(); 
      inventoryModule.eventBus = mockEventBus; 

      await inventoryModule.onInitialize(); // Call the method on the instance

      expect(inventoryModule.registerVersionedRoute).toHaveBeenCalledTimes(4); 
      expect(inventoryModule.registerVersionedRoute).toHaveBeenCalledWith(1, 'POST', '/items', expect.any(Function), expect.any(Object));
      expect(superOnInitializeSpy).toHaveBeenCalled();
      expect(inventoryModule.deps.logger.info).toHaveBeenCalledWith(expect.stringContaining('Initialized and routes defined for registration.'));
      
      superOnInitializeSpy.mockRestore();
    });
    
    test('onShutdown should unsubscribe event listeners and call super.onShutdown', async () => {
        const subIdToTest = 'test-sub-id-123';
        inventoryModule.subscriptions = [subIdToTest]; 
        inventoryModule.eventBus = mockEventBus; 
        const superSpy = jest.spyOn(RoutableModule.prototype, 'onShutdown').mockResolvedValue();

        await inventoryModule.onShutdown();

        expect(mockEventBus.unsubscribe).toHaveBeenCalledWith(subIdToTest);
        expect(inventoryModule.subscriptions).toEqual([]);
        expect(superSpy).toHaveBeenCalled();
        expect(inventoryModule.deps.logger.info).toHaveBeenCalledWith(expect.stringContaining('Shutdown complete.'));
    });
  });

  describe('Route Handlers', () => {
    let mockRequest;
    let mockReply;

    beforeEach(() => {
      mockRequest = {
        body: {},
        params: {},
        user: { id: 'testUser123' }, 
        url: '/test',
        method: 'POST'
      };
      mockReply = {
        code: jest.fn().mockReturnThis(),
        send: jest.fn().mockReturnThis(),
      };
      inventoryModule.handleError = jest.fn().mockResolvedValue(); // Spy on module's handleError
    });

    test('handleAddItem should add item and return 201 on success', async () => {
      const itemData = { sku: 'SKU100', name: 'New Gadget', quantity: 50, price: 199 };
      const createdItem = { id: 'itemGeneratedId001', ...itemData };
      mockRequest.body = itemData;
      mockDeps.inventoryService.addItem.mockResolvedValue(createdItem);
      inventoryModule.eventBus = mockEventBus; // Ensure eventBus for this.emit

      const result = await inventoryModule.handleAddItem(mockRequest, mockReply);

      expect(mockDeps.inventoryService.addItem).toHaveBeenCalledWith(itemData);
      expect(inventoryModule.eventBus.emit).toHaveBeenCalledWith(INVENTORY_EVENTS.ITEM_ADDED, {
        item: createdItem,
        byUser: 'testUser123',
      });
      expect(inventoryModule.state.metrics.get('inventorymodule.api.items_added').value).toBe(1);
      expect(mockReply.code).toHaveBeenCalledWith(201);
      expect(result).toEqual(createdItem); 
      expect(inventoryModule.handleError).not.toHaveBeenCalled();
    });

    test('handleAddItem should call handleError and throw on service failure', async () => {
      const itemData = { sku: 'SKU101', name: 'Faulty Gadget' };
      mockRequest.body = itemData;
      const serviceError = new InventoryError(InventoryErrorCodes.INVALID_SKU_FORMAT, "Service error");
      mockDeps.inventoryService.addItem.mockRejectedValue(serviceError);
      inventoryModule.eventBus = mockEventBus;

      await expect(inventoryModule.handleAddItem(mockRequest, mockReply)).rejects.toThrow(serviceError);

      expect(mockDeps.inventoryService.addItem).toHaveBeenCalledWith(itemData);
      expect(inventoryModule.handleError).toHaveBeenCalledWith(serviceError, {
        operation: 'handleAddItem',
        endpoint: `${mockRequest.method} ${mockRequest.url}`,
        requestBodySummary: Object.keys(itemData)
      });
      expect(inventoryModule.eventBus.emit).not.toHaveBeenCalledWith(INVENTORY_EVENTS.ITEM_ADDED, expect.anything());
      expect(mockReply.code).not.toHaveBeenCalled(); 
    });

    test('handleGetItem should return item on success', async () => {
        const sku = 'SKUEXIST';
        const item = { sku, name: 'Existing Item', quantity: 10, price: 50 };
        mockRequest.params = { sku };
        mockDeps.inventoryService.getItemBySku.mockResolvedValue(item);

        const result = await inventoryModule.handleGetItem(mockRequest, mockReply);

        expect(mockDeps.inventoryService.getItemBySku).toHaveBeenCalledWith(sku);
        expect(result).toEqual(item);
        expect(inventoryModule.handleError).not.toHaveBeenCalled();
    });

    test('handleGetItem should throw InventoryError if item not found', async () => {
        const sku = 'SKUNOTFOUND';
        mockRequest.params = { sku };
        mockDeps.inventoryService.getItemBySku.mockResolvedValue(null); 

        await expect(inventoryModule.handleGetItem(mockRequest, mockReply))
            .rejects.toThrow(InventoryError);
        
        try {
            // Calling again to inspect the thrown error instance properties
            await inventoryModule.handleGetItem(mockRequest, mockReply);
        } catch (e) {
            expect(e.code).toBe(`INVENTORY_${InventoryErrorCodes.ITEM_NOT_FOUND}`);
        }
        expect(inventoryModule.handleError).toHaveBeenCalledWith(expect.any(InventoryError), { operation: 'handleGetItem', sku });
    });
  });

  describe('Event Handlers', () => {
    test('handleOrderItemAllocated should update stock via service', async () => {
      const mockEvent = {
        id: 'event123',
        name: INVENTORY_EVENTS.ORDER_ITEM_ALLOCATED,
        data: { itemId: 'SKU789', quantityAllocated: 5 },
        timestamp: new Date().toISOString(),
        metadata: {},
      };
      mockDeps.inventoryService.updateStock.mockResolvedValue({ sku: 'SKU789', quantity: 95 }); 
      inventoryModule.handleError = jest.fn().mockResolvedValue(); // Spy for this test too

      await inventoryModule.handleOrderItemAllocated(mockEvent);

      expect(mockDeps.inventoryService.updateStock).toHaveBeenCalledWith('SKU789', -5);
      expect(inventoryModule.state.metrics.get('inventorymodule.event.order_item_allocated_handled').value).toBe(1);
      expect(inventoryModule.deps.logger.info).toHaveBeenCalledWith(expect.stringContaining('Received order.item.allocated for item SKU SKU789'));
      expect(inventoryModule.handleError).not.toHaveBeenCalled();
    });

    test('handleOrderItemAllocated should call handleError on service failure', async () => {
      const mockEvent = {
        id: 'event456',
        name: INVENTORY_EVENTS.ORDER_ITEM_ALLOCATED,
        data: { itemId: 'SKUFAIL', quantityAllocated: 2 },
      };
      const serviceError = new InventoryError(InventoryErrorCodes.INSUFFICIENT_STOCK, "Cannot allocate");
      mockDeps.inventoryService.updateStock.mockRejectedValue(serviceError);
      inventoryModule.handleError = jest.fn().mockResolvedValue(); // Spy

      await inventoryModule.handleOrderItemAllocated(mockEvent);

      expect(mockDeps.inventoryService.updateStock).toHaveBeenCalledWith('SKUFAIL', -2);
      expect(inventoryModule.handleError).toHaveBeenCalledWith(serviceError, expect.objectContaining({
        eventName: mockEvent.name,
        eventId: mockEvent.id,
        handler: 'handleOrderItemAllocated'
      }));
    });
  });
});
```

---
## 8. Shared Utilities Reference

The TSMIS core architecture includes foundational utilities in `src/core/common/`.

### 8.1. `SystemConstants.js`
#### 8.1.1. Purpose & Key Definitions
Defines shared, immutable constants for system-wide states (`SYSTEM_STATUS`), lifecycle event names (`LIFECYCLE_EVENTS`), and default configuration values (`DEFAULT_CONFIG`).

#### 8.1.2. Usage Example

**Example**:  Usage of SystemConstants.js

```javascript
// Example usage within a hypothetical core system component:
// import { SYSTEM_STATUS, LIFECYCLE_EVENTS, DEFAULT_CONFIG } from '../common/SystemConstants.js'; // Adjust path as needed

// class MySystem {
//   constructor(deps) {
//     this.deps = deps;
//     this.state = {
//       status: SYSTEM_STATUS.CREATED, // Using a constant for initial status
//       errors: [],
//       // ... other state properties
//     };
//     // Using a constant for a default configuration value
//     this.maxErrors = this.deps.config?.mySystem?.maxErrorHistory || DEFAULT_CONFIG.MAX_ERROR_HISTORY;
//   }

//   async initialize() {
//     if (this.state.status === SYSTEM_STATUS.RUNNING) return; // Comparing with a constant
//     this.state.status = SYSTEM_STATUS.INITIALIZING; // Setting status with a constant
//
//     // Emitting a standardized lifecycle event
//     // if (this.emit) { // Assuming 'this' is an EventEmitter
//     //   this.emit(LIFECYCLE_EVENTS.INITIALIZING, { system: this.constructor.name });
//     // }

//     // ... initialization logic ...

//     this.state.status = SYSTEM_STATUS.RUNNING;
//     // if (this.emit) {
//     //   this.emit(LIFECYCLE_EVENTS.INITIALIZED, { system: this.constructor.name });
//     //   this.emit(LIFECYCLE_EVENTS.RUNNING, { system: this.constructor.name });
//     // }
//   }

//   // ... other methods
// }
```

### 8.2. `ErrorUtils.js`
#### 8.2.1. Purpose & Key Functions
Provides `async safeHandleError(errorSystem, error, context)` for resilient error reporting to `ErrorSystem` (with console fallback), and `createStandardHealthCheckResult(status, detail, errors)` for uniform health check output.

#### 8.2.2. Usage Examples

**Example**: 

```javascript
// Example usage within a hypothetical core system or module:
// import { safeHandleError, createStandardHealthCheckResult } from '../common/ErrorUtils.js';
// import { SYSTEM_STATUS } from '../common/SystemConstants.js';
// import { CoreError } from '../errors/CoreError.js'; // Adjust path
// import { ErrorCodes } from '../errors/ErrorCodes.js'; // Adjust path


// class MyComponent {
//   constructor(deps) {
//     this.deps = deps; // Should include errorSystem, logger, etc.
//     this.state = { errors: [] }; // Simplified state for example
//   }

//   async _handleInternalError(error, context = {}) { // Example internal error handler
//       const internalError = !(error instanceof CoreError)
//         ? new CoreError(ErrorCodes.CORE.INTERNAL_ERROR, error.message, context, { cause: error })
//         : error;
//       this.state.errors.push({ error: internalError, timestamp: new Date().toISOString(), context });
//       // ... (error array capping logic) ...
//       // this.recordMetric('mycomponent.errors.internal', 1, { errorName: internalError.name });
//       await safeHandleError(this.deps.errorSystem, internalError, { source: this.constructor.name, ...context });
//   }


//   async checkMySpecificFeature() { // Example health check function
//     let isFeatureHealthy = true;
//     let featureDetails = { status: 'online', version: '1.2.3' };
//     let encounteredErrors = [];

//     try {
//       // if (await this.someDependency.isUnresponsive()) {
//       //   isFeatureHealthy = false;
//       //   featureDetails.status = 'dependency_issue';
//       //   encounteredErrors.push(new ServiceError(ErrorCodes.SERVICE.UNAVAILABLE, 'Dependency X is unresponsive.'));
//       // }
//     } catch (error) {
//       isFeatureHealthy = false;
//       featureDetails.error = error.message;
//       encounteredErrors.push(error);
//     }

//     return createStandardHealthCheckResult(
//       isFeatureHealthy ? SYSTEM_STATUS.HEALTHY : SYSTEM_STATUS.UNHEALTHY,
//       featureDetails,
//       encounteredErrors
//     );
//   }
// }
```

---
## 9. Conclusion & Future Directions

### 9.1. Summary of Achievements
The refactored TSMIS core architecture provides a robust, consistent, observable, and maintainable foundation by standardizing state management, error handling, lifecycles, health monitoring, and metrics across all core systems. This enhances developer experience and system stability.

### 9.2. Reinforcing the Standardization Pillars
Continued success depends on adhering to: Standard State, Standardized Error Handling, Standardized Lifecycle, Standardized Health Monitoring, Standardized Metrics Tracking, and Clear Naming Conventions.

### 9.3. Future Directions & Potential Enhancements
* **ContainerSystem**: Scoped containers, advanced/dynamic discovery, lazy initialization.
* **ErrorSystem**: Enhanced tracking/analytics, more framework integrations, third-party reporting.
* **EventBusSystem**: Advanced routing, schema validation/versioning, distributed bus, persistence.
* **ModuleSystem**: Advanced composition, dynamic management, inter-module contracts.
* **RouterSystem**: Advanced matching, dynamic routing, deeper validation integration.

This standardized foundation enables structured evolution and strategic incorporation of future enhancements for TSMIS.


// src/core/errors/CoreError.js

/**
 * @file CoreError.js
 * @description Universal base error class for the application.
 */

import { SYSTEM_STATUS } from '../common/SystemConstants.js'; // Optional: if used for env checks

export class CoreError extends Error {
  /**
   * Creates a new CoreError instance.
   * @param {string} code - A unique error code, typically UPPER_SNAKE_CASE.
   * @param {string} message - A human-readable description of the error.
   * @param {object} [details={}] - An object containing additional error-specific information.
   * @param {object} [options={}] - Additional options.
   * @param {Error} [options.cause] - The original error that caused this error.
   */
  constructor(code, message, details = {}, options = {}) {
    super(message); // Pass message to the native Error class

    // Standard error properties
    this.name = this.constructor.name; // E.g., "CoreError", "ValidationError"
    this.code = code; // E.g., "VALIDATION_FAILED"
    this.details = this.sanitizeDetails(details); // Ensure details are serializable
    this.timestamp = new Date().toISOString();

    // Store the original cause of the error, if provided
    if (options.cause) {
      this.initCause(options.cause);
    }

    // Improve stack trace (if supported by the environment)
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }

    // Standard V8 property to control stack trace formatting (optional)
    // Error.prepareStackTrace = (error, structuredStackTrace) => { /* custom formatting */ };

    // Ensure 'instanceof' works correctly after extending native Error
    Object.setPrototypeOf(this, new.target.prototype);
  }

  /**
   * Initializes the error cause, ensuring it's a proper Error instance.
   * @private
   * @param {Error|object|string} cause - The potential cause of the error.
   */
  initCause(cause) {
    const ensureValidName = (errorInstance) => {
      if (!errorInstance.name || !String(errorInstance.name).trim()) {
        errorInstance.name = 'Error'; // Default if name is missing or empty
      }
      return errorInstance;
    };

    if (cause instanceof Error) {
      this.cause = ensureValidName(cause); // [cite: 198]
    } else if (cause && typeof cause === 'object' && cause !== null) {
      const err = new Error(cause.message || JSON.stringify(cause)); // [cite: 199]
      if (cause.name && typeof cause.name === 'string' && cause.name.trim()) {
        err.name = cause.name; // [cite: 200]
      }
      if (cause.stack) {
        err.stack = cause.stack;
      }
      this.cause = err;
    } else if (typeof cause === 'string') {
      this.cause = new Error(cause); // [cite: 201]
    }
  }

  /**
   * Sanitizes error details to ensure they are serializable and prevent sensitive data leakage.
   * @private
   * @param {object} details - The original details object.
   * @returns {object} The sanitized details object.
   */
  sanitizeDetails(details) {
    if (typeof details !== 'object' || details === null) {
      return {};
    }
    try {
      // Attempt to serialize to catch non-serializable values like functions or complex objects
      JSON.stringify(details); // [cite: 202]
      // In a real application, you might want to filter out sensitive keys here
      return details;
    } catch (error) {
      // If serialization fails, return a safe representation
      return { // [cite: 203]
        error: 'Details contained non-serializable or circular values.',
        originalDetailsType: typeof details,
        safeDetailsRepresentation: String(details).substring(0, 256) // Truncate potentially large strings
      };
    }
  }

  /**
   * Determines if the current environment is considered 'development' or 'test'.
   * This can influence aspects like stack trace inclusion in toJSON().
   * @private
   * @returns {boolean}
   */
  isDevEnvironment() {
    if (typeof process !== 'undefined' && process.env) {
      return process.env.NODE_ENV === 'development' || process.env.NODE_ENV === 'test'; // [cite: 207]
    }
    // Basic client-side check (can be expanded)
    if (typeof window !== 'undefined') {
      // You might have a global ENV variable set during build
      return window.ENV === 'development' || window.location.hostname === 'localhost'; // [cite: 208]
    }
    return false; // Default to false if environment cannot be determined
  }

  /**
   * Converts the error object to a JSON representation.
   * Stack trace is typically included only in development environments.
   * @returns {object} A plain object representation of the error.
   */
  toJSON() {
    const jsonError = {
      name: this.name,
      code: this.code,
      message: this.message,
      details: this.details,
      timestamp: this.timestamp,
    }; // [cite: 209]

    if (this.cause) {
      jsonError.cause = {
        name: this.cause.name || 'Error', // [cite: 211]
        message: this.cause.message,
        // Optionally include code and details from the cause if they exist
        ...(this.cause.code && { code: this.cause.code }),
        ...(this.cause.details && { details: this.cause.details }),
      };
      if (this.isDevEnvironment() && this.cause.stack) {
        jsonError.cause.stack = this.cause.stack.split('\n'); // [cite: 212]
      }
    }

    if (this.isDevEnvironment() && this.stack) {
      jsonError.stack = this.stack.split('\n'); // [cite: 210]
    }

    return jsonError; // [cite: 213]
  }

  /**
   * Creates a CoreError (or a subclass) instance from a JSON-like object.
   * Useful for deserializing errors, e.g., from an API response.
   * @static
   * @param {object} data - The plain object containing error data.
   * @param {typeof CoreError} [ErrorType=CoreError] - The specific error class to instantiate. Defaults to CoreError.
   * @returns {CoreError} An instance of CoreError or its subclass.
   */
  static fromJSON(data, ErrorType = CoreError) {
    if (!data || typeof data !== 'object') {
      return new ErrorType(
        'DESERIALIZATION_FAILED',
        'Invalid data provided for error deserialization.',
        { providedData: data }
      );
    }

    const { code, message, details, cause: causeData, name } = data;
    const options = {};

    if (causeData) {
      if (typeof causeData === 'string') {
        options.cause = new Error(causeData); // [cite: 215]
      } else if (typeof causeData === 'object' && causeData !== null) {
        const reconstructedCause = new Error(causeData.message || 'Caused by an unspecified error.');
        reconstructedCause.name = causeData.name || 'Error'; // [cite: 216]
        if (causeData.code) reconstructedCause.code = causeData.code;
        // Note: Cause's own 'details' and 'stack' are not typically reconstructed deeply here
        // to avoid complexity, but could be if needed.
        options.cause = reconstructedCause;
      }
    }

    const errorInstance = new ErrorType(
      code || 'UNKNOWN_ERROR',
      message || 'An unspecified error occurred.',
      details || {},
      options
    ); // [cite: 217]

    // Restore original name if it was different (e.g. "ValidationError" from data)
    // and the ErrorType is the generic CoreError.
    if (name && ErrorType === CoreError && errorInstance.name !== name) {
        errorInstance.name = name;
    }

    return errorInstance;
  }
}


// src/core/errors/ErrorCodes.js

/**
 * @file ErrorCodes.js
 * @description Standardized error codes for the TSMIS application.
 */

export const ErrorCodes = Object.freeze({
  // --- Generic Core System Errors ---
  CORE: Object.freeze({
    UNKNOWN_ERROR: 'CORE_UNKNOWN_ERROR',
    INTERNAL_ERROR: 'CORE_INTERNAL_ERROR', // For unexpected internal issues
    INITIALIZATION_FAILED: 'CORE_INITIALIZATION_FAILED',
    ALREADY_INITIALIZED: 'CORE_ALREADY_INITIALIZED',
    NOT_INITIALIZED: 'CORE_NOT_INITIALIZED',
    SHUTDOWN_FAILED: 'CORE_SHUTDOWN_FAILED',
    VALIDATION_FAILED: 'CORE_VALIDATION_FAILED', // General validation failure
    INVALID_ARGUMENT: 'CORE_INVALID_ARGUMENT', // For invalid function/method arguments
    INVALID_OPERATION: 'CORE_INVALID_OPERATION', // Operation not allowed in current state
    INVALID_TYPE: 'CORE_INVALID_TYPE', // General type mismatch
    INVALID_HANDLER: 'CORE_INVALID_HANDLER', // Handler function is not valid
    INTEGRATION_FAILED: 'CORE_INTEGRATION_FAILED', // Generic failure with an external integration
    NOT_IMPLEMENTED: 'CORE_NOT_IMPLEMENTED', // Feature or method not implemented
    DEPRECATED: 'CORE_DEPRECATED', // Feature or method is deprecated
    RESOURCE_NOT_FOUND: 'CORE_RESOURCE_NOT_FOUND', // Generic resource not found
  }),

  // --- Configuration System Errors ---
  CONFIG: Object.freeze({
    LOAD_FAILED: 'CONFIG_LOAD_FAILED',
    SAVE_FAILED: 'CONFIG_SAVE_FAILED',
    VALIDATION_FAILED: 'CONFIG_VALIDATION_FAILED', // Specific to config validation
    MISSING_REQUIRED_FIELD: 'CONFIG_MISSING_REQUIRED_FIELD',
    INVALID_FIELD_TYPE: 'CONFIG_INVALID_FIELD_TYPE',
    INVALID_ENUM_VALUE: 'CONFIG_INVALID_ENUM_VALUE',
    PATTERN_MISMATCH: 'CONFIG_PATTERN_MISMATCH',
    INVALID_CONFIG_OBJECT: 'CONFIG_INVALID_CONFIG_OBJECT', // If config itself is not an object
    DUPLICATE_MANIFEST: 'CONFIG_DUPLICATE_MANIFEST', // Container specific
    DUPLICATE_COMPONENT: 'CONFIG_DUPLICATE_COMPONENT', // Container specific
    MISSING_DEPENDENCY: 'CONFIG_MISSING_DEPENDENCY', // Container specific: component dependency
    CIRCULAR_DEPENDENCY: 'CONFIG_CIRCULAR_DEPENDENCY', // Container specific
    MANIFEST_TYPE_NOT_FOUND: 'CONFIG_MANIFEST_TYPE_NOT_FOUND', // Container specific
  }),

  // --- Service & Component Errors (e.g., Container-managed services) ---
  SERVICE: Object.freeze({
    UNKNOWN_COMPONENT: 'SERVICE_UNKNOWN_COMPONENT', // Container specific
    COMPONENT_LOAD_FAILED: 'SERVICE_COMPONENT_LOAD_FAILED', // Container specific
    IMPLEMENTATION_LOAD_FAILED: 'SERVICE_IMPLEMENTATION_LOAD_FAILED', // Container specific
    DISCOVERY_FAILED: 'SERVICE_DISCOVERY_FAILED', // Container specific
    DIRECTORY_SCAN_FAILED: 'SERVICE_DIRECTORY_SCAN_FAILED', // Container specific
    OPERATION_FAILED: 'SERVICE_OPERATION_FAILED', // Generic service operation failure
    EXTERNAL_API_ERROR: 'SERVICE_EXTERNAL_API_ERROR',
    DATABASE_ERROR: 'SERVICE_DATABASE_ERROR',
    CACHE_ERROR: 'SERVICE_CACHE_ERROR',
    UNAVAILABLE: 'SERVICE_UNAVAILABLE', // Service is not available
  }),

  // --- Event System Errors ---
  EVENT: Object.freeze({
    INTERNAL_ERROR: 'EVENT_INTERNAL_ERROR',
    INITIALIZATION_FAILED: 'EVENT_INITIALIZATION_FAILED', // Specific to Event system
    ALREADY_INITIALIZED: 'EVENT_ALREADY_INITIALIZED', // Specific to Event system
    NOT_INITIALIZED: 'EVENT_NOT_INITIALIZED', // Specific to Event system
    SHUTDOWN_FAILED: 'EVENT_SHUTDOWN_FAILED', // Specific to Event system
    MISSING_DEPENDENCIES: 'EVENT_MISSING_DEPENDENCIES', // For EventBus/System deps
    INVALID_DEPENDENCY: 'EVENT_INVALID_DEPENDENCY', // For EventBus/System deps
    INVALID_EVENT_NAME: 'EVENT_INVALID_EVENT_NAME',
    INVALID_HANDLER: 'EVENT_INVALID_HANDLER', // Handler function validation
    INVALID_PATTERN: 'EVENT_INVALID_PATTERN', // Subscription pattern validation
    EMISSION_FAILED: 'EVENT_EMISSION_FAILED',
    SUBSCRIPTION_FAILED: 'EVENT_SUBSCRIPTION_FAILED',
    HANDLER_NOT_FOUND: 'EVENT_HANDLER_NOT_FOUND', // For unsubscribe if ID not found
    HANDLER_ERROR: 'EVENT_HANDLER_ERROR', // Error *thrown by* an event handler
    QUEUE_OPERATION_FAILED: 'EVENT_QUEUE_OPERATION_FAILED', // Generic queue add/remove issue
    QUEUE_PROCESSING_FAILED: 'EVENT_QUEUE_PROCESSING_FAILED', // Error during processQueue
    LEGACY_WILDCARD_FORWARD: 'EVENT_LEGACY_WILDCARD_FORWARD', // Specific internal diagnostic
  }),

  // --- Module System Errors ---
  MODULE: Object.freeze({
    INTERNAL_ERROR: 'MODULE_INTERNAL_ERROR', // CoreModule internal
    SYSTEM_ERROR: 'MODULE_SYSTEM_ERROR', // ModuleSystem internal
    INITIALIZATION_FAILED: 'MODULE_INITIALIZATION_FAILED', // Specific to Module system/instance
    ALREADY_INITIALIZED: 'MODULE_ALREADY_INITIALIZED', // Specific to Module system/instance
    NOT_INITIALIZED: 'MODULE_NOT_INITIALIZED', // Specific to Module system/instance
    SHUTDOWN_FAILED: 'MODULE_SHUTDOWN_FAILED', // Specific to Module system/instance
    MISSING_DEPENDENCIES: 'MODULE_MISSING_DEPENDENCIES', // For Module deps
    INVALID_DEPENDENCY: 'MODULE_INVALID_DEPENDENCY', // For Module deps
    DEPENDENCY_NOT_READY: 'MODULE_DEPENDENCY_NOT_READY',
    CONFIG_VALIDATION_FAILED: 'MODULE_CONFIG_VALIDATION_FAILED',
    INVALID_HEALTH_CHECK: 'MODULE_INVALID_HEALTH_CHECK',
    HEALTH_CHECK_FAILED: 'MODULE_HEALTH_CHECK_FAILED', // Error *executing* a health check
    UNHEALTHY: 'MODULE_UNHEALTHY', // Module reported unhealthy status
    OPERATION_FAILED: 'MODULE_OPERATION_FAILED', // Generic failure in a module's business logic
    DUPLICATE_MODULE: 'MODULE_DUPLICATE_MODULE', // ModuleSystem: registration
    REGISTRATION_FAILED: 'MODULE_REGISTRATION_FAILED', // ModuleSystem: registration
    UNREGISTER_FAILED: 'MODULE_UNREGISTER_FAILED', // ModuleSystem: unregistration
    NOT_FOUND: 'MODULE_NOT_FOUND', // ModuleSystem: resolve
    CIRCULAR_DEPENDENCY: 'MODULE_CIRCULAR_DEPENDENCY', // ModuleSystem: dependency order
  }),

  // --- Router System Errors ---
  ROUTER: Object.freeze({
    SYSTEM_INTERNAL_ERROR: 'ROUTER_SYSTEM_INTERNAL_ERROR', // RouterSystem internal
    INTERNAL_SYSTEM_ERROR: 'ROUTER_CORE_INTERNAL_ERROR', // CoreRouter internal (distinguish if needed)
    INITIALIZATION_FAILED: 'ROUTER_INITIALIZATION_FAILED', // Specific to Router system/instance
    ALREADY_INITIALIZED: 'ROUTER_ALREADY_INITIALIZED', // Specific to Router system/instance
    NOT_INITIALIZED: 'ROUTER_NOT_INITIALIZED', // Specific to Router system/instance
    SHUTDOWN_FAILED: 'ROUTER_SHUTDOWN_FAILED', // Specific to Router system/instance
    CREATION_FAILED: 'ROUTER_CREATION_FAILED', // For factory function issues
    MISSING_DEPENDENCIES: 'ROUTER_MISSING_DEPENDENCIES',
    INVALID_DEPENDENCY: 'ROUTER_INVALID_DEPENDENCY',
    INVALID_MODULE_ID: 'ROUTER_INVALID_MODULE_ID',
    INVALID_METHOD: 'ROUTER_INVALID_METHOD',
    INVALID_PATH: 'ROUTER_INVALID_PATH',
    INVALID_HANDLER: 'ROUTER_INVALID_HANDLER', // Handler function for a route
    INVALID_PAYLOAD: 'ROUTER_INVALID_PAYLOAD', // e.g. event payload missing data
    INVALID_API_VERSION: 'ROUTER_INVALID_API_VERSION',
    ROUTE_CONFLICT: 'ROUTER_ROUTE_CONFLICT',
    ROUTE_REGISTRATION_FAILED: 'ROUTER_ROUTE_REGISTRATION_FAILED',
    ROUTE_UNREGISTRATION_FAILED: 'ROUTER_ROUTE_UNREGISTRATION_FAILED',
    MODULE_UNREGISTRATION_FAILED: 'ROUTER_MODULE_UNREGISTRATION_FAILED',
    ROUTES_APPLICATION_FAILED: 'ROUTER_ROUTES_APPLICATION_FAILED',
    ADAPTER_NOT_FOUND: 'ROUTER_ADAPTER_NOT_FOUND',
    INVALID_ADAPTER: 'ROUTER_INVALID_ADAPTER',
    INVALID_ADAPTER_NAME: 'ROUTER_INVALID_ADAPTER_NAME',
    INVALID_MIDDLEWARE: 'ROUTER_INVALID_MIDDLEWARE',
    INVALID_MIDDLEWARE_NAME: 'ROUTER_INVALID_MIDDLEWARE_NAME',
    INVALID_HEALTH_CHECK: 'ROUTER_INVALID_HEALTH_CHECK', // If router system has own health checks
  }),

  // --- Specific Error Type Codes (used by respective Error classes) ---
  VALIDATION: Object.freeze({ // Used by ValidationError
    INVALID_INPUT: 'VALIDATION_INVALID_INPUT',
    SCHEMA_MISMATCH: 'VALIDATION_SCHEMA_MISMATCH', // More specific than CONFIG_VALIDATION_FAILED
    REQUIRED_FIELD: 'VALIDATION_REQUIRED_FIELD', // More specific than CONFIG_MISSING_REQUIRED_FIELD
    TYPE_ERROR: 'VALIDATION_TYPE_ERROR', // More specific than CONFIG_INVALID_FIELD_TYPE
    ENUM_MISMATCH: 'VALIDATION_ENUM_MISMATCH', // More specific than CONFIG_INVALID_ENUM_VALUE
    PATTERN_ERROR: 'VALIDATION_PATTERN_ERROR', // More specific than CONFIG_PATTERN_MISMATCH
    CUSTOM_VALIDATION_FAILED: 'VALIDATION_CUSTOM_VALIDATION_FAILED',
    // Codes from original ErrorSystem docs & errors/index.js [cite: 331] can be adapted here
    // SCHEMA: 'SCHEMA_VALIDATION_FAILED',
    // TYPE: 'INVALID_TYPE',
    // REQUIRED: 'REQUIRED_FIELD_MISSING',
    FAILED: 'VALIDATION_FAILED', // General catch-all for validation if not more specific
  }),

  NETWORK: Object.freeze({ // Used by NetworkError
    REQUEST_FAILED: 'NETWORK_REQUEST_FAILED',
    RESPONSE_ERROR: 'NETWORK_RESPONSE_ERROR', // Error parsing response or bad status code from remote
    TIMEOUT: 'NETWORK_TIMEOUT', // Or REQUEST_TIMEOUT
    CONNECTION_REFUSED: 'NETWORK_CONNECTION_REFUSED',
    HOST_UNREACHABLE: 'NETWORK_HOST_UNREACHABLE',
    DNS_LOOKUP_FAILED: 'NETWORK_DNS_LOOKUP_FAILED',
    SSL_ERROR: 'NETWORK_SSL_ERROR',
    ROUTE_NOT_FOUND: 'NETWORK_ROUTE_NOT_FOUND', // For 404s, distinct from ROUTER.ROUTE_NOT_FOUND (internal)
  }),

  AUTH: Object.freeze({ // Used by AuthError (Authentication)
    UNAUTHORIZED: 'AUTH_UNAUTHORIZED', // General, or for when reason is unknown
    INVALID_CREDENTIALS: 'AUTH_INVALID_CREDENTIALS',
    TOKEN_EXPIRED: 'AUTH_TOKEN_EXPIRED',
    TOKEN_INVALID: 'AUTH_TOKEN_INVALID', // Malformed, wrong signature etc.
    TOKEN_MISSING: 'AUTH_TOKEN_MISSING',
    ACCOUNT_LOCKED: 'AUTH_ACCOUNT_LOCKED',
    ACCOUNT_DISABLED: 'AUTH_ACCOUNT_DISABLED',
    MFA_REQUIRED: 'AUTH_MFA_REQUIRED',
    MFA_FAILED: 'AUTH_MFA_FAILED',
  }),

  ACCESS: Object.freeze({ // Used by AccessError (Authorization)
    FORBIDDEN: 'ACCESS_FORBIDDEN', // General access denied
    INSUFFICIENT_PERMISSIONS: 'ACCESS_INSUFFICIENT_PERMISSIONS',
    RESOURCE_OWNERSHIP_REQUIRED: 'ACCESS_RESOURCE_OWNERSHIP_REQUIRED',
    RATE_LIMIT_EXCEEDED: 'ACCESS_RATE_LIMIT_EXCEEDED',
    FEATURE_NOT_ENABLED: 'ACCESS_FEATURE_NOT_ENABLED', // For user/tenant
    // Codes from original ErrorSystem docs & errors/index.js
    // INSUFFICIENT_RIGHTS: 'INSUFFICIENT_RIGHTS', // Covered by INSUFFICIENT_PERMISSIONS
    // RESOURCE_ACCESS_DENIED: 'RESOURCE_ACCESS_DENIED', // Covered by FORBIDDEN
  }),
});


// src/core/errors/ErrorSystem.js

/**
 * @file ErrorSystem.js
 * @description Manages error types, framework integrations, and centralized error handling.
 */

import { EventEmitter } from 'events';
import { CoreError } from './CoreError.js';
import * as ErrorTypes from './types/index.js'; // Assuming types/index.js exports all named error types
import { ErrorCodes } from './ErrorCodes.js'; // Assuming ErrorCodes are in their own file
import { FastifyErrorHandler } from './integrations/fastify/FastifyErrorHandler.js'; // Adjusted import
import { SYSTEM_STATUS, LIFECYCLE_EVENTS, DEFAULT_CONFIG } from '../common/SystemConstants.js';
import { safeHandleError, createStandardHealthCheckResult } from '../common/ErrorUtils.js';

export class ErrorSystem extends EventEmitter {
  static dependencies = ['logger', 'config']; // config might be used for maxErrorHistory etc.
  static version = '2.0.0'; // Example version bump

  /**
   * Creates a new ErrorSystem instance.
   * @param {object} [deps={}] - Dependencies for the ErrorSystem.
   * @param {object} [deps.logger=console] - Logger instance.
   * @param {object} [deps.config={}] - Configuration object.
   */
  constructor(deps = {}) {
    super();
    this.deps = {
      logger: deps.logger || console,
      config: deps.config || {},
      // ErrorSystem does not depend on itself for safeHandleError
    };

    this.errorTypes = new Map(Object.entries(ErrorTypes));
    this.customHandlers = new Map(); // Renamed from 'handlers' to be more specific
    this.integrations = new Map();
    this.initialized = false; // Will be driven by state.status

    this.state = {
      status: SYSTEM_STATUS.CREATED,
      startTime: null,
      errors: [], // For internal errors of ErrorSystem
      metrics: new Map(),
      healthChecks: new Map(),
    };

    // Ensure a default handler is always present for unhandled CoreErrors
    this.registerHandler(CoreError.name, this.defaultCoreErrorHandler.bind(this)); // More specific default
    this.registerHealthCheck('errorsystem.state', this.checkSystemState.bind(this));
    this.registerHealthCheck('errorsystem.handlers', this.checkHandlerStatus.bind(this));
    this.registerHealthCheck('errorsystem.integrations', this.checkIntegrationStatus.bind(this));
  }

  /**
   * Initializes the ErrorSystem.
   * Validates error types and sets up the system.
   * @returns {Promise<ErrorSystem>}
   */
  async initialize() {
    if (this.state.status === SYSTEM_STATUS.RUNNING || this.state.status === SYSTEM_STATUS.INITIALIZING) {
      // Use internal handler for this operational error
      const err = new CoreError(
        ErrorCodes.CORE.ALREADY_INITIALIZED, // Assuming such a code exists or is added
        'ErrorSystem is already initialized or initializing.'
      );
      await this._handleInternalError(err, { currentStatus: this.state.status });
      return this; // Or throw err if preferred
    }

    this.emit(LIFECYCLE_EVENTS.INITIALIZING, { system: 'ErrorSystem' });
    this.state.status = SYSTEM_STATUS.INITIALIZING;
    this.state.startTime = Date.now();

    try {
      // Validate registered error types
      for (const [name, ErrorTypeClass] of this.errorTypes) {
        if (!(ErrorTypeClass.prototype instanceof CoreError)) {
          throw new CoreError(
            ErrorCodes.CORE.INVALID_TYPE, // Assuming a general invalid type code
            `Registered error type '${name}' must extend CoreError.`
          );
        }
      }

      // Potentially initialize default integrations if specified in config
      // Example: if (this.deps.config.errorSystem?.defaultIntegration === 'fastify') { ... }

      this.initialized = true; // Redundant with state.status but kept for current compatibility
      this.state.status = SYSTEM_STATUS.RUNNING;
      this.recordMetric('errorsystem.initialized.success', 1, { timestamp: Date.now() });
      this.emit(LIFECYCLE_EVENTS.INITIALIZED, { system: 'ErrorSystem', timestamp: new Date().toISOString() });
      this.emit(LIFECYCLE_EVENTS.RUNNING, { system: 'ErrorSystem', timestamp: new Date().toISOString() });


    } catch (error) {
      this.state.status = SYSTEM_STATUS.ERROR;
      this.recordMetric('errorsystem.initialized.failure', 1, { error: error.code, timestamp: Date.now() });
      await this._handleInternalError(error, { phase: 'initialization' });
      // Re-throw to signal catastrophic failure of ErrorSystem initialization
      throw error instanceof CoreError ? error : new CoreError(
        ErrorCodes.CORE.INITIALIZATION_FAILED,
        'ErrorSystem failed to initialize.',
        { originalMessage: error.message },
        { cause: error }
      );
    }
    return this;
  }

  /**
   * Registers a specific error handler for a given error type name.
   * @param {string} errorTypeName - The name of the error class (e.g., 'ValidationError', 'CoreError').
   * @param {Function} handler - The async function to handle the error: async (error, context) => {}.
   */
  registerHandler(errorTypeName, handler) {
    if (typeof handler !== 'function') {
      const err = new CoreError(ErrorCodes.CORE.INVALID_HANDLER, 'Error handler must be a function.', { errorTypeName }); //
      this._handleInternalError(err); // Log internal error
      throw err; // Throw for immediate feedback
    }
    if (typeof errorTypeName !== 'string' || !errorTypeName.trim()) {
        const err = new CoreError(ErrorCodes.CORE.INVALID_TYPE, 'Error type name must be a non-empty string.', { handlerName: handler.name });
        this._handleInternalError(err);
        throw err;
    }
    this.customHandlers.set(errorTypeName, handler);
    this.recordMetric('errorsystem.handlers.registered', 1, { errorTypeName });
  }

  /**
   * Registers and initializes a framework integration.
   * @param {string} integrationName - A name for the integration (e.g., 'fastify').
   * @param {IFrameworkIntegration} IntegrationClass - The class for the framework integration (e.g., FastifyErrorHandler).
   * @param {object} frameworkInstance - The instance of the web framework (e.g., Fastify app).
   * @param {object} [options={}] - Options to pass to the integration's initialize method.
   * @returns {Promise<object>} The initialized integration instance.
   */
  async registerIntegration(integrationName, IntegrationClass, frameworkInstance, options = {}) {
    if (!integrationName || typeof integrationName !== 'string') {
        const err = new CoreError(ErrorCodes.CORE.INVALID_ARGUMENT, 'Integration name must be a non-empty string.');
        await this._handleInternalError(err);
        throw err;
    }
    if (!IntegrationClass || typeof IntegrationClass !== 'function' || !IntegrationClass.prototype || typeof IntegrationClass.prototype.initialize !== 'function') {
        const err = new CoreError(ErrorCodes.CORE.INVALID_ARGUMENT, `IntegrationClass for '${integrationName}' is invalid or does not have an initialize method.`);
        await this._handleInternalError(err);
        throw err;
    }
     if (!frameworkInstance) {
        const err = new CoreError(ErrorCodes.CORE.INVALID_ARGUMENT, `Framework instance for '${integrationName}' is required.`);
        await this._handleInternalError(err);
        throw err;
    }

    try {
      const integration = new IntegrationClass(this); // Pass ErrorSystem instance if needed by integration
      await integration.initialize(frameworkInstance, options); // Ensure initialize is async if it does async work
      this.integrations.set(integrationName, integration);
      this.recordMetric('errorsystem.integrations.registered', 1, { integrationName });
      return integration;
    } catch (error) {
      const err = new CoreError(
          ErrorCodes.CORE.INTEGRATION_FAILED, // Assuming such code exists
          `Failed to register or initialize integration '${integrationName}'.`,
          { integrationName, originalMessage: error.message },
          { cause: error }
      );
      await this._handleInternalError(err);
      throw err;
    }
  }


  /**
   * Handles an error by finding the appropriate registered handler or using the default.
   * @param {Error} error - The error object. Must be an instance of CoreError or its subclass.
   * @param {object} [context={}] - Additional context about where/how the error occurred.
   */
  async handleError(error, context = {}) {
    this.recordMetric('errorsystem.errors.received', 1, { errorName: error.name, errorCode: error.code });

    // Ensure the error is a CoreError or subclass, or wrap it.
    let processedError = error;
    if (!(error instanceof CoreError)) {
      this.deps.logger.warn('[ErrorSystem] Received non-CoreError. Wrapping it:', { originalError: error, context });
      processedError = new CoreError(
        ErrorCodes.CORE.UNKNOWN, //
        error.message || 'An unknown error occurred.',
        { originalErrorName: error.name, context },
        { cause: error }
      );
    }

    // Find the most specific handler
    let handler = this.customHandlers.get(processedError.constructor.name) ||
                  this.customHandlers.get(CoreError.name); // Fallback to default CoreError handler

    if (!handler) {
        // This should ideally not happen if CoreError.name handler is always registered
        this.deps.logger.error('[ErrorSystem] No default CoreError handler found. Logging directly.', {
            error: processedError.toJSON(), // Use toJSON for structured logging
            context
        });
        this.emit('error:unhandled', { error: processedError, context }); //
        return;
    }

    try {
      await handler(processedError, context);
      this.emit('error:handled', { error: processedError, context, handler: handler.name }); //
    } catch (handlerError) {
      this.deps.logger.error('[ErrorSystem] Error handler itself failed:', {
        handlerName: handler.name,
        originalError: processedError.toJSON(),
        handlerError: (handlerError instanceof CoreError) ? handlerError.toJSON() : { message: handlerError.message, name: handlerError.name },
        context
      });
      this.emit('error:handler_failed', { error: handlerError, originalError: processedError, context }); //
      // Decide if handlerError should be re-thrown or if ErrorSystem absorbs it
    }
  }

  /**
   * Default handler for CoreError instances if no more specific handler is found.
   * @private
   */
  defaultCoreErrorHandler(error, context = {}) {
    this.deps.logger.error(`[ErrorSystem DefaultHandler] Unhandled CoreError:`, {
      error: error.toJSON(), // Use toJSON for structured logging
      context,
      timestamp: new Date().toISOString()
    });
  }

  /**
   * Creates an instance of a registered error type.
   * @param {string} typeName - The name of the error type (e.g., 'ValidationError').
   * @param {string} code - The specific error code.
   * @param {string} message - The error message.
   * @param {object} [details={}] - Additional error details.
   * @param {object} [options={}] - Error options, including 'cause'.
   * @returns {CoreError} An instance of the specified error type, or CoreError if type not found.
   */
  createError(typeName, code, message, details = {}, options = {}) {
    const ErrorTypeClass = this.errorTypes.get(typeName) || CoreError;
    // If ErrorTypeClass is CoreError itself and typeName was different, it means the specific type wasn't found.
    // The 'code' for specific errors usually doesn't include the prefix (e.g., just 'INVALID_INPUT' for ValidationError).
    // The prefix is added by the subclass constructor.
    if (ErrorTypeClass === CoreError && typeName !== CoreError.name) {
        this.deps.logger.warn(`[ErrorSystem] createError: Type '${typeName}' not found, defaulting to CoreError. Code: ${code}`);
    }
    return new ErrorTypeClass(code, message, details, options);
  }

  /**
   * Gracefully shuts down the ErrorSystem.
   * @returns {Promise<void>}
   */
  async shutdown() {
    if (this.state.status === SYSTEM_STATUS.SHUTDOWN || this.state.status === SYSTEM_STATUS.SHUTTING_DOWN) {
      return;
    }
    this.emit(LIFECYCLE_EVENTS.SHUTTING_DOWN, { system: 'ErrorSystem' });
    this.state.status = SYSTEM_STATUS.SHUTTING_DOWN;

    try {
      // Perform any cleanup for integrations if they have a shutdown method
      for (const [name, integration] of this.integrations) {
        if (typeof integration.shutdown === 'function') {
          await integration.shutdown();
        }
      }
      this.integrations.clear();
      this.customHandlers.clear();
      // this.errorTypes.clear(); // Usually, error type definitions are static and don't need clearing

      this.removeAllListeners(); // Clear all event listeners for this ErrorSystem instance

      this.initialized = false;
      this.state.status = SYSTEM_STATUS.SHUTDOWN;
      this.recordMetric('errorsystem.shutdown.success', 1, { timestamp: Date.now() });
      // Cannot emit shutdown if all listeners are removed, log instead or emit before removeAllListeners
      this.deps.logger.info('[ErrorSystem] Shutdown complete.');
      // If you want to emit a shutdown event, do it before removeAllListeners()
      // this.emit(LIFECYCLE_EVENTS.SHUTDOWN, { system: 'ErrorSystem', timestamp: new Date().toISOString() });


    } catch (error) {
      this.state.status = SYSTEM_STATUS.ERROR;
      this.recordMetric('errorsystem.shutdown.failure', 1, { error: error.code, timestamp: Date.now() });
      // Use console.error directly as _handleInternalError might try to use parts of a shutdown system
      console.error('[ErrorSystem] Shutdown failed:', error);
      // Do not re-throw during shutdown of ErrorSystem itself unless absolutely necessary
    }
  }

  // --- State, Health, Metrics ---
  /**
   * Handles internal operational errors of the ErrorSystem.
   * @private
   */
  async _handleInternalError(error, context = {}) {
    const internalError = !(error instanceof CoreError) ? new CoreError(ErrorCodes.CORE.INTERNAL, error.message, context, { cause: error }) : error;

    this.state.errors.push({ error: internalError, timestamp: new Date().toISOString(), context });
    if (this.state.errors.length > (this.deps.config?.maxErrorHistory || DEFAULT_CONFIG.MAX_ERROR_HISTORY)) {
      this.state.errors.shift();
    }
    // Log directly to prevent loops if ErrorSystem.handleError is itself broken
    this.deps.logger.error('[ErrorSystem Internal]', internalError.toJSON());
  }

  recordMetric(name, value, tags = {}) {
    this.state.metrics.set(name, { value, timestamp: Date.now(), tags });
  }

  getMetrics() {
    const metrics = {};
    for (const [name, data] of this.state.metrics) {
      metrics[name] = data;
    }
    return metrics;
  }

  registerHealthCheck(name, checkFn) {
    if (typeof checkFn !== 'function') {
        const err = new CoreError(ErrorCodes.CORE.INVALID_HANDLER, `Health check '${name}' must be a function.`);
        this._handleInternalError(err);
        throw err;
    }
    this.state.healthChecks.set(name, checkFn);
  }

  async checkHealth() {
    const results = {};
    let overallStatus = SYSTEM_STATUS.HEALTHY;

    for (const [name, checkFn] of this.state.healthChecks) {
      try {
        const checkResult = await checkFn(); // Expects { status, detail, errors }
        results[name] = checkResult;
        if (checkResult.status !== SYSTEM_STATUS.HEALTHY) {
          // If any check is unhealthy, the system might be degraded or unhealthy
          overallStatus = (overallStatus === SYSTEM_STATUS.HEALTHY) ? SYSTEM_STATUS.DEGRADED : SYSTEM_STATUS.UNHEALTHY;
          if (checkResult.status === SYSTEM_STATUS.UNHEALTHY) overallStatus = SYSTEM_STATUS.UNHEALTHY;
        }
      } catch (error) {
        results[name] = createStandardHealthCheckResult(SYSTEM_STATUS.UNHEALTHY, { error: 'Health check threw an exception' }, [error]);
        overallStatus = SYSTEM_STATUS.UNHEALTHY;
      }
    }

    return {
      name: this.constructor.name,
      version: ErrorSystem.version,
      status: overallStatus,
      timestamp: new Date().toISOString(),
      uptime: this.state.startTime ? Date.now() - this.state.startTime : 0,
      errorCount: this.state.errors.length,
      checks: results,
    };
  }

  async checkSystemState() {
    return createStandardHealthCheckResult(
      this.state.status === SYSTEM_STATUS.RUNNING ? SYSTEM_STATUS.HEALTHY : SYSTEM_STATUS.UNHEALTHY,
      {
        status: this.state.status,
        uptime: this.state.startTime ? Date.now() - this.state.startTime : 0,
        internalErrorCount: this.state.errors.length
      }
    );
  }

  async checkHandlerStatus() {
    return createStandardHealthCheckResult(SYSTEM_STATUS.HEALTHY, {
      customHandlerCount: this.customHandlers.size,
      registeredHandlerKeys: Array.from(this.customHandlers.keys())
    });
  }

  async checkIntegrationStatus() {
    const integrationDetails = {};
    let allIntegrationsHealthy = true;
    for (const [name, integration] of this.integrations) {
        if (typeof integration.checkHealth === 'function') {
            try {
                const iHealth = await integration.checkHealth();
                integrationDetails[name] = iHealth;
                if (iHealth.status !== SYSTEM_STATUS.HEALTHY) allIntegrationsHealthy = false;
            } catch (e) {
                integrationDetails[name] = createStandardHealthCheckResult(SYSTEM_STATUS.UNHEALTHY, { error: 'Integration health check failed' }, [e]);
                allIntegrationsHealthy = false;
            }
        } else {
            integrationDetails[name] = createStandardHealthCheckResult(SYSTEM_STATUS.HEALTHY, { status: 'No health check available' });
        }
    }
    return createStandardHealthCheckResult(
      allIntegrationsHealthy ? SYSTEM_STATUS.HEALTHY : SYSTEM_STATUS.DEGRADED,
      {
        integrationCount: this.integrations.size,
        registeredIntegrationKeys: Array.from(this.integrations.keys()),
        details: integrationDetails
      }
    );
  }

  getSystemStatus() { // For consistency with other systems if they have this
    return {
        name: this.constructor.name,
        version: ErrorSystem.version,
        status: this.state.status,
        uptime: this.state.startTime ? Date.now() - this.state.startTime : 0,
        initialized: this.state.status === SYSTEM_STATUS.RUNNING,
        errorCount: this.state.errors.length,
        timestamp: new Date().toISOString()
    };
  }
}

/**
 * Factory function for creating an ErrorSystem instance.
 * @param {object} [deps={}] - Dependencies for the ErrorSystem.
 * @returns {ErrorSystem}
 */
export function createErrorSystem(deps = {}) {
  return new ErrorSystem(deps);
}


// src/core/errors/error-system.md

# TSMIS Error Handling System Documentation
Version: 2.0.0 (Refactored Core)

## Table of Contents

1.  [Introduction to the Error Handling System](#1-introduction-to-the-error-handling-system)
    * [1.1. Purpose & Philosophy](#11-purpose--philosophy)
    * [1.2. Key Components & Their Roles](#12-key-components--their-roles)
    * [1.3. Core Dependencies (System-Wide)](#13-core-dependencies-system-wide)
    * [1.4. Architectural Flow](#14-architectural-flow)
2.  [Component: `CoreError.js` - The Foundational Error Class](#2-component-coreerrorjs---the-foundational-error-class)
    * [2.1. Overview](#21-overview)
    * [2.2. Purpose & Key Features](#22-purpose--key-features)
    * [2.3. API Reference (`CoreError`)](#23-api-reference-coreerror)
        * [2.3.1. Constructor](#231-constructor)
        * [2.3.2. Instance Properties](#232-instance-properties)
        * [2.3.3. Instance Methods](#233-instance-methods)
        * [2.3.4. Static Methods](#234-static-methods)
    * [2.4. State Management](#24-state-management)
    * [2.5. Lifecycle Management](#25-lifecycle-management)
    * [2.6. Error Handling (Usage Context)](#26-error-handling-usage-context)
    * [2.7. Event Integration](#27-event-integration)
    * [2.8. Health Monitoring](#28-health-monitoring)
    * [2.9. Metrics Tracking](#29-metrics-tracking)
    * [2.10. Integrations (How CoreError is Used)](#210-integrations-how-coreerror-is-used)
    * [2.11. Usage Examples & Best Practices](#211-usage-examples--best-practices)
    * [2.12. Testing Strategy Notes](#212-testing-strategy-notes)
3.  [Component: Specialized Error Types (`src/core/errors/types/`)](#3-component-specialized-error-types-srccoreerrorstypes)
    * [3.1. Overview and Purpose](#31-overview-and-purpose)
    * [3.2. Common Pattern & Extension of `CoreError`](#32-common-pattern--extension-of-coreerror)
    * [3.3. Key Individual Error Types (Brief Descriptions & Purpose)](#33-key-individual-error-types-brief-descriptions--purpose)
        * [`AccessError.js`](#accesserrorjs)
        * [`AuthError.js`](#autherrorjs)
        * [`ConfigError.js`](#configerrorjs)
        * [`EventError.js`](#eventerrorjs)
        * [`ModuleError.js`](#moduleerrorjs)
        * [`NetworkError.js`](#networkerrorjs)
        * [`RouterError.js`](#routererrorjs)
        * [`ServiceError.js`](#serviceerrorjs)
        * [`ValidationError.js`](#validationerrorjs)
4.  [Component: Standardized Error Codes (`ErrorCodes.js`)](#4-component-standardized-error-codes-errorcodesjs)
    * [4.1. Overview & Purpose](#41-overview--purpose)
    * [4.2. Structure and Naming Convention](#42-structure-and-naming-convention)
    * [4.3. Usage Guidelines](#43-usage-guidelines)
    * [4.4. Integration with `CoreError` and `ErrorSystem`](#44-integration-with-coreerror-and-errorsystem)
5.  [Component: Central Management (`ErrorSystem.js`)](#5-component-central-management-errorsystemjs)
    * [5.1. Overview & Primary Responsibility](#51-overview--primary-responsibility)
    * [5.2. Key Functionalities & API](#52-key-functionalities--api)
    * [5.3. Adherence to Standardization Pillars (Recap)](#53-adherence-to-standardization-pillars-recap)
    * [5.4. State Management (`ErrorSystem` Specifics)](#54-state-management-errorsystem-specifics)
    * [5.5. Lifecycle Management (`ErrorSystem` Specifics)](#55-lifecycle-management-errorsystem-specifics)
    * [5.6. Error Handling within `ErrorSystem`](#56-error-handling-within-errorsystem)
        * [5.6.1. Internal Error Handling (`_handleInternalError`)](#561-internal-error-handling-_handleinternalerror)
        * [5.6.2. Processing Application Errors (`handleError`)](#562-processing-application-errors-handleerror)
        * [5.6.3. Default Error Handler (`defaultCoreErrorHandler`)](#563-default-error-handler-defaultcoreerrorhandler)
    * [5.7. Event Integration (`ErrorSystem` Specifics)](#57-event-integration-errorsystem-specifics)
    * [5.8. Health Monitoring (`ErrorSystem` Specifics)](#58-health-monitoring-errorsystem-specifics)
    * [5.9. Metrics Tracking (`ErrorSystem` Specifics)](#59-metrics-tracking-errorsystem-specifics)
    * [5.10. Integrations (Managed by `ErrorSystem`)](#510-integrations-managed-by-errorsystem)
    * [5.11. Usage Examples & Best Practices (`ErrorSystem`)](#511-usage-examples--best-practices-errorsystem)
    * [5.12. Testing Strategy Notes (`ErrorSystem`)](#512-testing-strategy-notes-errorsystem)
6.  [Framework Integration Layer (`src/core/errors/integrations/`)](#6-framework-integration-layer-srccoreerrorsintegrations)
    * [6.1. Interface: `IFrameworkIntegration.js`](#61-interface-iframeworkintegrationjs)
        * [6.1.1. Purpose & Role](#611-purpose--role)
        * [6.1.2. API Definition (`initialize`, `mapError`, `serializeError`, `shutdown`)](#612-api-definition-initialize-maperror-serializeerror-shutdown)
    * [6.2. Example Implementation: `FastifyErrorHandler.js`](#62-example-implementation-fastifyerrorhandlerjs)
        * [6.2.1. Overview](#621-overview)
        * [6.2.2. Key Methods & Logic Explained](#622-key-methods--logic-explained)
        * [6.2.3. How it Integrates with `ErrorSystem` and Fastify](#623-how-it-integrates-with-errorsystem-and-fastify)
    * [6.3. Logger Serialization Helper (`FastifyErrorSerializer.js`)](#63-logger-serialization-helper-fastifyerrorserializerjs)
7.  [Shared Error Utilities (`src/core/common/ErrorUtils.js`)](#7-shared-error-utilities-srccorecommonerrorutilsjs)
    * [7.1. `async safeHandleError(errorSystem, error, context = {})`](#71-async-safehandleerrorerrorsystem-error-context---)
        * [7.1.1. Purpose and Functionality](#711-purpose-and-functionality)
        * [7.1.2. Usage Example](#712-usage-example)
8.  [Overall Error Handling Workflow & Best Practices](#8-overall-error-handling-workflow--best-practices)
9.  [Testing Strategies for the Error Handling System](#9-testing-strategies-for-the-error-handling-system)
10. [Future Considerations & Improvements for Error Handling](#10-future-considerations--improvements-for-error-handling)

---

## 1. Introduction to the Error Handling System

### 1.1. Purpose & Philosophy

The TSMIS Error Handling System is a foundational part of the core architecture designed to provide a robust, consistent, and manageable approach to dealing with exceptions and operational errors throughout the application. Its core philosophy is to ensure that errors are:

* **Consistently Structured**: All custom application errors inherit from a base `CoreError` class, providing uniform properties like `code`, `message`, `details`, `timestamp`, and `cause`.
* **Clearly Identifiable**: Standardized `ErrorCodes` allow for programmatic identification and precise understanding of specific error conditions.
* **Centrally Processed**: The `ErrorSystem` acts as a central hub for reported errors, allowing for consistent logging, metrics, and custom handling logic.
* **Contextually Rich**: Errors are encouraged to carry detailed contextual information to aid in debugging and resolution.
* **User-Friendly (where applicable)**: For errors that propagate to users (e.g., via API responses), framework integrations ensure responses are informative and well-formatted.
* **Resilient**: Mechanisms like `safeHandleError` prevent critical error reporting paths from failing silently.

This systematic approach is vital for building a robust, maintainable, and observable application.

### 1.2. Key Components & Their Roles

The Error Handling System is composed of several interconnected components, primarily residing within the `src/core/errors/` directory:

* **`CoreError.js`**: The foundational base class for all custom errors. Defines the standard structure and core functionalities for error objects.
* **Specialized Error Types** (in `src/core/errors/types/`): Subclasses of `CoreError` (e.g., `ValidationError`, `ServiceError`, `ModuleError`) tailored for specific error domains. They often carry additional domain-specific properties or default HTTP status codes.
* **`ErrorCodes.js`**: A centralized registry of all unique error code strings used within the application, categorized by domain.
* **`ErrorSystem.js`**: The central service that manages error types, registers custom error handlers, processes reported errors, and coordinates framework integrations for error responses.
* **`IFrameworkIntegration.js`** (in `src/core/errors/integrations/`): An interface defining the contract for adapters that bridge the `ErrorSystem` with specific web frameworks (e.g., Fastify).
* **`FastifyErrorHandler.js`** (in `src/core/errors/integrations/fastify/` - Example Integration): An implementation of `IFrameworkIntegration` tailored for the Fastify web framework.
* **`FastifyErrorSerializer.js`** (in `src/core/errors/integrations/fastify/`): A utility to help format errors for Fastify's internal logger.
* **`ErrorUtils.js`** (from `src/core/common/`): Contains shared utilities like `safeHandleError`.

These components work together to create a cohesive error management strategy.

### 1.3. Core Dependencies (System-Wide)

The error handling system, particularly `ErrorSystem.js` and its integrations, typically relies on:
* **Logger**: An injected logger instance (e.g., from `deps.logger`, defaulting to `console`) for outputting error information.
* **Configuration**: Application configuration (e.g., `deps.config`) can influence aspects like development mode (for stack traces) or error history limits.

### 1.4. Architectural Flow

Errors in TSMIS follow a structured reporting and handling path:
1. An error occurs and is represented as a `CoreError` (or subclass) instance, using a defined `ErrorCodes`.
2. The component encountering the error uses `safeHandleError` (often via its own `this.handleError` or `this._handleInternalError` method) to report it to the central `ErrorSystem`.
3. `ErrorSystem` processes the error, potentially invoking custom handlers.
4. If the error originated from an HTTP request, a registered framework integration (like `FastifyErrorHandler`) uses `ErrorSystem` to process the error and then formats a standardized HTTP error response.

**General Error Handling Flow in TSMIS**: 

```mermaid
sequenceDiagram
    participant AppComp as Application Component
    participant CoreErrUtil as CoreError / ErrorCodes.js
    participant ModHndlErr as Module.handleError() (if applicable)
    participant SafeHndlErr as ErrorUtils.safeHandleError()
    participant ErrSys as ErrorSystem
    participant CustomHndlr as CustomErrorHandler (in ErrorSystem)
    participant DefaultHndlr as DefaultCoreErrorHandler (in ErrorSystem)
    participant FwInt as FrameworkIntegration (e.g., FastifyErrorHandler)
    participant Logger as Logger
    participant HttpClient as HTTP Client

    AppComp->>AppComp: 1. Error Occurs
    AppComp->>CoreErrUtil: 2. new CoreError(ErrorCodes.DOMAIN.CODE, msg, details, {cause})
    CoreErrUtil-->>AppComp: Returns CoreError instance

    alt Error within a CoreModule derivative
        AppComp->>ModHndlErr: 3a. this.handleError(error, context)
        ModHndlErr->>ModHndlErr: Logs to module.state.errors, records metric
        ModHndlErr->>SafeHndlErr: safeHandleError(this.deps.errorSystem, error, context)
    else Direct reporting
        AppComp->>SafeHndlErr: 3b. safeHandleError(errorSystemInstance, error, context)
    end

    SafeHndlErr->>ErrSys: 4. errorSystem.handleError(error, context)
    Note over ErrSys: Records metric, ensures CoreError type
    ErrSys->>ErrSys: 5. Lookup Handler (Specific or Default)

    alt Specific Handler Found
        ErrSys->>CustomHndlr: 6a. specificHandler(error, context)
        CustomHndlr->>CustomHndlr: (Performs custom actions: logging, notifications, etc.)
        CustomHndlr-->>ErrSys: (Handler completes)
    else Default CoreError Handler
        ErrSys->>DefaultHndlr: 6b. defaultCoreErrorHandler(error, context)
        DefaultHndlr->>Logger: Logs error via this.deps.logger
        DefaultHndlr-->>ErrSys: (Handler completes)
    end
    
    ErrSys->>ErrSys: 7. Emits 'error:handled' or 'error:handler_failed'

    opt HTTP Context Error (Error propagates to Framework)
        AppComp-->>FwInt: (Error reaches Framework's global handler, which uses Integration)
        FwInt->>FwInt: mapError(rawError) -> mappedCoreError
        FwInt->>ErrSys: (Potentially) errorSystem.handleError(mappedCoreError, reqContext)
        FwInt->>FwInt: serializeError(mappedCoreError) -> httpPayload
        FwInt-->>HttpClient: HTTP Error Response
    end
```

---
## 2. Component: `CoreError.js` - The Foundational Error Class

### 2.1. Overview
`CoreError.js` defines the `CoreError` class, which is the cornerstone of TSMIS's standardized error handling. All custom application errors must extend this class or one of its specific subclasses. It extends the native JavaScript `Error` class, enhancing it with additional structured properties.

### 2.2. Purpose & Key Features
* **Standardized Structure**: Provides `name`, `code`, `message`, `details`, `timestamp`, and `cause` properties.
* **Error Codes**: Designed to be used with unique codes from `ErrorCodes.js`. The `code` property on a `CoreError` instance will typically be the fully prefixed code (e.g., `VALIDATION_INVALID_INPUT`).
* **Contextual Details**: Allows attaching arbitrary, serializable `details`.
* **Causation Chain**: Supports an `options.cause` parameter to link to the original error, preserving its context and stack trace.
* **Timestamping**: Automatically records the ISO 8601 timestamp of when the error instance was created.
* **JSON Serialization**: Provides a `toJSON()` method for converting error objects into a structured JSON format, suitable for API responses or logging. This method conditionally includes stack traces for development/test environments.
* **Deserialization**: Includes a static `fromJSON(data, ErrorType)` method to reconstruct `CoreError` (or subclass) instances from JSON data.
* **Extensibility**: Serves as the base for more specific error classes.
* **Environment Awareness**: Includes logic (`_isDevEnvironment`) to determine if the application is running in a development or test environment, which can affect the verbosity of `toJSON()`.

### 2.3. API Reference (`CoreError`)

#### 2.3.1. Constructor
**`new CoreError(code: string, message: string, details: object = {}, options: { cause?: Error } = {})`**
* **`code`**: `string` - The fully prefixed error code (e.g., `CORE_UNKNOWN_ERROR`, `VALIDATION_INVALID_INPUT`). Subclasses often construct this prefixed code themselves.
* **`message`**: `string` - A human-readable description of the error.
* **`details`**: `object` (optional) - Additional serializable information about the error.
* **`options.cause`**: `Error` (optional) - The underlying error that caused this one.

#### 2.3.2. Instance Properties
* `name: string`: The class name (e.g., "CoreError", "ValidationError").
* `code: string`: The error code provided.
* `message: string`: The error message.
* `details: object`: Sanitized additional details.
* `timestamp: string`: ISO 8601 timestamp of creation.
* `cause?: Error`: The wrapped original error, if any.
* `stack?: string`: The error stack trace.

#### 2.3.3. Instance Methods
* **`toJSON(): object`**: Returns a plain object representation, including `name`, `code`, `message`, `details`, `timestamp`. Includes `cause` (name, message, code, details, and dev-mode stack) and `stack` (in dev-mode).
* **`_initCause(cause)`** (private): Initializes `this.cause`, ensuring it's an `Error` instance.
* **`_sanitizeDetails(details)`** (private): Ensures `details` are serializable, providing a safe fallback.
* **`_isDevEnvironment()`** (private): Checks `process.env.NODE_ENV` or `window.ENV` to determine if it's a development/test environment.

#### 2.3.4. Static Methods
* **`static fromJSON(data: object, ErrorType: typeof CoreError = CoreError): CoreError`**: Reconstructs an error instance (of `ErrorType`) from a plain object representation.

### 2.4. State Management
Not Applicable. `CoreError` instances are data objects representing an error state; they do not manage an ongoing operational state themselves.

### 2.5. Lifecycle Management
Not Applicable. `CoreError` instances are created when an error occurs and do not have an independent lifecycle like `initialize()` or `shutdown()`.

### 2.6. Error Handling (Usage Context)
`CoreError` *is* the primary tool for representing errors. It is created and thrown by components when exceptional conditions arise. It is then caught and processed by error handling logic, often within the `ErrorSystem` or framework integrations.

### 2.7. Event Integration
Not Applicable. `CoreError` instances themselves do not directly emit or subscribe to events. Error events are typically emitted by the system or module that *handles* a `CoreError`.

### 2.8. Health Monitoring
Not Applicable.

### 2.9. Metrics Tracking
Not Applicable. Error metrics are tracked by the systems that handle these error objects.

### 2.10. Integrations (How CoreError is Used)
* **All TSMIS Components**: Any component that needs to signal an error should create and throw a `CoreError` or one of its subclasses.
* **`ErrorSystem`**: `ErrorSystem.handleError()` expects to process `CoreError` instances. `ErrorSystem.createError()` produces them.
* **Framework Integrations (e.g., `FastifyErrorHandler`)**: These integrations typically map raw framework errors to `CoreError` instances and use `CoreError.toJSON()` to serialize errors for HTTP responses.

### 2.11. Usage Examples & Best Practices
* **Creation & Throwing**:
    
    **CoreError.js**: Instantiation and Usage Example

    ```javascript
    // Assuming CoreError.js is in src/core/errors/CoreError.js
    // Assuming ErrorCodes.js is in src/core/errors/ErrorCodes.js

    // import { CoreError } from './CoreError.js'; // Or from wherever it's exported via an index file
    // import { ErrorCodes } from './ErrorCodes.js';
    // import { ServiceError } from './types/ServiceError.js'; // Example specific error

    // function performRiskyOperation(someInput) {
    //   if (!someInput) {
    //     throw new CoreError(
    //       ErrorCodes.CORE.INVALID_ARGUMENT, // Or a more specific CONFIG error code
    //       "Input cannot be empty for risky operation.",
    //       { providedInput: someInput }
    //     );
    //   }
    //   try {
    //     // const result = externalService.call(someInput);
    //     // if (!result.success) throw new Error(result.errorMessage); // Simulating external error
    //     throw new Error("External service call failed!"); // Placeholder for actual operation
    //   } catch (externalError) {
    //     // Wrapping the externalError in a more specific ServiceError
    //     throw new ServiceError(
    //       ErrorCodes.SERVICE.EXTERNAL_API_ERROR, // Assuming this code exists in ErrorCodes.SERVICE
    //       "Failed to complete operation due to an external service failure.",
    //       { operation: 'performRiskyOperation', input: someInput },
    //       { cause: externalError } // Preserving the original error
    //     );
    //   }
    // }

    // try {
    //   performRiskyOperation(null);
    // } catch (error) {
    //   if (error instanceof CoreError) {
    //     console.error("Caught a CoreError based error:");
    //     console.error("Name:", error.name);
    //     console.error("Code:", error.code);
    //     console.error("Message:", error.message);
    //     console.error("Details:", JSON.stringify(error.details, null, 2));
    //     console.error("Timestamp:", error.timestamp);
    //     if (error.cause) {
    //       console.error("Caused by:", error.cause.message);
    //     }
    //     // For API response or structured logging:
    //     // const errorResponse = error.toJSON();
    //     // console.error("Serialized JSON:", JSON.stringify(errorResponse, null, 2));
    //   } else {
    //     console.error("Caught an unexpected error type:", error);
    //   }
    // }
    ```
* **Extending `CoreError`**: See Section 3 for specialized error types.
* **Catching & Inspecting**:

    **CoreError.js**: Catching and Inspecting Errors

    ```javascript
    // // Assume performRiskyOperation and error classes are defined as in previous examples
    // // import { CoreError, ServiceError, ValidationError } from './core/errors'; // Example import
    // // import { ErrorCodes } from './core/errors/ErrorCodes';

    // try {
    //   // Call a function that might throw a CoreError or its subclass
    //   // performRiskyOperation({ data: "some data" }); // This might throw ServiceError
    //   // validateUserInput({ email: "invalid" }); // This might throw ValidationError
    // } catch (error) {
    //   if (error instanceof ValidationError) {
    //     console.error("--- Validation Error Specific Handling ---");
    //     console.error(`Validation failed for field(s): ${error.validationErrors.map(ve => ve.field).join(', ')}`);
    //     // console.log(JSON.stringify(error.toJSON(), null, 2));
    //     // sendSpecificValidationErrorResponse(error);
    //   } else if (error instanceof ServiceError) {
    //     console.error("--- Service Error Specific Handling ---");
    //     console.error(`Service operation failed with code: ${error.code}`);
    //     // console.log(JSON.stringify(error.toJSON(), null, 2));
    //     // triggerAlertForServiceFailure(error);
    //   } else if (error instanceof CoreError) {
    //     console.error("--- Generic CoreError Handling ---");
    //     console.error(`A core error occurred: [${error.code}] ${error.message}`);
    //     // console.log(JSON.stringify(error.toJSON(), null, 2));
    //   } else {
    //     console.error("--- Unexpected Non-CoreError ---");
    //     console.error(error.message);
    //     // It's good practice to wrap unexpected errors into CoreError if reporting further
    //     // const wrappedError = new CoreError(ErrorCodes.CORE.UNKNOWN_ERROR, "An unexpected error occurred.", {}, { cause: error });
    //     // errorSystem.handleError(wrappedError, { originalErrorType: error.constructor.name });
    //   }
    // }
    ```
* **Best Practices**:
    * Always use a defined `code` from `ErrorCodes.js`.
    * Provide a clear, concise `message`.
    * Include relevant, serializable `details` for debugging. Avoid sensitive data.
    * Wrap underlying exceptions using the `cause` option to preserve context.
    * Use specific subclasses of `CoreError` where appropriate for better semantic meaning.

### 2.12. Testing Strategy Notes
* Test instantiation with all constructor parameters (`code`, `message`, `details`, `cause`).
* Verify all instance properties are set correctly.
* Test `toJSON()` output in both development/test mode (with stack traces) and production mode (without stack traces).
* Test `toJSON()` includes `cause` information correctly.
* Test `static fromJSON()` can accurately reconstruct error instances.
* Test `_sanitizeDetails()` with serializable and non-serializable inputs.

---
## 3. Component: Specialized Error Types (`src/core/errors/types/`)

### 3.1. Overview and Purpose
To provide more semantic meaning and enable domain-specific handling for different kinds of errors, TSMIS utilizes a set of specialized error classes. These classes all extend the base `CoreError` and are located in the `src/core/errors/types/` directory. Using specialized types allows for more precise error identification (e.g., distinguishing a `ValidationError` from a `NetworkError`) and can facilitate type-specific error handling logic within custom handlers registered with `ErrorSystem`.

### 3.2. Common Pattern & Extension of `CoreError`
Each specialized error class generally follows this pattern:
1.  **Extends `CoreError`**: `export class SpecificError extends CoreError { ... }`
2.  **Constructor**:
    * Typically accepts `(specificCode, message, details = {}, options = {})`.
    * Calls `super(\`DOMAIN_${specificCode}\`, message, details, options)`. The `DOMAIN_` prefix (e.g., `VALIDATION_`, `AUTH_`, `MODULE_`) is hardcoded or constructed within the subclass's constructor to ensure the final `error.code` is globally unique and indicative of its domain. The `specificCode` argument is the part of the code unique within that domain (e.g., `INVALID_INPUT` for `ValidationError`).
    * Sets `this.name` explicitly to its own class name (e.g., `this.name = 'ValidationError';`).
    * Often sets a default `this.statusCode` property appropriate for HTTP responses related to that error type (e.g., `this.statusCode = 400;` for `ValidationError`).
3.  **Additional Properties/Methods (Optional)**: May define additional properties (like `this.validationErrors` in `ValidationError`) or override methods (like `toJSON()` in `ValidationError` to include these extra properties).

### 3.3. Key Individual Error Types (Brief Descriptions & Purpose)

The following are the standard specialized error types provided in the TSMIS core:

* **`AccessError.js`**: Represents errors related to authorization and access control (e.g., user lacks permission for an action). Default `statusCode: 403`.
* **`AuthError.js`**: Represents errors during authentication (e.g., invalid credentials, expired token, missing token). Default `statusCode: 401`.
* **`ConfigError.js`**: Represents errors encountered during application configuration (loading, validation, missing required values). Default `statusCode: 500`.
* **`EventError.js`**: Represents errors specific to the operation of `EventBusSystem` or `CoreEventBus` (e.g., event emission failure, invalid subscription pattern). Default `statusCode: 500`.
* **`ModuleError.js`**: Represents errors specific to the `ModuleSystem` or the lifecycle/operation of a `CoreModule` (e.g., module initialization failure, missing module dependency). Default `statusCode: 500`.
* **`NetworkError.js`**: Represents errors occurring during external network communications (e.g., request timeouts to other services, DNS lookup failures, connection refused). Default `statusCode: 503`, but can be overridden by `details.statusCode`.
* **`RouterError.js`**: Represents errors specific to `RouterSystem` or `CoreRouter` (e.g., route registration conflicts, adapter failures, invalid route definitions). Default `statusCode: 500`.
* **`ServiceError.js`**: A more generic error for issues within application services or their dependencies that don't fit other categories (e.g., database unavailable, unexpected failure in a business operation). Default `statusCode: 503`.
* **`ValidationError.js`**: Represents failures in data validation, typically for user input or API request payloads. Default `statusCode: 400`. Includes a `validationErrors` array property detailing specific field validation failures.

**Example**: Defining and Using ValidationError

```javascript
// Example definition (src/core/errors/types/ValidationError.js)
// import { CoreError } from '../CoreError.js';
// import { ErrorCodes } from '../ErrorCodes.js'; // Assuming ErrorCodes.VALIDATION.* exists

// export class ValidationError extends CoreError {
//   constructor(specificCode, message, details = {}, options = {}) {
//     super(`VALIDATION_${specificCode}`, message, details, options);
//     this.name = 'ValidationError';
//     this.statusCode = 400;
//     this.validationErrors = Array.isArray(details?.validationErrors) ? details.validationErrors : [];
//   }

//   toJSON() {
//     const json = super.toJSON();
//     json.validationErrors = this.validationErrors;
//     return json;
//   }

//   static fromJSON(data) {
//     const errorInstance = super.fromJSON(data, ValidationError);
//     errorInstance.validationErrors = Array.isArray(data?.validationErrors) ? data.validationErrors : [];
//     return errorInstance;
//   }
// }


// Example Usage:
// function validateUserInput(input) {
//   const errors = [];
//   if (!input.email || !input.email.includes('@')) {
//     errors.push({ field: 'email', message: 'A valid email is required.' });
//   }
//   if (!input.password || input.password.length < 8) {
//     errors.push({ field: 'password', message: 'Password must be at least 8 characters long.' });
//   }

//   if (errors.length > 0) {
//     throw new ValidationError(
//       ErrorCodes.VALIDATION.INVALID_INPUT, // Assuming this is 'INVALID_INPUT'
//       'User input validation failed.',
//       { validationErrors: errors, attemptId: 'user-reg-123' }
//     );
//   }
//   return true;
// }

// try {
//   validateUserInput({ email: 'test', password: 'short' });
// } catch (error) {
//   if (error instanceof ValidationError) {
//     console.error("--- Validation Error Caught ---");
//     console.error("Name:", error.name);
//     console.error("Code:", error.code); // Will be VALIDATION_INVALID_INPUT
//     console.error("Message:", error.message);
//     console.error("Status Code:", error.statusCode);
//     console.error("Details:", JSON.stringify(error.details, null, 2));
//     console.error("Validation Errors Array:", JSON.stringify(error.validationErrors, null, 2));
//   }
// }
```

---
## 4. Component: Standardized Error Codes (`ErrorCodes.js`)

### 4.1. Overview & Purpose
`ErrorCodes.js` (located at `src/core/errors/ErrorCodes.js`) is the central definition for all application-specific error code strings. Its purpose is to:
* Provide a single source of truth for all error identifiers.
* Ensure consistency and prevent typos when creating and checking errors.
* Facilitate programmatic handling of errors based on unique codes.
* Offer a categorized and human-readable (for developers) map of possible error conditions.

### 4.2. Structure and Naming Convention
* The file exports a single, deeply frozen `ErrorCodes` object.
* **Top-level keys** within `ErrorCodes` represent major domains or systems (e.g., `CORE`, `CONFIG`, `MODULE`, `VALIDATION`, `AUTH`, `ACCESS`, `NETWORK`, `EVENT`, `ROUTER`, and potentially business-module specific domains like `INVENTORY`). These keys are conventionally `PascalCase` or `UPPER_SNAKE_CASE`.
* **Nested keys** under each domain are the specific error identifiers, always in `UPPER_SNAKE_CASE` (e.g., `UNKNOWN_ERROR`, `INITIALIZATION_FAILED`).
* **Value**: The string value of each error code constant is typically the same as its key (e.g., `ErrorCodes.CORE.UNKNOWN_ERROR` would have the string value `'UNKNOWN_ERROR'`).
    * **Important**: When these specific codes (like `'INVALID_INPUT'`) are passed to the constructor of a specialized `CoreError` subclass (e.g., `new ValidationError('INVALID_INPUT', ...)`), the subclass's constructor is responsible for prepending its domain prefix to form the final, fully qualified `error.code` (e.g., `'VALIDATION_INVALID_INPUT'`). The base `CoreError` constructor itself does not add a prefix.

**Example**: Snippet from ErrorCodes.js

```javascript
// src/core/errors/ErrorCodes.js (Illustrative Snippet)

// export const ErrorCodes = Object.freeze({
//   // --- Generic Core System Errors ---
//   CORE: Object.freeze({
//     UNKNOWN_ERROR: 'UNKNOWN_ERROR',
//     INTERNAL_ERROR: 'INTERNAL_ERROR',
//     INITIALIZATION_FAILED: 'INITIALIZATION_FAILED',
//     // ... other core errors
//   }),

//   // --- Module System & CoreModule Errors ---
//   MODULE: Object.freeze({
//     INITIALIZATION_FAILED: 'INITIALIZATION_FAILED', // Specific part of the code
//     MISSING_DEPENDENCIES: 'MISSING_DEPENDENCIES',
//     // ... other module system or generic module errors
//   }),

//   // --- Validation Error Specific Codes (used by ValidationError type) ---
//   VALIDATION: Object.freeze({
//     INVALID_INPUT: 'INVALID_INPUT', // Specific part of the code
//     SCHEMA_MISMATCH: 'SCHEMA_MISMATCH',
//     REQUIRED_FIELD: 'REQUIRED_FIELD',
//     // ... other specific validation failure codes
//   }),

//   // ... other domains like CONFIG, EVENT, ROUTER, SERVICE, NETWORK, AUTH, ACCESS ...
//   // ... and business module specific domains like INVENTORY ...
// });
```

### 4.3. Usage Guidelines
* **Importing**: Import the `ErrorCodes` object where needed:
    `import { ErrorCodes } from '../core/errors/ErrorCodes.js';`
* **Creating Errors**: When instantiating `CoreError` or its subclasses, use the constants from `ErrorCodes`:
    * For generic `CoreError`: `new CoreError(ErrorCodes.CORE.INTERNAL_ERROR, ...)` (Here, `ErrorCodes.CORE.INTERNAL_ERROR` itself should be the fully prefixed string, e.g., `'CORE_INTERNAL_ERROR'`. *Self-correction: The previous description implied unprefixed values. For direct `CoreError` usage, the code value should be globally unique as `CoreError` doesn't add a prefix.*)
    * For specific subclasses (e.g., `ValidationError`): `new ValidationError(ErrorCodes.VALIDATION.INVALID_INPUT, ...)` (Here, `ErrorCodes.VALIDATION.INVALID_INPUT` would be the specific part, e.g., `'INVALID_INPUT'`, and `ValidationError` constructor prepends `VALIDATION_`).
    * *Correction*: To maintain consistency, it's better if `ErrorCodes.js` stores the *specific, unprefixed* code part, and the `CoreError` subclasses always prepend their domain. If a direct `CoreError` is needed with a specific domain, that domain prefix must be added manually or `ErrorSystem.createError` should be used. Let's assume `ErrorCodes.js` stores the unprefixed part.
* **Checking Error Codes**: In error handlers, compare `error.code` against the fully prefixed codes (e.g., `if (error.code === \`VALIDATION_${ErrorCodes.VALIDATION.INVALID_INPUT}\`)`). The `ErrorSystem` and its custom handlers will see the fully prefixed code on the error instance.
* **Adding New Codes**:
    1.  Identify or create the appropriate domain object within `ErrorCodes`.
    2.  Add a new `UPPER_SNAKE_CASE` key with its corresponding string value (the unprefixed code).
    3.  Ensure all nested objects are also frozen with `Object.freeze()`.

### 4.4. Integration with `CoreError` and `ErrorSystem`
* **`CoreError` Subclasses**: Use codes from `ErrorCodes.DOMAIN.SPECIFIC_CODE` in their constructors, prepending their domain prefix to create the final `error.code`.
* **`ErrorSystem`**:
    * `createError(typeName, code, ...)`: Expects the unprefixed `code` from `ErrorCodes.js` and uses `typeName` to find the correct `CoreError` subclass (which then adds the prefix).
    * `handleError(error, ...)`: Works with `error.code` which will be the fully prefixed code, allowing handlers to switch on these specific codes.

---
## 5. Component: Central Management (`ErrorSystem.js`)

**(This section provides a detailed summary. For the most exhaustive API details, refer to the standalone `error-system-docs.md`.)**

### 5.1. Overview & Primary Responsibility
`ErrorSystem.js` defines the `ErrorSystem` class, which acts as the central orchestrator for error management. Its primary responsibility is to process errors reported from any part of the application, route them to appropriate handlers based on their type, manage framework integrations for consistent error responses, and serve as a factory for creating standardized error objects.

### 5.2. Key Functionalities & API
* **Initialization & Shutdown**: `async initialize()` and `async shutdown()`.
* **Error Processing**: `async handleError(error: Error, context = {}): Promise<void>` is the main method for application components to report errors.
* **Handler Management**: `registerHandler(errorTypeName: string, handler: Function)` allows defining custom logic for specific error types.
* **Integration Management**: `async registerIntegration(name, IntegrationClass, frameworkInstance, options)` for plugging in adapters like `FastifyErrorHandler`.
* **Error Factory**: `createError(typeName, code, message, details, options): CoreError` for instantiating error objects.

### 5.3. Adherence to Standardization Pillars (Recap)
* **State Management**: Implements the standard `this.state` object. Also maintains `errorTypes`, `customHandlers`, and `integrations` maps.
* **Lifecycle Management**: Follows standard `initialize`/`shutdown` patterns, emitting `LIFECYCLE_EVENTS`. `initialize()` validates registered error types. `shutdown()` cleans up handlers and integrations.
* **Error Handling (Internal)**: Uses `_handleInternalError` for its own operational errors, reporting via `safeHandleError`.
* **Health Monitoring**: `checkHealth()` aggregates status from `errorsystem.state`, `errorsystem.handlers` (counts), and `errorsystem.integrations` (counts, and individual integration health if supported).
* **Metrics Tracking**: Records metrics for its lifecycle, internal errors, errors processed by `handleError`, and registrations of handlers/integrations.
* **Factory Function**: `createErrorSystem(deps = {})` is provided.

### 5.4. State Management (`ErrorSystem` Specifics)
Beyond the standard `this.state` object, `ErrorSystem` manages:
* **`errorTypes: Map<string, typeof CoreError>`**: A map storing the constructors of known `CoreError` subclasses (e.g., from `src/core/errors/types/`), keyed by their class name. Used by `ErrorSystem.createError`.
* **`customHandlers: Map<string, Function>`**: A map storing custom error handling functions, keyed by the `error.constructor.name` they are registered for.
* **`integrations: Map<string, IFrameworkIntegration>`**: A map storing active framework integration instances (like `FastifyErrorHandler`), keyed by the name provided during registration.

### 5.5. Lifecycle Management (`ErrorSystem` Specifics)
* **`initialize()`**: Key tasks include validating any pre-loaded error types that might be passed to its constructor or discovered (though the refactor primarily loads types via static imports) and preparing default handlers. It ensures the system is ready to process errors. Emits `system:initializing`, `system:initialized`, `system:running`.
* **`shutdown()`**: Key tasks include attempting to gracefully shut down any registered integrations (if they have a `shutdown` method), clearing its internal maps of handlers and integrations, and removing its own event listeners. Emits `system:shutting_down`, `system:shutdown`.

### 5.6. Error Handling within `ErrorSystem`

#### 5.6.1. Internal Error Handling (`_handleInternalError`)
For errors arising from its own operations (e.g., an invalid argument to `registerHandler`, failure during `initialize`), `ErrorSystem` uses its private `_handleInternalError(error, context)` method. This method:
1. Ensures the error is a `CoreError`.
2. Logs the error to `ErrorSystem`'s own `this.state.errors`.
3. Records an `errorsystem.errors.internal` metric.
4. Calls `safeHandleError(null, error, context)` (passing `null` for `errorSystem` to indicate the error originated within `ErrorSystem` itself, thus relying on `safeHandleError`'s console fallback).

#### 5.6.2. Processing Application Errors (`handleError`)
The public `async handleError(error: Error, context = {})` method is the primary entry point for external errors:
1. Records an `errorsystem.errors.received` metric.
2. Ensures the input `error` is an instance of `CoreError`. If not (e.g., a native `Error` or an error from a third-party library), it wraps the original error in a generic `CoreError` (with code like `ErrorCodes.CORE.UNKNOWN_ERROR`), preserving the original as `cause`.
3. **Handler Lookup**: It determines the most specific handler by:
    * First checking `this.customHandlers` for a handler registered for `error.constructor.name` (e.g., a handler for `ValidationError`).
    * If no specific handler is found, it checks for a handler registered for the generic `CoreError.name`.
4. The `defaultCoreErrorHandler` is registered for `CoreError.name` during construction, ensuring a fallback.
5. The chosen handler function `async handler(processedError, context)` is invoked.
6. After the handler executes:
    * `ErrorSystem` emits an `error:handled` event if the handler completed without throwing.
    * If the handler itself throws an error, `ErrorSystem` catches this, logs it (using its internal logger via `_handleInternalError`), and emits an `error:handler_failed` event.

#### 5.6.3. Default Error Handler (`defaultCoreErrorHandler`)
Registered for `CoreError.name` by default. If no more specific handler processes an error that is (or has been wrapped into) a `CoreError`, this handler will be invoked. Its primary action is to log the error in a structured format (using `error.toJSON()`) along with its context, via `this.deps.logger.error()`.

### 5.7. Event Integration (`ErrorSystem` Specifics)
`ErrorSystem` is an `EventEmitter` and emits operational events related to its error processing:
* **`error:handled`**: After an error has been successfully processed by a registered or default handler. Payload: `{ error: CoreError, context: object, handlerName: string }`.
* **`error:handler_failed`**: If a registered error handler itself throws an error during execution. Payload: `{ error: Error (the handler's error), originalError: CoreError, context: object }`.
* **`error:unhandled`**: (Less likely with the refactored default handler for `CoreError`) If `handleError` receives an error for which no handler could be invoked. Payload: `{ error: CoreError, context: object }`.
It also emits standard system lifecycle events for itself.

### 5.8. Health Monitoring (`ErrorSystem` Specifics)
`ErrorSystem` provides a `checkHealth()` method adhering to the standard. Its default registered health checks include:
* **`errorsystem.state`**: Reports its current lifecycle `status`, `uptime`, and the count of internal errors logged in `this.state.errors`.
* **`errorsystem.handlers`**: Reports the number of custom error handlers currently registered.
* **`errorsystem.integrations`**: Reports the number of framework integrations currently registered. If these integrations implement `checkHealth()`, their individual health statuses can be included in the `detail` part of this check.

### 5.9. Metrics Tracking (`ErrorSystem` Specifics)
`ErrorSystem` records the following key metrics:
* **Lifecycle**: `errorsystem.initialized.success`, `errorsystem.initialized.failure`, `errorsystem.shutdown.success`, `errorsystem.shutdown.failure`.
* **Internal Operations**: `errorsystem.errors.internal` (for errors within `ErrorSystem`'s own logic).
* **Error Processing**:
    * `errorsystem.errors.received`: Count of all errors passed to `handleError`. Tags: `errorName` (e.g., `ValidationError`), `errorCode` (e.g., `VALIDATION_INVALID_INPUT`).
* **Registrations**:
    * `errorsystem.handlers.registered`: Count of custom error handlers added. Tags: `errorTypeName`.
    * `errorsystem.integrations.registered`: Count of framework integrations added. Tags: `integrationName`.

### 5.10. Integrations (Managed by `ErrorSystem`)
This details how `ErrorSystem` *manages and interacts with* other components, specifically its framework integrations.
* **Framework Integrations (e.g., `FastifyErrorHandler`)**:
    * These are crucial components registered with `ErrorSystem` via `errorSystem.registerIntegration(name, IntegrationClass, frameworkInstance, options)`.
    * `ErrorSystem` can pass itself (`this`) as part of the `options` to the integration's `initialize` method, allowing the integration to call back `errorSystem.handleError()`.
    * The role of these integrations is to:
        1.  Capture errors at the boundary of a specific framework (e.g., errors in Fastify route handlers or middleware).
        2.  Use their `mapError()` method to convert these raw/framework errors into standardized `CoreError` instances.
        3.  Pass this `CoreError` to `errorSystem.handleError()` for centralized logging, metric recording, and invocation of any relevant custom application-level handlers.
        4.  Use their `serializeError()` method to convert the `CoreError` (which might have been modified or annotated by handlers) into an HTTP response payload suitable for the client.
        5.  Send the HTTP response using the framework's native mechanisms, with an appropriate status code (typically derived from `coreError.statusCode`).
* **Logger Dependency (`deps.logger`)**: Used for default error logging and `ErrorSystem`'s internal logs.
* **Configuration (`deps.config`)**: Can influence `ErrorSystem`'s behavior (e.g., `maxErrorHistory`, dev mode for integrations).

**ErrorSystem - Core Structure & Error Processing Flow**: 

```mermaid
graph TD
    subgraph ErrorOrigin [Error Origin]
        AppCode["Application Code / Other System"]
        Framework["HTTP Web Framework"]
    end

    subgraph ErrorSystemCore [ErrorSystem Core Components]
        direction LR
        ES_State[("this.state")]
        ES_Handlers[("Custom Handlers Map")]
        ES_Integrations[("Integrations Map")]
        ES_ErrorTypes[("Error Types Registry")]
    end
    
    AppCode -- "Reports error via safeHandleError()" --> SafeErrorUtil["ErrorUtils.safeHandleError()"];
    Framework -- "Catches HTTP error" --> FwInt["FrameworkIntegration Instance"];
    
    FwInt -- "mapError(rawError)" --> MappedCoreError["Standardized CoreError"];
    FwInt -- "errorSystem.handleError(MappedCoreError, reqCtx)" --> ES_HandleError["ErrorSystem.handleError()"];
    SafeErrorUtil -- "errorSystem.handleError(error, context)" --> ES_HandleError;
    
    ES_HandleError -- "1. Record Metric, Ensure CoreError" --> ES_State;
    ES_HandleError -- "2. Lookup Handler" --> ES_Handlers;
    ES_Handlers -- "3a. Found Specific/Default Handler" --> ChosenHandler["Chosen Error Handler"];
    ChosenHandler -- "4. Process Error" --> LoggingMonitoring["External Logging/Monitoring Services"];
    ChosenHandler -- "(or DefaultHandler logs via Logger)" --> LoggerDep["Logger Dependency"];
    ES_HandleError -- "5. Emit 'error:handled' or 'error:handler_failed'" --> EventBusLink["(Event on ErrorSystem)"];

    FwInt -- "Uses" --> ES_HandleError; %% For central processing
    FwInt -- "serializeError(MappedCoreError)" --> SerializedPayload["HTTP Error Payload"];
    SerializedPayload -- "reply.status(code).send()" --> Framework;
    Framework -- "HTTP Error Response" --> Client["HTTP Client"];

    AppCode -- "Creates error via errorSystem.createError()" --> ES_CreateError["ErrorSystem.createError()"];
    ES_CreateError -- "Uses" --> ES_ErrorTypes;


    classDef stateNode fill:#f9f,stroke:#333,stroke-width:2px;
    classDef utilNode fill:#e8f8f5,stroke:#333,stroke-width:1px;
    class ES_State, ES_Handlers, ES_Integrations, ES_ErrorTypes stateNode;
    class SafeErrorUtil, MappedCoreError, SerializedPayload utilNode;
```

### 5.11. Usage Examples & Best Practices (`ErrorSystem`)

**ErrorSystem**: Registering a Custom Error Handler

```javascript
// // In application setup, after ErrorSystem is initialized
// // const errorSystem = container.resolve('errorSystem');
// // import { ValidationError } from '../core/errors/types/ValidationError.js';
// // import { CoreError } from '../core/errors/CoreError.js';

// // Custom handler for ValidationErrors
// errorSystem.registerHandler(ValidationError.name, async (validationError, context) => {
//   errorSystem.deps.logger.warn(`[ValidationErrorHandler] Validation Failed for ${context.source}:`, {
//     code: validationError.code,
//     message: validationError.message,
//     validationErrors: validationError.validationErrors, // Specific to ValidationError
//     context: context,
//   });
//   // Example: Notify a monitoring service or take specific action
//   // await monitoringService.reportValidationError(validationError, context);
// });

// // Register a fallback handler for any CoreError not specifically handled by other custom handlers
// // Note: ErrorSystem constructor already registers a defaultCoreErrorHandler for CoreError.name
// // This would override it if registered after initialization.
// errorSystem.registerHandler(CoreError.name, async (coreError, context) => {
//   errorSystem.deps.logger.error(`[CustomDefaultCoreErrorHandler] Core Error Occurred for ${context.source}:`, {
//     error: coreError.toJSON(), // Use toJSON for structured logging
//     context: context,
//   });
// });
```

**ErrorSystem**: Registering FastifyErrorHandler Integration

```javascript
// // Assuming ErrorSystem instance and Fastify app instance are available
// // import { FastifyErrorHandler } from '../core/errors/integrations/fastify/FastifyErrorHandler.js';
// // import Fastify from 'fastify';

// // const errorSystem = container.resolve('errorSystem');
// // const fastifyApp = Fastify({ logger: true /* other options */ });
// // const appLogger = fastifyApp.log; // Or your main application logger

// async function setupFastifyErrorIntegration(app, errSys, logger) {
//   try {
//     await errSys.registerIntegration(
//       'fastifyMain',          // A name for this integration instance
//       FastifyErrorHandler,    // The integration class constructor
//       app,                    // The Fastify framework instance
//       { errorSystem: errSys, logger } // Options for the FastifyErrorHandler
//     );
//     logger.info('[AppSetup] FastifyErrorHandler integration registered with ErrorSystem.');
//   } catch (integrationError) {
//     logger.error('[AppSetup] Failed to register FastifyErrorHandler with ErrorSystem:', integrationError);
//     // Potentially a critical failure
//     throw integrationError;
//   }
// }

// // setupFastifyErrorIntegration(fastifyApp, errorSystem, appLogger);
```

**ErrorSystem**: Application Code Reporting an Error

```javascript
// // Inside a service or module method
// // Assume 'this.errorSystem' is an injected ErrorSystem instance
// // Assume 'this.logger' is an injected logger instance
// // import { ErrorCodes } from '../core/errors/ErrorCodes.js';
// // import { ValidationError } from '../core/errors/types/ValidationError.js';

// async function processUserData(userId, data) {
//   try {
//     if (!data.email) {
//       // Use errorSystem.createError for consistency
//       throw this.errorSystem.createError(
//         'ValidationError', // Type name (class name)
//         ErrorCodes.VALIDATION.REQUIRED_FIELD, // Specific code (unprefixed)
//         'Email is required for user processing.',
//         { field: 'email', userId, component: 'UserProcessor' }
//       );
//     }
//     // ... other processing ...
//     this.logger.info(`[UserProcessor] Successfully processed data for user ${userId}`);
//   } catch (error) {
//     // Let ErrorSystem handle it
//     const processingContext = {
//       operation: 'processUserData',
//       userId,
//       inputDataSummary: { hasEmail: !!data.email, keyCount: Object.keys(data).length }
//     };
//     await this.errorSystem.handleError(error, processingContext);

//     // Re-throw if the caller needs to act on the error (e.g., API layer to send HTTP response)
//     // If error is already handled and an HTTP response sent by an integration, re-throwing might not be needed here.
//     throw error;
//   }
// }
```

* **Best Practices**:
    * Initialize `ErrorSystem` early in the application bootstrap.
    * Register specific handlers for common, actionable error types.
    * Always use a framework integration for web applications.
    * Provide rich context when calling `handleError`.
    * Ensure a capable, structured logger is injected.

### 5.12. Testing Strategy Notes (`ErrorSystem`)
* Test handler registration and correct invocation based on error type.
* Test `handleError` with `CoreError`s, subclasses, and native errors (to check wrapping).
* Test `createError` factory.
* Test `registerIntegration` with mock `IFrameworkIntegration`.
* Test lifecycle, health checks, and metrics.
* Test behavior when its own logger or dependencies are misconfigured (graceful degradation, console fallbacks via `safeHandleError`).

---
## 6. Framework Integration Layer (`src/core/errors/integrations/`)

To bridge the gap between the abstract `ErrorSystem` and concrete web frameworks like Fastify, TSMIS employs an integration layer. This layer consists of an interface and specific adapter implementations.

### 6.1. Interface: `IFrameworkIntegration.js`

#### 6.1.1. Purpose & Role
`IFrameworkIntegration.js` defines the standard contract that any framework-specific error handling adapter must implement. This allows `ErrorSystem` to manage different integrations polymorphically, without needing to know the specifics of each framework. The primary role of an integration is to capture errors from a web framework, process them through `ErrorSystem`, and then format an appropriate HTTP error response.

#### 6.1.2. API Definition
Key methods defined by `IFrameworkIntegration`:
* **`async initialize(framework: object, options: { errorSystem?: ErrorSystem, logger?: object })`**: Sets up the integration with the framework instance (e.g., by registering a global error handler). Receives `ErrorSystem` and `logger` via `options`.
* **`mapError(frameworkError: Error, requestContext = {}): CoreError`**: Converts a raw error from the framework (or a native JS error) into a standardized `CoreError` or one of its subclasses.
* **`serializeError(coreError: CoreError, requestContext = {}): object`**: Transforms a `CoreError` instance into a plain object payload suitable for an HTTP response body, taking into account things like whether to include stack traces (based on environment).
* **`async shutdown(): Promise<void>|void`** (Optional): Allows the integration to perform any necessary cleanup when `ErrorSystem` is shut down.

**IFrameworkIntegration.js**: Interface Definition

```javascript
// src/core/errors/integrations/IFrameworkIntegration.js (Illustrative Content)
// import { CoreError } from '../CoreError.js';
// import { ErrorSystem } from '../ErrorSystem.js'; // For type hinting

// export class IFrameworkIntegration {
//   async initialize(framework, options = {}) {
//     throw new Error('IFrameworkIntegration.initialize() must be implemented by subclass.');
//   }

//   mapError(frameworkError, requestContext = {}) {
//     throw new Error('IFrameworkIntegration.mapError() must be implemented by subclass.');
//   }

//   serializeError(coreError, requestContext = {}) {
//     throw new Error('IFrameworkIntegration.serializeError() must be implemented by subclass.');
//   }

//   async shutdown() {
//     // Optional cleanup
//   }
// }
```

### 6.2. Example Implementation: `FastifyErrorHandler.js`

#### 6.2.1. Overview
`FastifyErrorHandler.js` provides a concrete implementation of `IFrameworkIntegration` tailored for the Fastify web framework. It hooks into Fastify's error handling mechanism to ensure all errors are processed by `ErrorSystem` and result in consistent, standardized HTTP error responses.

#### 6.2.2. Key Methods & Logic Explained
* **`async initialize(fastify, options)`**:
    * Stores `options.errorSystem` and `options.logger`.
    * Adds a Fastify `onRequest` hook to create a basic `request.errorContext` (e.g., `requestId`, `url`, `method`).
    * Calls `fastify.setErrorHandler()` to register Fastify's global error handler. This global handler function encapsulates the core error processing logic:
        1.  It calls `this.mapError(errorFromFastify, request.errorContext)` to get a `CoreError`.
        2.  It calls `await this.errorSystem.handleError(coreError, request.errorContext)` to allow `ErrorSystem` (and any custom handlers) to process the error (log, emit events, record metrics, etc.).
        3.  It calls `this.serializeError(coreError, request.errorContext)` to generate the JSON payload for the HTTP response.
        4.  It uses `reply.status(coreError.statusCode || 500).send(payload)` to send the HTTP response.
* **`mapError(frameworkError, requestContext)`**:
    * Intelligently converts various types of errors into `CoreError` instances.
    * If `frameworkError` is already a `CoreError`, it's returned directly.
    * Handles Fastify's specific validation errors (those with a `.validation` property or code `FST_ERR_VALIDATION`) by creating a detailed `ValidationError`, populating `validationErrors` from Fastify's validation output.
    * Handles Fastify's "Not Found" errors (code `FST_ERR_NOT_FOUND` or `statusCode === 404`) by creating a `NetworkError` with an `ErrorCodes.NETWORK.ROUTE_NOT_FOUND` code.
    * For other, generic errors, it wraps them in a `CoreError` with `ErrorCodes.CORE.UNKNOWN_ERROR`, preserving the original message and cause.
    * It ensures an appropriate `statusCode` is set on the resulting `CoreError`.
* **`serializeError(coreError, requestContext)`**:
    * Primarily relies on `coreError.toJSON()` to get the base serializable object.
    * May selectively add minimal, safe information from `requestContext` (like `requestId`) to the response if configured or deemed necessary for client-side correlation. It avoids exposing excessive internal details.

**FastifyErrorHandler.js**: Example Implementation Snippet

```javascript
// src/core/errors/integrations/fastify/FastifyErrorHandler.js (Illustrative Snippet)
// import { IFrameworkIntegration } from '../IFrameworkIntegration.js';
// import { CoreError } from '../../CoreError.js';
// import { ErrorCodes } from '../../ErrorCodes.js';
// import { ValidationError, NetworkError } from '../../types/index.js';

// export class FastifyErrorHandler extends IFrameworkIntegration {
//   errorSystem = null;
//   logger = console;
//   initialized = false;

//   constructor() { super(); }

//   async initialize(fastify, options = {}) {
//     if (this.initialized) return;
//     this.errorSystem = options.errorSystem;
//     this.logger = options.logger || this.logger;

//     fastify.addHook('onRequest', async (request, reply) => {
//       request.errorContext = { /* requestId, url, method, ip, timestamp */ };
//     });

//     fastify.setErrorHandler(async (error, request, reply) => {
//       const requestContext = { ...request.errorContext, params: request.params, query: request.query };
//       const mappedCoreError = this.mapError(error, requestContext);

//       if (this.errorSystem) {
//         await this.errorSystem.handleError(mappedCoreError, requestContext);
//       } else {
//         this.logger.error('[FastifyErrorHandler] ErrorSystem unavailable. Logging raw mapped error:', {
//           error: mappedCoreError.toJSON ? mappedCoreError.toJSON() : mappedCoreError, context: requestContext,
//         });
//       }
//       const responsePayload = this.serializeError(mappedCoreError, requestContext);
//       let statusCode = mappedCoreError.statusCode || 500;
//       if (typeof statusCode !== 'number' || statusCode < 100 || statusCode > 599) statusCode = 500;
//       reply.status(statusCode).send(responsePayload);
//     });
//     this.initialized = true;
//   }

//   mapError(frameworkError, requestContext = {}) {
//     if (frameworkError instanceof CoreError) return frameworkError;
//     if (frameworkError.code === 'FST_ERR_VALIDATION' || frameworkError.validation) {
//       // ... create ValidationError ...
//       // return validationError;
//     }
//     if (frameworkError.code === 'FST_ERR_NOT_FOUND' || frameworkError.statusCode === 404) {
//       // ... create NetworkError ...
//       // return notFoundError;
//     }
//     // ... create generic CoreError ...
//     // return genericError;
//     return new CoreError(ErrorCodes.CORE.UNKNOWN_ERROR, frameworkError.message, {}, { cause: frameworkError }); // Simplified for snippet
//   }

//   serializeError(coreError, requestContext = {}) {
//     if (coreError instanceof CoreError) {
//       const serialized = coreError.toJSON();
//       return { ...serialized /*, context: { requestId: requestContext?.requestId } */ };
//     }
//     return { /* fallback serialization */ };
//   }
// }
```

#### 6.2.3. How it Integrates with `ErrorSystem` and Fastify
1.  **Registration**: An instance of `FastifyErrorHandler` is typically created and then registered with `ErrorSystem` using `errorSystem.registerIntegration('fastify', FastifyErrorHandler, fastifyAppInstance, { errorSystem: errorSystemInstance, logger })`.
2.  **Initialization**: `ErrorSystem` calls `fastifyErrorHandler.initialize(fastifyAppInstance, options)`.
3.  **Runtime**: When Fastify catches an error in a route or plugin, it invokes the global error handler set up by `FastifyErrorHandler`. This handler then coordinates with `ErrorSystem` for processing and uses its own logic for Fastify-specific response formatting.

### 6.3. Logger Serialization Helper (`FastifyErrorSerializer.js`)
Fastify uses Pino as its logger, which allows for custom serializers for different data types, including errors. `FastifyErrorSerializer.js` provides a utility function, `createFastifyLoggerErrorSerializer(serializeMethod)`, to help configure Fastify's logger to use the same `serializeError` logic (from an instantiated `FastifyErrorHandler`) for formatting errors that are logged directly by Fastify/Pino.

This ensures that errors appearing in logs (whether processed by `ErrorSystem` or logged directly by Fastify) have a consistent, structured format.

**FastifyErrorSerializer.js**: Utility Definition

```javascript
// src/core/errors/integrations/fastify/FastifyErrorSerializer.js (Illustrative Content)

// export function createFastifyLoggerErrorSerializer(serializeMethod) {
//   if (typeof serializeMethod !== 'function') {
//     console.warn('[FastifyErrorSerializer] serializeMethod is not a function.');
//     return {
//       serializer: (error) => ({ message: error.message, stack: error.stack, code: error.code, name: error.name })
//     };
//   }
//   return {
//     serializer: (error) => serializeMethod(error, {}), // Pass empty context for logger
//   };
// }
```

## 7. Shared Error Utilities (`src/core/common/ErrorUtils.js`)

### 7.1. `async safeHandleError(errorSystem, error, context = {})`

#### 7.1.1. Purpose and Functionality
This critical utility (located in `src/core/common/ErrorUtils.js`) provides a fallback mechanism for error reporting. It attempts to delegate error handling to the provided `errorSystem` instance. If the `errorSystem` is not available or if `errorSystem.handleError()` itself throws an exception, `safeHandleError` catches this secondary failure and logs the original error (and the forwarding error, if any) directly to `console.error`. This ensures that critical error information is not lost even if the primary error handling pathway fails.

#### 7.1.2. Usage Example

**Example**: Usage of safeHandleError

```javascript
// Example usage of safeHandleError within a component's method:
// Assume 'this.deps.errorSystem' holds the ErrorSystem instance
// and 'this.state.errors' is the component's internal error log.
// import { CoreError } from '../errors/CoreError.js'; // Or a specific subclass
// import { ErrorCodes } from '../errors/ErrorCodes.js';
// import { safeHandleError } from '../common/ErrorUtils.js';

// async function someOperationInComponent() {
//   try {
//     // ... code that might throw an error ...
//     if (true /* some condition leads to error */) {
//       throw new Error("A raw error occurred during the operation.");
//     }
//   } catch (rawError) {
//     // Create a standardized CoreError
//     const operationError = new CoreError(
//       ErrorCodes.CORE.OPERATION_FAILED || 'OPERATION_FAILED', // Example code
//       `The operation failed: ${rawError.message}`,
//       { operationName: 'someOperationInComponent', inputParameters: { /*...*/ } },
//       { cause: rawError }
//     );

//     // Report to central ErrorSystem via safeHandleError
//     await safeHandleError(this.deps.errorSystem, operationError, {
//       source: this.constructor.name, // Identify the source component
//       customContext: 'Additional info about where in the operation it failed.'
//     });

//     // Optionally, also log to the component's internal state for local context
//     // This might be part of a _handleInternalError method pattern
//     // this.state.errors.push({ 
//     //   error: operationError, 
//     //   timestamp: new Date().toISOString(), 
//     //   context: { operationName: 'someOperationInComponent' } 
//     // });

//     // Decide whether to re-throw the operationError or handle further
//     // throw operationError; 
//   }
// }
```

## 8. Overall Error Handling Workflow & Best Practices

The general workflow for errors in TSMIS is designed to be robust and informative:
1.  **Detection & Instantiation**: Errors are detected, and specific `CoreError` subclasses are instantiated with codes from `ErrorCodes.js`, clear messages, details, and wrapped causes.
2.  **Local Handling Attempt (Optional)**: A component might attempt to handle an error locally if it's recoverable.
3.  **Centralized Reporting**: Unrecoverable or significant errors are reported to `ErrorSystem` via `module.handleError()` or `safeHandleError()`.
4.  **`ErrorSystem` Processing**: `ErrorSystem` invokes appropriate handlers (custom or default). Handlers perform actions like logging, metrics updates, or notifications.
5.  **API Response (if applicable)**: For errors in an HTTP request context, the framework integration (e.g., `FastifyErrorHandler`) uses the processed `CoreError` to generate and send a standardized HTTP error response.

**General Error Handling Flow in TSMIS (Recap)**: 

```mermaid
sequenceDiagram
    participant AppComp as Application Component
    participant CoreErrUtil as CoreError / ErrorCodes.js
    participant ModHndlErr as Module.handleError() (if applicable)
    participant SafeHndlErr as ErrorUtils.safeHandleError()
    participant ErrSys as ErrorSystem
    participant CustomHndlr as CustomErrorHandler (in ErrorSystem)
    participant DefaultHndlr as DefaultCoreErrorHandler (in ErrorSystem)
    participant FwInt as FrameworkIntegration (e.g., FastifyErrorHandler)
    participant Logger as Logger
    participant HttpClient as HTTP Client

    AppComp->>AppComp: 1. Error Occurs
    AppComp->>CoreErrUtil: 2. new CoreError(ErrorCodes.DOMAIN.CODE, msg, details, {cause})
    CoreErrUtil-->>AppComp: Returns CoreError instance

    alt Error within a CoreModule derivative
        AppComp->>ModHndlErr: 3a. this.handleError(error, context)
        ModHndlErr->>ModHndlErr: Logs to module.state.errors, records metric
        ModHndlErr->>SafeHndlErr: safeHandleError(this.deps.errorSystem, error, context)
    else Direct reporting
        AppComp->>SafeHndlErr: 3b. safeHandleError(errorSystemInstance, error, context)
    end

    SafeHndlErr->>ErrSys: 4. errorSystem.handleError(error, context)
    Note over ErrSys: Records metric, ensures CoreError type
    ErrSys->>ErrSys: 5. Lookup Handler (Specific or Default)

    alt Specific Handler Registered
        ErrSys->>CustomHndlr: 6a. specificHandler(error, context)
        CustomHndlr->>CustomHndlr: (Performs custom actions: logging, notifications, etc.)
        CustomHndlr-->>ErrSys: (Handler completes)
    else Default CoreError Handler
        ErrSys->>DefaultHndlr: 6b. defaultCoreErrorHandler(error, context)
        DefaultHndlr->>Logger: Logs error via this.deps.logger
        DefaultHndlr-->>ErrSys: (Handler completes)
    end
    
    ErrSys->>ErrSys: 7. Emits 'error:handled' or 'error:handler_failed'

    opt HTTP Context Error (Error propagates to Framework)
        AppComp-->>FwInt: (Error reaches Framework's global handler, which uses Integration)
        FwInt->>FwInt: mapError(rawError) -> mappedCoreError
        FwInt->>ErrSys: (Potentially) errorSystem.handleError(mappedCoreError, reqContext)
        FwInt->>FwInt: serializeError(mappedCoreError) -> httpPayload
        FwInt-->>HttpClient: HTTP Error Response
    end
```

**Best Practices:**
* **Specificity**: Use the most specific `CoreError` subclass and `ErrorCode` possible.
* **Context is Key**: Always provide rich, serializable `details` and wrap `cause` when creating errors.
* **Report, Don't Just Log (Usually)**: For significant errors, prefer reporting to `ErrorSystem` over just `console.log` so that centralized logic, metrics, and potential integrations can act on them.
* **Idempotent Handlers**: Design custom error handlers in `ErrorSystem` to be idempotent if they might be called multiple times for the same underlying issue (though `ErrorSystem` itself doesn't retry handlers).
* **Security**: Be mindful of not leaking sensitive information in error messages or details that might be exposed to clients. `CoreError.toJSON()` and framework integration serializers should consider this.
* **Test Error Paths**: Thoroughly test error conditions in your modules and services.

## 9. Testing Strategies for the Error Handling System
* **`CoreError` & Subclasses**: Verify correct property assignment, `toJSON()` output (dev vs. prod), `cause` handling, and `fromJSON()` reconstruction. For subclasses, test `statusCode` and any specific properties (e.g., `ValidationError.validationErrors`).
* **`ErrorCodes.js`**: While mainly a data structure, ensure it's correctly imported and used in error instantiation tests.
* **`ErrorSystem.js`**:
    * Test `initialize()` and `shutdown()` lifecycles, including state changes and event emissions.
    * Test `registerHandler()`: Ensure handlers are stored and correctly invoked by `handleError()` based on error type.
    * Test `handleError()`: Provide various error types (CoreError, subclasses, native Errors) and verify correct handler invocation, error wrapping, and event emissions (`error:handled`, `error:handler_failed`).
    * Test `defaultCoreErrorHandler` behavior.
    * Test `createError()` factory method.
    * Test `registerIntegration()` with a mock `IFrameworkIntegration` to ensure it's called correctly.
    * Test internal error handling (`_handleInternalError`) by inducing failures in its methods.
    * Test health checks and metrics.
* **`IFrameworkIntegration.js` Implementations (e.g., `FastifyErrorHandler.js`)**:
    * Test `initialize()` by mocking the framework instance (e.g., Fastify `app`) and verifying that `setErrorHandler` (or equivalent) is called.
    * Test `mapError()` with a variety of framework-specific errors and generic errors to ensure correct mapping to `CoreError` types and status codes.
    * Test `serializeError()` with different `CoreError` instances to ensure correct HTTP response payload generation.
    * Conduct integration tests where actual errors are thrown in a mock Fastify route, ensuring the `FastifyErrorHandler` catches them, interacts with a mock `ErrorSystem`, and that the mock Fastify `reply` object is called with the expected status and payload.
* **`ErrorUtils.js`**:
    * Test `safeHandleError()` with a mock `ErrorSystem` that works, one that is null/invalid, and one whose `handleError` method throws an error, verifying console fallbacks.
    * Test `createStandardHealthCheckResult()` to ensure it produces the correct output structure.

## 10. Future Considerations & Improvements for Error Handling
(Drawn from the more general "ErrorSystem Related" in the main SoT conclusion)
* **Enhanced Error Tracking & Analytics**: Implement features like error aggregation, deduplication, and unique error identifiers for improved cross-system tracing. Consider integration with third-party error reporting services (Sentry, Rollbar).
* **Expanded Framework Integrations**: Develop error handling adapters for other web frameworks (e.g., Express, Koa) or API styles (e.g., GraphQL) as needed.
* **Security for Error Details**: Implement more sophisticated sanitization and configurable redaction policies for sensitive data within error reports.
* **Error Analysis Tools**: Develop tools for analyzing error patterns, implement automated root cause analysis capabilities.
* **Improved Developer Experience for Error Debugging**: Enhance context in development mode, potentially link error codes to detailed online documentation.
* **Error Code to Message Localization**: For user-facing errors, map `ErrorCodes` to localized messages.


// src/core/errors/index.js

/**
 * @file src/core/errors/index.js
 * @description Main public interface for the TSMIS Error System.
 * Exports CoreError, ErrorSystem, factory functions, all specific error types,
 * standardized error codes, and framework integration components.
 */

import { CoreError } from './CoreError.js';
import { ErrorSystem, createErrorSystem } from './ErrorSystem.js';
import { ErrorCodes } from './ErrorCodes.js'; // Assuming ErrorCodes.js is now a separate file

// Import all specific error types and the ErrorTypes namespace from ./types/index.js
import * as SpecificErrorTypes from './types/index.js';

// Import integration components from ./integrations/index.js
import * as Integrations from './integrations/index.js';

// Export the main classes and factory
export {
  CoreError,
  ErrorSystem,
  createErrorSystem,
  ErrorCodes,
};

// Export all specific error types individually for direct consumption
export {
  SpecificErrorTypes_ AccessError,
  SpecificErrorTypes_ AuthError,
  SpecificErrorTypes_ ConfigError,
  SpecificErrorTypes_ EventError,
  SpecificErrorTypes_ ModuleError,
  SpecificErrorTypes_ NetworkError,
  SpecificErrorTypes_ RouterError,
  SpecificErrorTypes_ ServiceError,
  SpecificErrorTypes_ ValidationError,
} from './types/index.js'; // This re-exports named exports from types/index.js

// Export the ErrorTypes namespace object
// (This is the object containing all specific error type classes, e.g., ErrorTypes.ValidationError)
export const ErrorTypes = SpecificErrorTypes.ErrorTypes;


// Export integration-related components
export {
  Integrations_ IFrameworkIntegration,
  Integrations_ FastifyErrorHandler, // The class itself
  Integrations_ createFastifyLoggerErrorSerializer, // The utility function
  // Add other specific integrations here if they are directly exported, e.g., ExpressErrorHandler
} from './integrations/index.js';


/**
 * Utility function to create a CoreError (or subclass) from an HTTP-like response object.
 * This is similar to the original `createErrorFromResponse`.
 *
 * @param {object} response - The response object, expected to have properties like
 * `data.name`, `data.code`, `data.message`, `data.details`.
 * If `data` is not present, it will look at the root of `response`.
 * @param {string} [defaultMessage='Unknown error occurred'] - Default message if not found in response.
 * @returns {CoreError} An instance of CoreError or its determined subclass.
 */
export function createErrorFromResponse(response, defaultMessage = 'Unknown error occurred') {
  const errorData = response?.data || response || {}; // [cite: 333]
  let message = errorData.message || defaultMessage; // [cite: 335]
  let code = errorData.code || ErrorCodes.CORE.UNKNOWN_ERROR; // [cite: 335]
  let details = errorData.details || {}; // [cite: 335]
  let cause = errorData.cause; // The original createErrorFromResponse passed the whole response as cause [cite: 335]

  // Determine the ErrorConstructor based on errorData.name
  // This relies on ErrorTypes namespace being available (either imported here or from SpecificErrorTypes)
  const ErrorConstructor = SpecificErrorTypes.ErrorTypes[errorData.name] || CoreError; // [cite: 334]

  // If the ErrorConstructor is a specific type (e.g., ValidationError),
  // the code passed to it should be the specific part, not the prefixed one.
  // However, errorData.code might already be the full prefixed code if coming from another TSMIS service.
  // For now, we assume errorData.code is the intended code to pass to the constructor.
  // The constructors of specific error types will add their prefixes.
  // If errorData.code ALREADY has a prefix and ErrorConstructor is specific, it might get double-prefixed.
  // This needs careful handling based on expected `errorData.code` format.
  // Let's assume `errorData.code` is the *full* code for now, and constructors are idempotent with prefixes
  // OR that `errorData.code` is the *specific* part of the code.
  // Given the refactored error constructors expect the specific part (e.g. 'INVALID_INPUT'),
  // we might need to strip a prefix from `errorData.code` if `ErrorConstructor` is not `CoreError`.

  if (ErrorConstructor !== CoreError && typeof code === 'string') {
    const prefix = `${ErrorConstructor.name.replace('Error', '').toUpperCase()}_`; // e.g., VALIDATION_
    if (code.startsWith(prefix)) {
        // Code already seems to have a prefix that matches the error type name,
        // or it's a code that the subclass constructor expects without the prefix.
        // The subclass constructors now expect the unprefixed code.
        // So, if `errorData.name` is `ValidationError` and `code` is `VALIDATION_INVALID_INPUT`,
        // we should pass `INVALID_INPUT` to `new ValidationError()`.
        code = code.substring(prefix.length);
    } else if (code.includes('_') && ErrorConstructor.name.toUpperCase().startsWith(code.split('_')[0])) {
        // Heuristic: If code is FOO_BAR and ErrorConstructor is FooError, pass BAR.
        // This is a bit fragile. Better if errorData.code is always the non-prefixed version
        // when errorData.name indicates a specific type.
        // For now, we'll pass it as is and rely on constructor logic or specific code format.
    }
  }


  const errorInstance = new ErrorConstructor(
    code,
    message,
    details,
    { cause: cause || response } // Pass original response as part of the cause if no specific cause data
  );

  // If errorData.name was present and we used CoreError as fallback, set the name.
  if (errorData.name && ErrorConstructor === CoreError && errorInstance.name !== errorData.name) {
      errorInstance.name = errorData.name;
  }

  // For ValidationError, specifically re-attach validationErrors if present in details
  if (errorInstance instanceof SpecificErrorTypes.ValidationError && Array.isArray(details.validationErrors)) {
    errorInstance.validationErrors = details.validationErrors;
  }

  return errorInstance;
}

// Default export can be the ErrorTypes namespace or the ErrorSystem class,
// depending on the most common usage.
// Your original had 'export default ErrorTypes;' [cite: 336]
// Sticking to named exports mostly, but if a default is desired:
// export default ErrorTypes;
// Or for more comprehensive default:
export default {
  CoreError,
  ErrorSystem,
  createErrorSystem,
  ErrorCodes,
  ErrorTypes: SpecificErrorTypes.ErrorTypes, // Explicitly re-exporting here too
  createErrorFromResponse,
  Integrations,
  // Individually exporting types again for convenience if default is used by consumer
  AccessError: SpecificErrorTypes.AccessError,
  AuthError: SpecificErrorTypes.AuthError,
  ConfigError: SpecificErrorTypes.ConfigError,
  EventError: SpecificErrorTypes.EventError,
  ModuleError: SpecificErrorTypes.ModuleError,
  NetworkError: SpecificErrorTypes.NetworkError,
  RouterError: SpecificErrorTypes.RouterError,
  ServiceError: SpecificErrorTypes.ServiceError,
  ValidationError: SpecificErrorTypes.ValidationError,
};


// src/core/errors/integrations/IFrameworkIntegration.js

/**
 * @file IFrameworkIntegration.js
 * @description Defines the interface for framework-specific error handling integrations
 * that work with the ErrorSystem.
 */

import { CoreError } from '../CoreError.js'; // For type hinting and potential use in implementations

/**
 * @interface IFrameworkIntegration
 * @description Interface that framework-specific error handling integrations must implement.
 * These integrations bridge the ErrorSystem with HTTP frameworks like Fastify or Express.
 */
export class IFrameworkIntegration {
  /**
   * Initializes the integration with the specific web framework instance.
   * This method should set up global error handlers for the framework.
   *
   * @param {object} framework - The instance of the web framework (e.g., Fastify app, Express app).
   * @param {object} [options={}] - Integration-specific options. May include a reference to ErrorSystem.
   * @param {ErrorSystem} [options.errorSystem] - An instance of the ErrorSystem for centralized error processing.
   * @param {object} [options.logger] - A logger instance.
   * @returns {Promise<void>|void}
   * @throws {Error} If initialization fails or framework instance is invalid.
   */
  async initialize(framework, options = {}) { // [cite: 337]
    throw new Error('IFrameworkIntegration.initialize() must be implemented by subclass.');
  }

  /**
   * Maps a raw error (often framework-specific or a native JavaScript Error)
   * to a standardized CoreError instance or one of its subclasses.
   *
   * @param {Error} frameworkError - The raw error object caught by the framework.
   * @param {object} [requestContext={}] - Optional context from the request (e.g., request.id, url, method).
   * @returns {CoreError} An instance of CoreError or its subclass.
   * @throws {Error} If mapping fails.
   */
  mapError(frameworkError, requestContext = {}) { // [cite: 339]
    throw new Error('IFrameworkIntegration.mapError() must be implemented by subclass.');
  }

  /**
   * Serializes a CoreError instance into a format suitable for an HTTP response body.
   *
   * @param {CoreError} coreError - The CoreError instance to serialize.
   * @param {object} [requestContext={}] - Optional context from the request.
   * @returns {object} A plain object representing the error response payload.
   * @throws {Error} If serialization fails.
   */
  serializeError(coreError, requestContext = {}) { // [cite: 338]
    throw new Error('IFrameworkIntegration.serializeError() must be implemented by subclass.');
  }

  /**
   * Optional method for integrations to perform cleanup during ErrorSystem shutdown.
   * @returns {Promise<void>|void}
   */
  async shutdown() {
    // Optional: Subclasses can implement this if they need to clean up resources.
  }
}

// For clarity, an interface is often not exported as default if it's truly just a contract.
// However, if it's used as a base class from which others must inherit (as in JS), default export is fine.
// export default IFrameworkIntegration;


// src/core/errors/integrations/fastify/FastifyErrorHandler.js

/**
 * @file FastifyErrorHandler.js
 * @description Implements IFrameworkIntegration for Fastify, providing standardized
 * error handling, mapping, and serialization for Fastify applications.
 */

import { IFrameworkIntegration } from '../IFrameworkIntegration.js';
import { CoreError } from '../../CoreError.js';
import { ErrorCodes } from '../../ErrorCodes.js';
import { ValidationError, NetworkError } from '../../types/index.js'; // Ensure types index exports these

export class FastifyErrorHandler extends IFrameworkIntegration {
  /**
   * @type {ErrorSystem | null}
   */
  errorSystem = null;
  /**
   * @type {object}
   */
  logger = console;
  /**
   * @type {boolean}
   */
  initialized = false;

  constructor() {
    super();
    // Dependencies like errorSystem and logger will be passed via options in initialize
  }

  /**
   * Initializes the Fastify error handling integration.
   * Sets up Fastify's global error handler and an onRequest hook for error context.
   * @param {object} fastify - The Fastify framework instance.
   * @param {object} [options={}] - Integration options.
   * @param {ErrorSystem} [options.errorSystem] - The ErrorSystem instance for processing errors.
   * @param {object} [options.logger] - A logger instance.
   * @override
   */
  async initialize(fastify, options = {}) {
    if (this.initialized) {
      this.logger.warn('[FastifyErrorHandler] Already initialized.');
      return;
    }
    if (!fastify || typeof fastify.setErrorHandler !== 'function' || typeof fastify.addHook !== 'function') {
      throw new CoreError(ErrorCodes.CORE.INVALID_ARGUMENT, 'Invalid Fastify instance provided to FastifyErrorHandler.');
    }

    this.errorSystem = options.errorSystem;
    this.logger = options.logger || this.logger;

    // Add error context to request
    fastify.addHook('onRequest', async (request, reply) => {
      // Create a basic error context on the request object
      // This can be enriched by other middleware or route handlers
      request.errorContext = {
        requestId: request.id,
        url: request.raw?.url || request.url, // Prefer raw.url if available
        method: request.raw?.method || request.method,
        ip: request.ip,
        timestamp: new Date().toISOString(),
      };
    });

    // Set Fastify's global error handler
    fastify.setErrorHandler(async (error, request, reply) => {
      const requestContext = { // Augment context from request if available
        ...(request.errorContext || {}), // Base context from onRequest hook
        params: request.params,
        query: request.query,
        // Avoid logging full body by default unless configured, can be large/sensitive
        // bodySummary: request.body ? { keys: Object.keys(request.body) } : undefined,
      };

      // 1. Map the raw Fastify error to a CoreError instance
      const mappedCoreError = this.mapError(error, requestContext);

      // 2. Process with ErrorSystem (logging, custom handlers, metrics, etc.)
      if (this.errorSystem && typeof this.errorSystem.handleError === 'function') {
        await this.errorSystem.handleError(mappedCoreError, requestContext);
      } else {
        // Fallback logging if ErrorSystem is not available
        this.logger.error('[FastifyErrorHandler] ErrorSystem not available. Logging raw mapped error:', {
          error: mappedCoreError.toJSON ? mappedCoreError.toJSON() : mappedCoreError,
          context: requestContext,
        });
      }

      // 3. Serialize the CoreError for the HTTP response
      const responsePayload = this.serializeError(mappedCoreError, requestContext);

      // 4. Send the HTTP response
      // Ensure status code is a number and in valid HTTP range
      let statusCode = mappedCoreError.statusCode || 500;
      if (typeof statusCode !== 'number' || statusCode < 100 || statusCode > 599) {
          this.logger.warn(`[FastifyErrorHandler] Invalid statusCode ${statusCode} from error ${mappedCoreError.code}. Defaulting to 500.`);
          statusCode = 500;
      }
      reply.status(statusCode).send(responsePayload);
    });

    this.initialized = true;
    this.logger.info('[FastifyErrorHandler] Initialized and Fastify error handler set.');
  }

  /**
   * Maps a raw Fastify error to a standardized CoreError.
   * @param {Error} frameworkError - The error object caught by Fastify.
   * @param {object} [requestContext={}] - Context from the HTTP request.
   * @returns {CoreError}
   * @override
   */
  mapError(frameworkError, requestContext = {}) { //
    if (frameworkError instanceof CoreError) {
      return frameworkError; //
    }

    // Handle Fastify's built-in validation errors (FST_ERR_VALIDATION)
    if (frameworkError.code === 'FST_ERR_VALIDATION' || frameworkError.validation) { //
      const validationDetails = frameworkError.validation?.map(vErr => ({
        field: vErr.dataPath || vErr.instancePath || 'N/A', // dataPath for ajv v6, instancePath for v7+
        message: vErr.message,
        keyword: vErr.keyword,
        params: vErr.params,
      }));
      const validationError = new ValidationError(
        ErrorCodes.VALIDATION.SCHEMA_MISMATCH || 'SCHEMA_MISMATCH', // Using a defined code
        frameworkError.message || 'Request validation failed.',
        { validationErrors: validationDetails || [], rawFastifyValidation: frameworkError.validation },
        { cause: frameworkError }
      );
      validationError.statusCode = frameworkError.statusCode || 400;
      return validationError;
    }

    // Handle Fastify's Not Found errors (FST_ERR_NOT_FOUND)
    if (frameworkError.code === 'FST_ERR_NOT_FOUND' || frameworkError.statusCode === 404) { //
      const path = requestContext?.url || 'unknown path';
      const method = requestContext?.method || 'unknown method';
      const notFoundError = new NetworkError(
        ErrorCodes.NETWORK.ROUTE_NOT_FOUND, //
        `Route ${method} ${path} not found.`,
        { method, path },
        { cause: frameworkError }
      );
      notFoundError.statusCode = 404;
      return notFoundError;
    }

    // Generic error mapping
    const message = frameworkError.message || 'An unexpected error occurred.';
    const details = {
      originalErrorName: frameworkError.name,
      // Avoid exposing raw error in production by default from generic mapping
      ...( (this.errorSystem && this.errorSystem.deps.config?.isDevEnvironment) || // Check dev env via errorSystem config
           (process.env.NODE_ENV === 'development' || process.env.NODE_ENV === 'test')
           ? { rawError: String(frameworkError) } : {} )
    };

    const genericError = new CoreError(
      ErrorCodes.CORE.UNKNOWN_ERROR, //
      message,
      details,
      { cause: frameworkError }
    );
    genericError.statusCode = typeof frameworkError.statusCode === 'number' ? frameworkError.statusCode : 500; //
    return genericError;
  }

  /**
   * Serializes a CoreError for an HTTP response.
   * @param {CoreError} coreError - The CoreError instance.
   * @param {object} [requestContext={}] - Context from the HTTP request.
   * @returns {object} The error payload for the HTTP response.
   * @override
   */
  serializeError(coreError, requestContext = {}) { //
    if (coreError instanceof CoreError) {
      const serialized = coreError.toJSON(); //
      // Add minimal, safe request context to the response payload if desired
      return { //
        ...serialized,
        // Only include non-sensitive parts of requestContext if needed for client
        // context: { requestId: requestContext?.requestId } // Example
      };
    }

    // Fallback for non-CoreError (should ideally be caught by mapError)
    this.logger.warn('[FastifyErrorHandler] serializeError received a non-CoreError:', coreError);
    return { //
      name: coreError.name || 'Error',
      code: ErrorCodes.CORE.UNKNOWN_ERROR, //
      message: coreError.message || 'An unexpected error occurred.',
      timestamp: new Date().toISOString(),
      // context: { requestId: requestContext?.requestId }
    };
  }

  /**
   * Optional shutdown logic for the integration.
   */
  async shutdown() {
    this.initialized = false;
    this.logger.info('[FastifyErrorHandler] Shutdown.');
    // No specific resources to release for this basic handler.
  }
}


// src/core/errors/integrations/fastify/FastifyErrorSerializer.js

/**
 * @file FastifyErrorSerializer.js
 * @description Provides a utility for creating a Fastify logger error serializer
 * using a standardized error serialization method.
 */

/**
 * Creates a Fastify logger error serializer object.
 * This is intended to be used when configuring the Fastify logger instance.
 * The provided `serializeMethod` should be the `serializeError` method from an
 * instantiated and configured FastifyErrorHandler.
 *
 * @example
 * // In your Fastify setup:
 * // const errorSystem = await container.resolve('errorSystem');
 * // const fastifyFrameworkInstance = Fastify({ logger: true }); // example
 * // const options = { errorSystem, logger: fastifyFrameworkInstance.log };
 * // const fastifyErrorHandlerInstance = new FastifyErrorHandler(); // ErrorSystem would typically do this
 * // await fastifyErrorHandlerInstance.initialize(fastifyFrameworkInstance, options);
 * //
 * // const fastify = Fastify({
 * //   logger: {
 * //     level: 'info',
 * //     serializers: {
 * //       // Use the serializeError method from your configured FastifyErrorHandler instance
 * //       error: createFastifyLoggerErrorSerializer(fastifyErrorHandlerInstance.serializeError.bind(fastifyErrorHandlerInstance))
 * //     }
 * //   }
 * // });
 *
 * @param {Function} serializeMethod - The method to use for serializing errors.
 * This should typically be `fastifyErrorHandlerInstance.serializeError.bind(fastifyErrorHandlerInstance)`.
 * It's expected to take an error and an optional context, returning a plain object.
 * @returns {{serializer: Function}} A Fastify logger serializer object for errors.
 */
export function createFastifyLoggerErrorSerializer(serializeMethod) {
  if (typeof serializeMethod !== 'function') {
    console.warn('[FastifyErrorSerializer] serializeMethod provided is not a function. Logger might not serialize errors correctly.');
    // Fallback to a very basic serializer
    return {
      serializer: (error) => {
        return {
          message: error.message,
          stack: error.stack,
          code: error.code,
          name: error.name,
          type: Object.prototype.toString.call(error).slice(8, -1)
        };
      }
    };
  }
  return {
    // The serializer function for Fastify logger takes only the error object.
    // Our `serializeError` method takes `(coreError, requestContext = {})`.
    // For logger purposes, requestContext might not be available or relevant.
    // We pass an empty context.
    serializer: (error) => serializeMethod(error, {}),
  };
}

// Note: The original file directly imported a singleton.
// This version is a utility function because FastifyErrorHandler is no longer a singleton.
// The application setup code is responsible for instantiating FastifyErrorHandler
// (likely via ErrorSystem.registerIntegration) and then using its serializeError
// method when configuring Fastify's logger.

// If you want a more direct export similar to the original, and assuming you
// will *always* have a single, globally accessible instance of FastifyErrorHandler
// (which is less aligned with the DI pattern for ErrorSystem managing integrations),
// then that instance would need to be exported from somewhere and imported here.
// The functional approach above is more flexible.


// src/core/errors/integrations/fastify/index.js

/**
 * @file src/core/errors/integrations/fastify/index.js
 * @description Barrel file for exporting Fastify error integration components.
 */

import { FastifyErrorHandler } from './FastifyErrorHandler.js';
import { createFastifyLoggerErrorSerializer } from './FastifyErrorSerializer.js';

export {
  FastifyErrorHandler,
  createFastifyLoggerErrorSerializer
};

// Optional: If you want to export a pre-configured or default setup function
// similar to the original `setupErrorHandler`, you could add it here,
// but it would typically be part of application bootstrap code or a higher-level setup utility.
// For example:
//
// export function setupFastifyErrorHandling(fastifyInstance, errorSystemInstance, loggerInstance) {
//   const handler = new FastifyErrorHandler();
//   handler.initialize(fastifyInstance, { errorSystem: errorSystemInstance, logger: loggerInstance });
//
//   // To configure logger serializer (example, actual logger config is more complex):
//   // if (fastifyInstance.log && fastifyInstance.log.serializers) {
//   //   fastifyInstance.log.serializers.error = createFastifyLoggerErrorSerializer(handler.serializeError.bind(handler));
//   // }
//   return handler; // Return the instance if needed
// }

// The original file [cite: 372] exported `setupErrorHandler` from `handler.js`
// and `errorSerializer` from `serializer.js`.
// Our refactored approach exports the class `FastifyErrorHandler` and the utility
// function `createFastifyLoggerErrorSerializer`. The actual setup (instantiation
// and initialization of FastifyErrorHandler) is now handled by ErrorSystem.registerIntegration
// or directly in the application's Fastify setup code.


// src/core/errors/integrations/index.js

/**
 * @file src/core/errors/integrations/index.js
 * @description Barrel file for exporting error handling integration interfaces and modules.
 */

import { IFrameworkIntegration } from './IFrameworkIntegration.js';
import {
  FastifyErrorHandler,
  createFastifyLoggerErrorSerializer
} from './fastify/index.js'; // Imports from the fastify integration's own index.js

// You would add other integrations here if they existed, e.g.:
// import { ExpressErrorHandler } from './express/index.js';

export {
  IFrameworkIntegration,
  FastifyErrorHandler,
  createFastifyLoggerErrorSerializer,
  // ExpressErrorHandler, // Example if it existed
};

// Optionally, provide a default export if that suits your module consumption pattern,
// though named exports are generally clear for ES Modules.
// export default {
//   IFrameworkIntegration,
//   fastify: {
//     FastifyErrorHandler,
//     createFastifyLoggerErrorSerializer,
//   },
//   // express: { ExpressErrorHandler }
// };


// src/core/errors/types/AccessError.js

/**
 * @file AccessError.js
 * @description Defines errors related to authorization and access control.
 */

import { CoreError } from '../CoreError.js';

/**
 * Represents an error where access to a resource or operation is denied.
 * Typically corresponds to HTTP 403 Forbidden.
 * @extends CoreError
 */
export class AccessError extends CoreError {
  /**
   * Creates a new AccessError instance.
   * @param {string} code - A specific error code for the access issue (e.g., 'INSUFFICIENT_PERMISSIONS').
   * @param {string} message - A human-readable description of the error.
   * @param {object} [details={}] - Additional details about the access error.
   * @param {object} [options={}] - Additional error options, including 'cause'.
   */
  constructor(code, message, details = {}, options = {}) {
    super(`ACCESS_${code}`, message, details, options); // [cite: 374]
    this.statusCode = 403; // [cite: 374]
  }
}


// src/core/errors/types/AuthError.js

/**
 * @file AuthError.js
 * @description Defines errors related to authentication.
 */

import { CoreError } from '../CoreError.js'; // [cite: 375]

/**
 * Represents an error during the authentication process.
 * Typically corresponds to HTTP 401 Unauthorized.
 * @extends CoreError
 */
export class AuthError extends CoreError {
  /**
   * Creates a new AuthError instance.
   * @param {string} code - A specific error code for the authentication issue (e.g., 'INVALID_CREDENTIALS', 'TOKEN_EXPIRED').
   * @param {string} message - A human-readable description of the error.
   * @param {object} [details={}] - Additional details about the authentication error.
   * @param {object} [options={}] - Additional error options, including 'cause'.
   */
  constructor(code, message, details = {}, options = {}) {
    super(`AUTH_${code}`, message, details, options); // [cite: 376]
    this.statusCode = 401; // [cite: 376]
  }
}


// src/core/errors/types/ConfigError.js

/**
 * @file ConfigError.js
 * @description Defines errors related to application configuration.
 */

import { CoreError } from '../CoreError.js'; // [cite: 377]

/**
 * Represents an error encountered during application configuration loading, validation, or access.
 * Typically corresponds to HTTP 500 Internal Server Error.
 * @extends CoreError
 */
export class ConfigError extends CoreError {
  /**
   * Creates a new ConfigError instance.
   * @param {string} code - A specific error code for the configuration issue (e.g., 'MISSING_VARIABLE', 'INVALID_FORMAT').
   * @param {string} message - A human-readable description of the error.
   * @param {object} [details={}] - Additional details about the configuration error.
   * @param {object} [options={}] - Additional error options, including 'cause'.
   */
  constructor(code, message, details = {}, options = {}) {
    super(`CONFIG_${code}`, message, details, options); // [cite: 378]
    this.statusCode = 500; // [cite: 378]
  }
}


// src/core/errors/types/EventError.js

/**
 * @file EventError.js
 * @description Defines errors related to the event system.
 */

import { CoreError } from '../CoreError.js'; // [cite: 379]

/**
 * Represents an error occurring within the event bus or event handling system.
 * Typically corresponds to HTTP 500 Internal Server Error.
 * @extends CoreError
 */
export class EventError extends CoreError {
  /**
   * Creates a new EventError instance.
   * @param {string} code - A specific error code for the event system issue (e.g., 'EMIT_FAILED', 'HANDLER_EXCEPTION').
   * @param {string} message - A human-readable description of the error.
   * @param {object} [details={}] - Additional details about the event system error.
   * @param {object} [options={}] - Additional error options, including 'cause'.
   */
  constructor(code, message, details = {}, options = {}) {
    super(`EVENT_${code}`, message, details, options); // [cite: 380]
    this.statusCode = 500; // [cite: 380]
  }
}


// src/core/errors/types/ModuleError.js

/**
 * @file ModuleError.js
 * @description Defines errors related to the module system.
 */

import { CoreError } from '../CoreError.js'; // [cite: 381]

/**
 * Represents an error occurring within a module or the module management system.
 * Typically corresponds to HTTP 500 Internal Server Error.
 * @extends CoreError
 */
export class ModuleError extends CoreError {
  /**
   * Creates a new ModuleError instance.
   * @param {string} code - A specific error code for the module system issue (e.g., 'LOAD_FAILED', 'DEPENDENCY_MISSING').
   * @param {string} message - A human-readable description of the error.
   * @param {object} [details={}] - Additional details about the module system error.
   * @param {object} [options={}] - Additional error options, including 'cause'.
   */
  constructor(code, message, details = {}, options = {}) {
    super(`MODULE_${code}`, message, details, options); // [cite: 382]
    this.statusCode = 500; // [cite: 382]
  }
}


// src/core/errors/types/NetworkError.js

/**
 * @file NetworkError.js
 * @description Defines errors related to network operations.
 */

import { CoreError } from '../CoreError.js'; // [cite: 383]

/**
 * Represents an error occurring during network communication (e.g., request timeouts, connection issues).
 * Default statusCode is 503 Service Unavailable, but can be overridden by details.statusCode.
 * @extends CoreError
 */
export class NetworkError extends CoreError {
  /**
   * Creates a new NetworkError instance.
   * @param {string} code - A specific error code for the network issue (e.g., 'REQUEST_TIMEOUT', 'CONNECTION_REFUSED').
   * @param {string} message - A human-readable description of the error.
   * @param {object} [details={}] - Additional details about the network error. Can include `details.statusCode` to override default.
   * @param {object} [options={}] - Additional error options, including 'cause'.
   */
  constructor(code, message, details = {}, options = {}) {
    super(`NETWORK_${code}`, message, details, options); // [cite: 384]
    // Original code allowed details.statusCode to override. We'll keep this behavior.
    this.statusCode = (details && typeof details.statusCode === 'number') ? details.statusCode : 503; // [cite: 384, 385]
  }
}


// src/core/errors/types/RouterError.js

/**
 * @file RouterError.js
 * @description Defines errors related to the routing system.
 */
import { CoreError } from '../CoreError.js';

/**
 * Represents an error occurring within the routing system (e.g., route not found, registration conflict).
 * Typically corresponds to HTTP 500 Internal Server Error for system issues, or others depending on context.
 * @extends CoreError
 */
export class RouterError extends CoreError {
  /**
   * Creates a new RouterError instance.
   * @param {string} code - A specific error code for the router system issue (e.g., 'ROUTE_NOT_FOUND', 'INVALID_ADAPTER').
   * @param {string} message - A human-readable description of the error.
   * @param {object} [details={}] - Additional details about the router system error.
   * @param {object} [options={}] - Additional error options, including 'cause'.
   */
  constructor(code, message, details = {}, options = {}) {
    super(`ROUTER_${code}`, message, details, options); // [cite: 386]
    this.statusCode = 500; // [cite: 386]
  }
}

// The original file also had 'export default RouterError;' which is fine if only this class is in the file.
// For consistency with other error types, a named export is sufficient if it's part of an index.js barrel file.


// src/core/errors/types/ServiceError.js

/**
 * @file ServiceError.js
 * @description Defines errors related to service-level operations.
 */

import { CoreError } from '../CoreError.js'; // [cite: 387]

/**
 * Represents an error occurring within a service or a dependency it relies on.
 * Typically corresponds to HTTP 503 Service Unavailable.
 * @extends CoreError
 */
export class ServiceError extends CoreError {
  /**
   * Creates a new ServiceError instance.
   * @param {string} code - A specific error code for the service issue (e.g., 'DATABASE_UNAVAILABLE', 'EXTERNAL_API_FAILED').
   * @param {string} message - A human-readable description of the error.
   * @param {object} [details={}] - Additional details about the service error.
   * @param {object} [options={}] - Additional error options, including 'cause'.
   */
  constructor(code, message, details = {}, options = {}) {
    super(`SERVICE_${code}`, message, details, options); // [cite: 388]
    this.statusCode = 503; // [cite: 388]
  }
}


// src/core/errors/types/ValidationError.js

/**
 * @file ValidationError.js
 * @description Defines errors related to data validation.
 */

import { CoreError } from '../CoreError.js'; // [cite: 389]

/**
 * Represents an error that occurs when input data fails validation.
 * Typically corresponds to HTTP 400 Bad Request.
 * @extends CoreError
 */
export class ValidationError extends CoreError {
  /**
   * Creates a new ValidationError instance.
   * @param {string} code - A specific error code for the validation issue (e.g., 'INVALID_INPUT', 'SCHEMA_MISMATCH').
   * @param {string} message - A human-readable description of the error.
   * @param {object} [details={}] - Additional details, expected to contain a `validationErrors` array.
   * @param {Array<object>} [details.validationErrors=[]] - An array of specific validation failure objects (e.g., { field, message }).
   * @param {object} [options={}] - Additional error options, including 'cause'.
   */
  constructor(code, message, details = {}, options = {}) {
    super(`VALIDATION_${code}`, message, details, options); // [cite: 390]
    this.statusCode = 400; // [cite: 390]
    // Ensure validationErrors is always an array, even if not provided or malformed in details.
    this.validationErrors = Array.isArray(details?.validationErrors) ? details.validationErrors : []; // [cite: 391]
  }

  /**
   * Converts the error object to a JSON representation, including `validationErrors`.
   * @returns {object} A plain object representation of the error.
   */
  toJSON() {
    const json = super.toJSON(); //
    json.validationErrors = this.validationErrors; // [cite: 392]
    return json;
  }

  /**
   * Creates a ValidationError instance from a JSON-like object.
   * @static
   * @param {object} data - The plain object containing error data.
   * @returns {ValidationError} An instance of ValidationError.
   */
  static fromJSON(data) {
    const errorInstance = super.fromJSON(data, ValidationError); // Pass ValidationError as the type
    // Ensure validationErrors is an array after deserialization.
    errorInstance.validationErrors = Array.isArray(data?.validationErrors) ? data.validationErrors : []; // [cite: 393]
    return errorInstance;
  }
}


// src/core/errors/types/index.js

/**
 * @file src/core/errors/types/index.js
 * @description Barrel file for exporting all specific CoreError subclasses
 * and an ErrorTypes namespace object.
 */

import { AccessError } from './AccessError.js';
import { AuthError } from './AuthError.js';
import { ConfigError } from './ConfigError.js';
import { EventError } from './EventError.js';
import { ModuleError } from './ModuleError.js';
import { NetworkError } from './NetworkError.js';
import { RouterError } from './RouterError.js';
import { ServiceError } from './ServiceError.js';
import { ValidationError } from './ValidationError.js';

// Export individual error types for direct import
export {
  AccessError,
  AuthError,
  ConfigError,
  EventError,
  ModuleError,
  NetworkError,
  RouterError,
  ServiceError,
  ValidationError,
};

// Create and export the ErrorTypes namespace object
// This provides a convenient way to access error types, similar to the original.
export const ErrorTypes = Object.freeze({
  AccessError,
  AuthError,
  ConfigError,
  EventError,
  ModuleError,
  NetworkError,
  RouterError,
  ServiceError,
  ValidationError,
});

// Optionally, make ErrorTypes the default export if desired,
// though named exports are common for ES Modules.
// The original had 'export default ErrorTypes;' [cite: 400] which is also fine.
// For consistency with how we are handling other index files that export multiple things,
// sticking to named exports for `ErrorTypes` might be cleaner unless a default is strongly preferred.


// src/core/event/CoreEventBus.js

/**
 * @file CoreEventBus.js
 * @description Centralized event bus for robust event management, queuing, and history.
 */

import { EventEmitter } from 'events'; // Node.js built-in
import { EventError } from '../errors/index.js'; // Assuming errors/index.js exports EventError
import { ErrorCodes } from '../errors/ErrorCodes.js'; // Assuming ErrorCodes are in their own file
import { SYSTEM_STATUS, LIFECYCLE_EVENTS, DEFAULT_CONFIG } from '../common/SystemConstants.js';
import { safeHandleError, createStandardHealthCheckResult } from '../common/ErrorUtils.js';

// Assuming crypto.randomUUID is available (Node.js 15.6.0+, or use a polyfill/library for broader compatibility)
// For older Node or browsers, you might need a library like 'uuid'.
// const { v4: uuidv4 } = require('uuid'); // Example if using uuid library

export class CoreEventBus extends EventEmitter {
  static dependencies = ['errorSystem', 'config']; // [cite: 401]
  static version = '2.0.0'; // Example version bump

  /**
   * Creates a new CoreEventBus instance.
   * @param {object} [deps={}] - Dependencies for the CoreEventBus.
   * @param {object} [deps.errorSystem] - The ErrorSystem instance.
   * @param {object} [deps.config={}] - Configuration object.
   */
  constructor(deps = {}) { // [cite: 402]
    super();
    this.deps = {
      errorSystem: deps.errorSystem,
      config: deps.config || {},
    };

    this.queues = new Map(); // [cite: 402]
    this.subscriptions = new Map(); // [cite: 402]
    this.history = new Map(); // [cite: 403]
    this.maxHistorySize = this.deps.config?.eventBus?.maxHistorySize || // Adjusted config path
                          this.deps.config?.eventHistory?.maxSize || // Kept original for compatibility
                          DEFAULT_CONFIG.MAX_ERROR_HISTORY; // Default if none specified
    // this.initialized is now driven by this.state.status

    this.state = {
      status: SYSTEM_STATUS.CREATED,
      startTime: null,
      errors: [], // For internal errors of CoreEventBus
      metrics: new Map(),
      healthChecks: new Map(),
    }; // [cite: 404]

    this._originalEmit = null; // For wildcard forwarding
    this._processingNewListener = false; // Guard for newListener recursion

    this.setupDefaultHealthChecks(); // [cite: 405]
    this._setupInternalListeners(); // Setup newListener/removeListener logic
  }

  /**
   * Sets up internal listeners for managing wildcard forwarding.
   * @private
   */
  _setupInternalListeners() {
    this.on('newListener', (eventName, listener) => {
      if (this._processingNewListener) return;
      this._processingNewListener = true;
      try {
        const eventNameStr = typeof eventName === 'string' ? eventName : String(eventName);
        if (eventNameStr === '*') { // [cite: 428, 429]
          this._enableWildcardForwarding(); // [cite: 429]
        }
      } finally {
        this._processingNewListener = false;
      }
    });

    this.on('removeListener', (eventName) => {
      const eventNameStr = typeof eventName === 'string' ? eventName : String(eventName);
      if (eventNameStr === '*' && this.listenerCount('*') === 0) { // [cite: 430]
        this._disableWildcardForwarding(); // [cite: 430]
      }
    });
  }

  /**
   * Handles internal operational errors of the CoreEventBus.
   * @private
   */
  async _handleInternalError(error, context = {}) {
    const errorToLog = !(error instanceof EventError)
      ? new EventError(ErrorCodes.EVENT.INTERNAL_ERROR || 'INTERNAL_ERROR', error.message, context, { cause: error })
      : error;

    this.state.errors.push({ error: errorToLog, timestamp: new Date().toISOString(), context });
    if (this.state.errors.length > (this.deps.config?.eventBus?.maxErrorHistory || DEFAULT_CONFIG.MAX_ERROR_HISTORY)) {
      this.state.errors.shift();
    }
    this.recordMetric('eventbus.errors.internal', 1, { errorName: errorToLog.name, errorCode: errorToLog.code });
    await safeHandleError(this.deps.errorSystem, errorToLog, { source: 'CoreEventBus', ...context });
  }

  /**
   * Initializes the CoreEventBus.
   * @returns {Promise<CoreEventBus>}
   */
  async initialize() {
    if (this.state.status === SYSTEM_STATUS.RUNNING || this.state.status === SYSTEM_STATUS.INITIALIZING) {
      const err = new EventError(ErrorCodes.EVENT.ALREADY_INITIALIZED, 'CoreEventBus is already initialized or initializing.'); // [cite: 425]
      await this._handleInternalError(err, { currentStatus: this.state.status });
      return this;
    }

    this.emit(LIFECYCLE_EVENTS.INITIALIZING, { system: 'CoreEventBus' });
    this.state.status = SYSTEM_STATUS.INITIALIZING; // [cite: 426]
    this.state.startTime = Date.now(); // [cite: 427]

    try {
      // Wildcard forwarding setup is now handled by newListener/removeListener
      this.state.status = SYSTEM_STATUS.RUNNING; // [cite: 431]
      this.recordMetric('eventbus.initialized.success', 1, { timestamp: Date.now() });
      // Emit system:initialized AFTER this.emit is potentially wrapped by wildcard forwarding
      // to ensure system:initialized can also be caught by a wildcard if needed.
      // However, system events are often special. The current emit logic forwards non-"*" events.
      // Let's emit system events directly using super.emit if this.emit is wrapped,
      // or ensure system events are not doubly processed by wildcard if not desired.
      // For now, standard emit:
      this.emit(LIFECYCLE_EVENTS.INITIALIZED, { system: 'CoreEventBus', timestamp: new Date().toISOString() }); // [cite: 431]
      this.emit(LIFECYCLE_EVENTS.RUNNING, { system: 'CoreEventBus', timestamp: new Date().toISOString() });


    } catch (error) {
      this.state.status = SYSTEM_STATUS.ERROR; // [cite: 432]
      this.recordMetric('eventbus.initialized.failure', 1, { error: error.code, timestamp: Date.now() }); // [cite: 434]
      // The original code had `await this.handleError(error)` here, which is for external errors.
      // For init errors, use _handleInternalError.
      await this._handleInternalError(error, { phase: 'initialization' }); // [cite: 434]
      throw error instanceof EventError ? error : new EventError( // [cite: 434]
        ErrorCodes.EVENT.INITIALIZATION_FAILED, // [cite: 434]
        'CoreEventBus failed to initialize.', // [cite: 434]
        { originalMessage: error.message }, // [cite: 434]
        { cause: error } // [cite: 434]
      );
    }
    return this;
  }

  /**
   * Enables wildcard event forwarding by wrapping the emit method.
   * @private
   */
  _enableWildcardForwarding() {
    if (this._originalEmit) return; // Already enabled [cite: 417]
    this._originalEmit = super.emit; // Store the original EventEmitter.emit [cite: 418]

    // Replace the emit method of this instance
    // Note: We are replacing `this.emit` which is inherited from EventEmitter's prototype.
    // This instance's `emit` will now be this new function.
    // Calls to `super.emit()` inside this new function will call the original EventEmitter.emit.
    const newEmit = (eventName, ...args) => {
      // Call original emit for the specific event
      // The first argument to `_originalEmit` should be `this` (the CoreEventBus instance)
      const result = this._originalEmit.call(this, eventName, ...args); // [cite: 419]

      // Forward to wildcard handlers ('*') if the eventName itself is not '*'
      // CRITICAL FIX: Pass the actual arguments received by this emit, not re-parsing.
      // If args[0] is the wrapped event object, that's what we forward.
      if (eventName !== '*' && this.listenerCount('*') > 0) { // [cite: 420]
          // Wildcard listeners expect the event object as their first argument.
          // And the event name as the "emitted" event for the wildcard listener.
          // So, emit the event `*` with arguments `(originalEventName, actualEventPayloadObject)`
          // OR, emit `*` with argument `(actualEventPayloadObject)` which also has `actualEventPayloadObject.name`.
          // Let's align with the latter for simplicity for the wildcard handler.
          // The actualEventPayloadObject is typically args[0] for our wrapped events.
        if (args.length > 0 && typeof args[0] === 'object' && args[0] !== null && args[0].id && args[0].name) {
            this._originalEmit.call(this, '*', args[0]); // Forward the full event object [cite: 420]
        } else {
            // This case implies a non-standard event emission not using our wrapped event object.
            // Or it's a system event not following the pattern.
            // For now, maintain previous behavior if event object isn't found.
            this._originalEmit.call(this, '*', eventName, ...args);
        }
      }
      return result;
    };
    this.emit = newEmit;

    this.recordMetric('eventbus.wildcard.enabled', 1); // [cite: 422]
  }

  /**
   * Disables wildcard event forwarding by restoring the original emit method.
   * @private
   */
  _disableWildcardForwarding() {
    if (!this._originalEmit) return; // [cite: 422]
    this.emit = this._originalEmit; // Restore original EventEmitter.emit [cite: 423]
    this._originalEmit = null; // [cite: 423]
    this.recordMetric('eventbus.wildcard.disabled', 1); // [cite: 424]
  }

  /**
   * Emits an event with queuing, history, and pattern matching.
   * @param {string} eventName - Event name.
   * @param {*} data - Event data.
   * @param {object} [options={}] - Emission options (e.g., queue, metadata).
   * @returns {Promise<boolean>} Whether the event had listeners (or was queued).
   */
  async emit(eventName, data, options = {}) { // This is the public emit, potentially wrapped
    if (typeof eventName !== 'string' || !eventName.trim()) { // [cite: 439]
      const err = new EventError(
        ErrorCodes.EVENT.INVALID_EVENT_NAME, // [cite: 440]
        'Event name must be a non-empty string.', // [cite: 440]
        { providedEventName: eventName } // [cite: 440]
      );
      await this._handleInternalError(err, { eventName, data, options });
      throw err;
    }

    const eventId = global.crypto && typeof global.crypto.randomUUID === 'function'
                    ? global.crypto.randomUUID() // For Node.js
                    : Math.random().toString(36).substring(2) + Date.now().toString(36); // Basic fallback

    const event = { // [cite: 441]
      id: eventId, // [cite: 441]
      name: eventName, // [cite: 441]
      data, // [cite: 441]
      timestamp: new Date().toISOString(), // [cite: 441]
      metadata: options.metadata || {}, // [cite: 441]
    };

    try {
      this.trackEvent(event); // [cite: 442]
      this.recordMetric('eventbus.events.emitted', 1, { eventName, queued: !!options.queue }); // [cite: 443]

      if (options.queue) { // [cite: 444]
        await this.queueEvent(event, options); // [cite: 444] Changed to await
        return true; // Event was queued
      }

      // Use super.emit (or this._originalEmit if wrapped) to call the actual EventEmitter emit
      const emitFn = this._originalEmit || super.emit;
      return emitFn.call(this, eventName, event); // Pass the wrapped event object [cite: 445]

    } catch (error) {
      // This catch is for errors during the emit process itself (e.g. history, queueing)
      // not for errors thrown by listeners (those are handled by EventEmitter).
      await this._handleInternalError(error, { eventName, eventId: event.id, options }); // [cite: 446]
      throw error instanceof EventError ? error : new EventError( // [cite: 447]
        ErrorCodes.EVENT.EMISSION_FAILED, // [cite: 447]
        `Failed to emit event: ${eventName}`, // [cite: 447]
        { eventName, eventId: event.id, options }, // [cite: 447]
        { cause: error } // [cite: 447]
      );
    }
  }

  /**
   * Subscribes to events matching a pattern.
   * @param {string} pattern - Event pattern (e.g., 'user.created', 'item.*', '*').
   * @param {Function} handler - Async function to handle the event: async (event) => {}.
   * @param {object} [options={}] - Subscription options.
   * @returns {string} Subscription ID.
   */
  subscribe(pattern, handler, options = {}) { // [cite: 448]
    if (typeof pattern !== 'string' || !pattern.trim()) { // [cite: 448]
      const err = new EventError(ErrorCodes.EVENT.INVALID_PATTERN, 'Event pattern must be a non-empty string.', { pattern }); // [cite: 449]
      this._handleInternalError(err); // Log, then throw
      throw err;
    }
    if (typeof handler !== 'function') { // [cite: 450]
      const err = new EventError(ErrorCodes.EVENT.INVALID_HANDLER, 'Event handler must be a function.', { pattern }); // [cite: 450]
      this._handleInternalError(err);
      throw err;
    }

    const subscriptionId = global.crypto && typeof global.crypto.randomUUID === 'function'
                        ? global.crypto.randomUUID()
                        : Math.random().toString(36).substring(2) + Date.now().toString(36);

    const subscription = { // [cite: 451]
      id: subscriptionId, // [cite: 451]
      pattern, // [cite: 451]
      handler, // [cite: 451]
      options: options || {}, // [cite: 451]
      created: new Date().toISOString(), // [cite: 451]
      // internalHandler will store the actual function passed to EventEmitter.on
    }; //

    try {
      if (pattern === '*') { // [cite: 453]
        // Wildcard handler receives the full event object as its first argument
        subscription.internalHandler = (event) => handler(event); // [cite: 453]
        super.on('*', subscription.internalHandler); // [cite: 454]
      } else if (pattern.includes('*')) {
        const regexPattern = new RegExp('^' + pattern.replace(/\./g, '\\.').replace(/\*/g, '.*') + '$'); // More robust regex
        // Pattern handlers also receive the full event object
        subscription.internalHandler = (event) => { // [cite: 455]
          // The event argument here comes from the wildcard emit: emit('*', fullEventObject)
          if (event && typeof event.name === 'string' && regexPattern.test(event.name)) { // [cite: 455]
            handler(event); // [cite: 456]
          }
        };
        super.on('*', subscription.internalHandler); // Listen on wildcard, filter by name [cite: 456]
      } else {
        // Direct match, handler receives the full event object
        subscription.internalHandler = (event) => handler(event);
        super.on(pattern, subscription.internalHandler); // [cite: 452]
      }

      this.subscriptions.set(subscription.id, subscription); //
      this.recordMetric('eventbus.subscriptions.added', 1, { pattern }); // [cite: 457]
      return subscription.id; // [cite: 458]
    } catch (error) {
      // Use _handleInternalError for subscription setup issues
      await this._handleInternalError(error, { phase: 'subscribe', pattern }); // [cite: 458]
      throw error instanceof EventError ? error : new EventError( // [cite: 459]
        ErrorCodes.EVENT.SUBSCRIPTION_FAILED, // [cite: 459]
        `Failed to subscribe to pattern: ${pattern}`, // [cite: 459]
        { pattern }, // [cite: 459]
        { cause: error } // [cite: 459]
      );
    }
  }

  /**
   * Unsubscribes from events.
   * @param {string} subscriptionId - The ID returned by subscribe.
   * @returns {boolean} True if unsubscribed, false otherwise.
   */
  unsubscribe(subscriptionId) { // [cite: 460]
    const subscription = this.subscriptions.get(subscriptionId); // [cite: 460]
    if (!subscription) { // [cite: 461]
      // Don't throw if not found, just return false or log a warning
      this.deps.logger?.warn(`[CoreEventBus] Unsubscribe failed: Subscription ID '${subscriptionId}' not found.`);
      return false;
    }

    try {
      const { pattern, internalHandler } = subscription; // [cite: 462]
      if (pattern.includes('*')) { // [cite: 464, 465, 468]
        super.removeListener('*', internalHandler); // [cite: 465, 466, 468]
      } else {
        super.removeListener(pattern, internalHandler); // [cite: 463, 467]
      }

      this.subscriptions.delete(subscriptionId); // [cite: 469]
      this.recordMetric('eventbus.subscriptions.removed', 1, { pattern: subscription.pattern }); // [cite: 470]
      return true; // [cite: 471]
    } catch (error) {
      await this._handleInternalError(error, { phase: 'unsubscribe', subscriptionId }); // [cite: 471]
      // We might not want to re-throw an EventError here if the primary goal (removing from map) succeeded.
      // However, if removeListener failed, it's an internal issue.
      // For now, let's not escalate to EventError unless the error is from EventEmitter itself.
      if (!(error instanceof EventError)) {
          this.deps.logger?.error(`[CoreEventBus] Error during removeListener for ${subscriptionId}: ${error.message}`);
      }
      return false; // Indicate potential issue
    }
  }

  /**
   * Adds an event to a named queue for later processing.
   * @param {object} event - The full event object.
   * @param {object} [options={}] - Queuing options (e.g., immediate).
   * @returns {Promise<boolean>} True if queued successfully.
   */
  async queueEvent(event, options = {}) { // [cite: 473]
    try {
      const queueName = event.name;
      const queue = this.queues.get(queueName) || []; // [cite: 474]
      const queueItem = { event, options, timestamp: new Date().toISOString() }; // [cite: 474]
      queue.push(queueItem); // [cite: 475]
      this.queues.set(queueName, queue); // [cite: 475]

      this.recordMetric('eventbus.events.queued', 1, { eventName: queueName, queueSize: queue.length }); // [cite: 475]

      if (options.immediate) { // [cite: 476]
        await this.processQueue(queueName); // [cite: 476]
      }
      return true; //
    } catch (error) {
      await this._handleInternalError(error, { phase: 'queueEvent', eventName: event.name }); // [cite: 477]
      throw error instanceof EventError ? error : new EventError( // [cite: 478]
        ErrorCodes.EVENT.QUEUE_OPERATION_FAILED || 'QUEUE_OPERATION_FAILED', // Assuming new code [cite: 478]
        `Failed to queue event: ${event.name}`, // [cite: 478]
        { eventName: event.name }, // [cite: 478]
        { cause: error } // [cite: 478]
      );
    }
  }

  /**
   * Processes all events in a named queue.
   * @param {string} queueName - The name of the queue to process.
   * @returns {Promise<number>} The number of events processed.
   */
  async processQueue(queueName) { // [cite: 479]
    const queue = this.queues.get(queueName) || []; // [cite: 480]
    if (queue.length === 0) return 0;

    let processedCount = 0;
    const startTime = Date.now();
    const BATCH_SIZE = this.deps.config?.eventBus?.queueBatchSize || 100; // Process in batches

    // Process only up to BATCH_SIZE to prevent blocking for too long if queue is huge
    const itemsToProcess = queue.splice(0, Math.min(queue.length, BATCH_SIZE));

    for (const { event } of itemsToProcess) { // [cite: 481]
      try {
        // Use super.emit or _originalEmit to bypass this instance's emit logic (like queuing again)
        const emitFn = this._originalEmit || super.emit;
        emitFn.call(this, event.name, event); // Emit the full event object [cite: 481]
        processedCount++; // [cite: 481]
      } catch (handlerError) {
        // Error thrown by a listener during the emit. This is an application error, not an EventBus error.
        // We should report it via the main ErrorSystem.
        const appError = new EventError(
          ErrorCodes.EVENT.HANDLER_ERROR, // [cite: 482]
          `Error in handler for event: ${event.name} (ID: ${event.id}) during queue processing.`, // [cite: 482]
          { eventName: event.name, eventId: event.id }, // [cite: 482]
          { cause: handlerError } // [cite: 482]
        );
        // Use the public handleError which forwards to ErrorSystem
        await this.handleError(appError, { phase: 'processQueue-handler', queueName, eventId: event.id });
        // Continue processing other events in the batch
      }
    }

    this.recordMetric('eventbus.queue.processed', processedCount, { queueName, processingTimeMs: Date.now() - startTime }); // [cite: 484]
    if (queue.length > 0) {
        this.recordMetric('eventbus.queue.remaining', queue.length, { queueName });
    }
    return processedCount; // [cite: 485]
  }

  /**
   * Public error handler to be used by event listeners if they want to report errors
   * through the EventBus's configured ErrorSystem.
   * @param {Error} error - The error object from the event listener.
   * @param {object} [context={}] - Context from the event listener.
   */
  async handleError(error, context = {}) { // [cite: 435]
    // This is the public method for listeners to report their errors.
    // It should use safeHandleError to forward to the configured ErrorSystem.
    this.recordMetric('eventbus.errors.reported_by_listener', 1, { errorName: error.name, errorCode: error.code });
    await safeHandleError(this.deps.errorSystem, error, { source: 'CoreEventBusListener', ...context }); // [cite: 438]
  }


  /**
   * Processes all events in all queues.
   * @returns {Promise<Object.<string, number>>} An object mapping queue names to processed counts.
   */
  async processAllQueues() { // [cite: 487]
    const results = {}; // [cite: 488]
    const queueNames = Array.from(this.queues.keys()); // [cite: 488]
    let totalProcessed = 0;

    for (const queueName of queueNames) { // [cite: 489]
      try {
        results[queueName] = await this.processQueue(queueName); // [cite: 489]
        totalProcessed += results[queueName];
      } catch (error) {
        // _handleInternalError for errors in the processQueue logic itself
        await this._handleInternalError(error, { phase: 'processAllQueues', queueName }); // [cite: 490]
        // Don't rethrow here to allow other queues to be processed. Error is logged.
        results[queueName] = 0; // Mark as 0 processed for this queue due to error
      }
    }
    this.recordMetric('eventbus.all_queues.processed_total', totalProcessed);
    return results; //
  }

  trackEvent(event) { // [cite: 491]
    const eventHistoryQueue = this.history.get(event.name) || []; // [cite: 492]
    eventHistoryQueue.unshift(event); // [cite: 492]
    if (eventHistoryQueue.length > this.maxHistorySize) { // [cite: 492]
      eventHistoryQueue.pop(); // [cite: 493]
    }
    this.history.set(event.name, eventHistoryQueue); // [cite: 493]
    this.recordMetric('eventbus.history.size', eventHistoryQueue.length, { eventName: event.name }); // [cite: 494]
  }

  getHistory(eventName, options = {}) { // [cite: 494]
    const historyQueue = this.history.get(eventName) || []; // [cite: 495]
    if (options.limit && options.limit > 0) { // [cite: 495]
      return historyQueue.slice(0, options.limit); // [cite: 496]
    }
    return [...historyQueue]; // Return a copy [cite: 496]
  }

  getAllHistory(options = {}) { // [cite: 497]
    const result = {}; // [cite: 497]
    for (const [eventName, historyQueue] of this.history) { // [cite: 497]
      result[eventName] = options.limit ? historyQueue.slice(0, options.limit) : [...historyQueue]; // [cite: 498]
    }
    return result; // [cite: 499]
  }

  async reset() { // [cite: 499]
    this.queues.clear(); // [cite: 500]
    this.history.clear(); // [cite: 500]
    // Remove only non-system listeners. Our internal 'newListener'/'removeListener' should stay.
    const eventNames = super.eventNames().filter( // [cite: 500]
      (name) => name !== 'newListener' && name !== 'removeListener' && !name.startsWith('system:')
    );
    for (const eventName of eventNames) { // [cite: 501]
      super.removeAllListeners(eventName); // [cite: 501]
    }
    this.subscriptions.clear(); // Clear our tracking of subscriptions
    this.recordMetric('eventbus.reset', 1); // [cite: 502]
    // Wildcard forwarding might need to be explicitly disabled if this.emit was wrapped
    if (this._originalEmit) {
        this._disableWildcardForwarding();
    }
  }

  async shutdown() { // [cite: 503]
    if (this.state.status === SYSTEM_STATUS.SHUTDOWN || this.state.status === SYSTEM_STATUS.SHUTTING_DOWN) { // [cite: 503]
      return;
    }
    this.emit(LIFECYCLE_EVENTS.SHUTTING_DOWN, { system: 'CoreEventBus' });
    this.state.status = SYSTEM_STATUS.SHUTTING_DOWN; // [cite: 504]

    try {
      await this.reset(); // [cite: 504]
      super.removeAllListeners(); // Remove ALL listeners, including internal ones [cite: 506]

      this.state.status = SYSTEM_STATUS.SHUTDOWN; // [cite: 504]
      this.state.startTime = null;
      this.recordMetric('eventbus.shutdown.success', 1, { timestamp: Date.now() }); // [cite: 507]
      // Cannot emit shutdown if all listeners are removed. Log instead.
      this.deps.logger?.info('[CoreEventBus] Shutdown complete.');

    } catch (error) {
      this.state.status = SYSTEM_STATUS.ERROR; // [cite: 508]
      this.recordMetric('eventbus.shutdown.failure', 1, { error: error.code, timestamp: Date.now() }); // [cite: 509]
      // Use console.error as this is a critical failure during event bus shutdown
      console.error('[CoreEventBus] Shutdown failed:', error); // [cite: 509]
      // Do not re-throw from EventBus shutdown itself unless absolutely necessary
    }
  }

  // --- Health Checks & Metrics ---
  setupDefaultHealthChecks() { // [cite: 405]
    this.registerHealthCheck('eventbus.state', this.checkSystemState.bind(this)); // [cite: 406]
    this.registerHealthCheck('eventbus.queues', this.checkQueueStatus.bind(this)); // [cite: 407]
    this.registerHealthCheck('eventbus.subscriptions', this.checkSubscriptionStatus.bind(this)); // [cite: 409]
  }

  recordMetric(name, value, tags = {}) { // [cite: 416]
    this.state.metrics.set(name, { value, timestamp: Date.now(), tags }); // [cite: 417]
  }

  getMetrics() {
    const metrics = {};
    for (const [name, data] of this.state.metrics) {
      metrics[name] = data;
    }
    return metrics;
  }

  registerHealthCheck(name, checkFn) { // [cite: 410]
    if (typeof checkFn !== 'function') {
      const err = new EventError(ErrorCodes.EVENT.INVALID_HANDLER, `Health check '${name}' must be a function.`); // [cite: 411]
      this._handleInternalError(err); // Log, but rethrow as it's a programming error
      throw err;
    }
    this.state.healthChecks.set(name, checkFn); // [cite: 411]
  }

  async checkHealth() { // [cite: 411]
    const results = {}; // [cite: 412]
    let overallStatus = SYSTEM_STATUS.HEALTHY; // [cite: 412]

    for (const [name, checkFn] of this.state.healthChecks) { // [cite: 412]
      try {
        const checkResult = await checkFn(); // Expects { status, detail, errors } [cite: 412]
        results[name] = checkResult; // [cite: 412]
        if (checkResult.status !== SYSTEM_STATUS.HEALTHY) { // [cite: 413]
          overallStatus = (overallStatus === SYSTEM_STATUS.HEALTHY) ? SYSTEM_STATUS.DEGRADED : SYSTEM_STATUS.UNHEALTHY; // [cite: 413]
          if (checkResult.status === SYSTEM_STATUS.UNHEALTHY) overallStatus = SYSTEM_STATUS.UNHEALTHY; // [cite: 414]
        }
      } catch (error) {
        results[name] = createStandardHealthCheckResult(SYSTEM_STATUS.UNHEALTHY, { error: 'Health check threw an exception' }, [error]); // [cite: 414]
        overallStatus = SYSTEM_STATUS.UNHEALTHY; // [cite: 415]
      }
    }
    return { // [cite: 415]
      name: this.constructor.name, // [cite: 415]
      version: CoreEventBus.version, // [cite: 415]
      status: overallStatus, // [cite: 415]
      timestamp: new Date().toISOString(), // [cite: 415]
      uptime: this.state.startTime ? Date.now() - this.state.startTime : 0,
      errorCount: this.state.errors.length,
      checks: results, // [cite: 415]
    };
  }

  async checkSystemState() { // [cite: 406]
    return createStandardHealthCheckResult(
      this.state.status === SYSTEM_STATUS.RUNNING ? SYSTEM_STATUS.HEALTHY : SYSTEM_STATUS.UNHEALTHY,
      { // [cite: 406]
        status: this.state.status, // [cite: 407]
        uptime: this.state.startTime ? Date.now() - this.state.startTime : 0, // [cite: 407]
        internalErrorCount: this.state.errors.length // [cite: 407]
      }
    );
  }

  async checkQueueStatus() { // [cite: 407]
    const queueCounts = {}; // [cite: 407]
    let totalQueuedEvents = 0; // [cite: 407]
    this.queues.forEach((queue, key) => { // [cite: 408]
      queueCounts[key] = queue.length; // [cite: 408]
      totalQueuedEvents += queue.length; // [cite: 408]
    });
    return createStandardHealthCheckResult(SYSTEM_STATUS.HEALTHY, { // [cite: 408]
      queueCount: this.queues.size, // [cite: 408]
      totalQueuedEvents, // [cite: 408]
      queues: queueCounts, // [cite: 408]
    });
  }

  async checkSubscriptionStatus() { // [cite: 409]
    return createStandardHealthCheckResult(SYSTEM_STATUS.HEALTHY, { // [cite: 409]
      count: this.subscriptions.size, // [cite: 409]
      patterns: Array.from(this.subscriptions.values()).map(s => s.pattern), // [cite: 409]
    });
  }

   getSystemStatus() { // For consistency
    return {
        name: this.constructor.name,
        version: CoreEventBus.version,
        status: this.state.status,
        uptime: this.state.startTime ? Date.now() - this.state.startTime : 0,
        initialized: this.state.status === SYSTEM_STATUS.RUNNING,
        errorCount: this.state.errors.length,
        timestamp: new Date().toISOString()
    };
  }
}

/**
 * Factory function for creating a CoreEventBus instance.
 * @param {object} [deps={}] - Dependencies for the CoreEventBus.
 * @returns {CoreEventBus}
 */
export function createEventBus(deps = {}) { // [cite: 510]
  return new CoreEventBus(deps); // [cite: 511]
}


// src/core/event/EventBusSystem.js

/**
 * @file EventBusSystem.js
 * @description Manages the CoreEventBus and provides system-level eventing capabilities.
 */

import { EventEmitter } from 'events';
import { CoreEventBus } from './CoreEventBus.js';
import { EventError } from '../errors/index.js'; // Assuming errors/index.js exports EventError
import { ErrorCodes } from '../errors/ErrorCodes.js';
import { SYSTEM_STATUS, LIFECYCLE_EVENTS, DEFAULT_CONFIG } from '../common/SystemConstants.js';
import { safeHandleError, createStandardHealthCheckResult } from '../common/ErrorUtils.js';

export class EventBusSystem extends EventEmitter {
  static dependencies = ['errorSystem', 'config']; //
  static version = '2.0.0'; // Example version bump

  /**
   * Creates a new EventBusSystem instance.
   * @param {object} [deps={}] - Dependencies for the EventBusSystem.
   * @param {object} [deps.errorSystem] - The ErrorSystem instance.
   * @param {object} [deps.config={}] - Configuration object.
   */
  constructor(deps = {}) { //
    super();
    this.deps = {
      errorSystem: deps.errorSystem, // Will be validated in validateDependencies
      config: deps.config || {},
    };

    this.eventBus = null; // Will be an instance of CoreEventBus
    // this.initialized is now driven by this.state.status
    this._forwardingInitialized = false; // Instance flag for event forwarding setup

    this.state = {
      status: SYSTEM_STATUS.CREATED,
      startTime: null,
      errors: [], // For internal errors of EventBusSystem itself
      metrics: new Map(),
      healthChecks: new Map(),
    }; //

    this.validateDependencies(); // Validate early
    this.setupDefaultHealthChecks(); //
  }

  /**
   * Validates that required dependencies are provided and are valid.
   * @private
   */
  validateDependencies() { //
    const missing = EventBusSystem.dependencies.filter(dep => !this.deps[dep]); //
    if (missing.length > 0) { //
      throw new EventError( // Use EventError for its own domain
        ErrorCodes.EVENT.MISSING_DEPENDENCIES, //
        `EventBusSystem: Missing required dependencies: ${missing.join(', ')}`, //
        { missingDeps: missing } //
      );
    }
    if (this.deps.errorSystem && typeof this.deps.errorSystem.handleError !== 'function') { //
      throw new EventError( //
        ErrorCodes.EVENT.INVALID_DEPENDENCY, //
        'EventBusSystem: ErrorSystem dependency is invalid (missing handleError method).', //
        { dependency: 'errorSystem' } //
      );
    }
  }

  /**
   * Handles internal operational errors of the EventBusSystem.
   * @private
   */
  async _handleInternalError(error, context = {}) {
    const errorToLog = !(error instanceof EventError)
      ? new EventError(ErrorCodes.EVENT.INTERNAL_ERROR || 'INTERNAL_ERROR', error.message, context, { cause: error })
      : error;

    this.state.errors.push({ error: errorToLog, timestamp: new Date().toISOString(), context });
    if (this.state.errors.length > (this.deps.config?.eventBusSystem?.maxErrorHistory || DEFAULT_CONFIG.MAX_ERROR_HISTORY)) {
      this.state.errors.shift();
    }
    this.recordMetric('eventbussystem.errors.internal', 1, { errorName: errorToLog.name, errorCode: errorToLog.code });
    await safeHandleError(this.deps.errorSystem, errorToLog, { source: 'EventBusSystem', ...context });
  }

  /**
   * Initializes the EventBusSystem and the underlying CoreEventBus.
   * @returns {Promise<EventBusSystem>}
   */
  async initialize() { //
    if (this.state.status === SYSTEM_STATUS.RUNNING || this.state.status === SYSTEM_STATUS.INITIALIZING) {
      const err = new EventError(ErrorCodes.EVENT.ALREADY_INITIALIZED, 'EventBusSystem is already initialized or initializing.'); //
      await this._handleInternalError(err, { currentStatus: this.state.status }); //
      return this;
    }

    this.emit(LIFECYCLE_EVENTS.INITIALIZING, { system: 'EventBusSystem' });
    this.state.status = SYSTEM_STATUS.INITIALIZING; //
    this.state.startTime = Date.now(); //

    try {
      // Create and initialize the CoreEventBus instance
      // Pass system dependencies to CoreEventBus
      this.eventBus = new CoreEventBus({
        errorSystem: this.deps.errorSystem,
        config: this.deps.config, // Pass the whole config, CoreEventBus can pick what it needs
      }); //
      await this.eventBus.initialize(); //

      this.setupEventForwarding(); //

      this.state.status = SYSTEM_STATUS.RUNNING; //
      this.recordMetric('eventbussystem.initialized.success', 1, { timestamp: Date.now() }); //
      this.emit(LIFECYCLE_EVENTS.INITIALIZED, { system: 'EventBusSystem', timestamp: new Date().toISOString() }); //
      this.emit(LIFECYCLE_EVENTS.RUNNING, { system: 'EventBusSystem', timestamp: new Date().toISOString() });


    } catch (error) {
      this.state.status = SYSTEM_STATUS.ERROR; //
      this.recordMetric('eventbussystem.initialized.failure', 1, { error: error.code, timestamp: Date.now() }); //
      await this._handleInternalError(error, { phase: 'initialization' }); //
      throw error instanceof EventError ? error : new EventError( //
        ErrorCodes.EVENT.INITIALIZATION_FAILED, //
        'EventBusSystem failed to initialize.', //
        { originalMessage: error.message }, //
        { cause: error } //
      );
    }
    return this;
  }

  /**
   * Sets up event forwarding from the CoreEventBus to this EventBusSystem.
   * This allows listeners on EventBusSystem to receive events emitted on CoreEventBus.
   * @private
   */
  setupEventForwarding() { //
    if (!this.eventBus || this._forwardingInitialized) { //
      return; //
    }

    // Listen for all events on the actual eventBus instance (* means all named events)
    // As per CoreEventBus refactor, wildcard listeners receive the full event object.
    this.eventBus.on('*', (event) => { // `event` here is the full event object
      if (event && typeof event.name === 'string') { //
        // Forward non-system events emitted on CoreEventBus to EventBusSystem's listeners
        // This avoids loops if EventBusSystem itself emits a system event that CoreEventBus also handles.
        // However, if system events from CoreEventBus (like 'system:initialized' from CoreEventBus)
        // are desired on EventBusSystem, this logic needs adjustment or specific listeners.
        // The original code had this `if (!event.name.startsWith('system:'))`
        // For broader forwarding, we might remove this condition or make it configurable.
        // For now, let's assume we want to forward most things for observability.
        // We should be careful not to re-emit events that EventBusSystem itself emitted to CoreEventBus.
        // The current `emit` on EventBusSystem forwards to `this.eventBus.emit` for non-system events.
        // So, an event emitted by `EventBusSystem.emit('app.event', ...)` will go to `CoreEventBus`,
        // which then might be caught by this '*' listener and re-emitted by `super.emit` on `EventBusSystem`.
        // This can create a duplicate for listeners on EventBusSystem.

        // To avoid this, only forward events that did not originate from EventBusSystem's own emit chain.
        // This is tricky without adding more metadata.
        // A simpler approach: system events from CoreEventBus are prefixed e.g. "coreEventBus:initialized"
        // And events emitted by modules go through CoreEventBus directly.
        // EventBusSystem is more of a manager and a point for very high-level system events.

        // Let's simplify: EventBusSystem primarily manages CoreEventBus.
        // Events it emits itself are for its own lifecycle.
        // If other systems want to listen to ALL CoreEventBus events, they should getEventBus().on('*', ...).
        // The forwarding here can be for specific system-level aggregation if needed.
        // The original code for test events implies specific forwarding.
        // For general events, it was `if (!event.name.startsWith('system:')) { super.emit(event.name, event); }`

        // Re-evaluating: The main purpose of EventBusSystem is to provide *access* to the event bus.
        // Its own EventEmitter capabilities are for its own lifecycle.
        // Forwarding all CoreEventBus events to EventBusSystem listeners might be too noisy / confusing.
        // Let's stick to specific lifecycle event forwarding from CoreEventBus if needed,
        // or remove general '*' forwarding from CoreEventBus to EventBusSystem.
        // The original code specifically forwarded non-system events.
        // This might be useful if some older code listens on EventBusSystem instance directly.

        // For now, let's keep the original intent of forwarding non-system events:
        if (event.name && !event.name.startsWith('system:')) {
             super.emit(event.name, event); // Forward the full event object to EventBusSystem's own listeners
        }

        // Forward specific system events from CoreEventBus if they need to be exposed by EventBusSystem
        if (event.name === LIFECYCLE_EVENTS.INITIALIZED && event.system === 'CoreEventBus') {
            super.emit('coreEventBus:initialized', event);
        }
        if (event.name === LIFECYCLE_EVENTS.SHUTDOWN && event.system === 'CoreEventBus') {
            super.emit('coreEventBus:shutdown', event);
        }

      } else if (event) { // Check if event itself is the name (old wildcard behavior)
        // This block is for compatibility if CoreEventBus wildcard emits (eventName, data)
        // But our refactored CoreEventBus now emits (fullEventObject) for wildcard.
        // So this block might become less relevant or need removal if CoreEventBus is strictly refactored.
        // For now, logging if this path is hit.
        this._handleInternalError(new EventError(ErrorCodes.EVENT.LEGACY_WILDCARD_FORWARD, "Legacy wildcard format received by EventBusSystem forwarder."), { eventArg: event });
      }
    });
    this._forwardingInitialized = true; //
  }

  /**
   * Emits an event.
   * Primarily, this system manages CoreEventBus. Direct emission from EventBusSystem
   * should be for its own lifecycle or specific system-level events.
   * Application events should be emitted via the CoreEventBus instance.
   * @param {string} eventName - Event name.
   * @param {...any} args - Event arguments.
   * @returns {Promise<boolean>}
   */
  async emit(eventName, ...args) { //
    // Local emission for EventBusSystem's own lifecycle events
    const localEmitResult = super.emit(eventName, ...args); //

    // Forward to CoreEventBus ONLY if it's NOT a system lifecycle event from this EventBusSystem itself,
    // to prevent loops with the wildcard forwarder.
    // Application code should typically use getEventBus().emit().
    if (this.eventBus && typeof this.eventBus.emit === 'function' &&
        !eventName.startsWith('system:') && !eventName.startsWith('coreEventBus:')) { //
      try {
        // When EventBusSystem emits, it's likely emitting raw data, not a pre-formed event object.
        // CoreEventBus.emit(eventName, data, options) will wrap it.
        await this.eventBus.emit(eventName, ...args); //
      } catch (error) {
        // Handle errors from attempting to emit via CoreEventBus
        await this._handleInternalError(error, { phase: 'emit-forward', eventName }); //
        // Do not re-throw here, as local emit might have succeeded.
        // The error from eventBus.emit would be an EventError.
      }
    }
    return localEmitResult; //
  }


  getEventBus() { //
    if (this.state.status !== SYSTEM_STATUS.RUNNING) { //
      throw new EventError( //
        ErrorCodes.EVENT.NOT_INITIALIZED, //
        'EventBusSystem (or its CoreEventBus) is not initialized or not running.', //
        { currentStatus: this.state.status } //
      );
    }
    return this.eventBus; //
  }

  async shutdown() { //
    if (this.state.status === SYSTEM_STATUS.SHUTDOWN || this.state.status === SYSTEM_STATUS.SHUTTING_DOWN) { //
      return this; //
    }
    this.emit(LIFECYCLE_EVENTS.SHUTTING_DOWN, { system: 'EventBusSystem' });
    this.state.status = SYSTEM_STATUS.SHUTTING_DOWN; //

    try {
      if (this.eventBus) { //
        await this.eventBus.shutdown(); //
      }
      super.removeAllListeners(); // Clear EventBusSystem's own listeners

      this.eventBus = null; //
      this.state.status = SYSTEM_STATUS.SHUTDOWN; //
      this.state.startTime = null;
      this.recordMetric('eventbussystem.shutdown.success', 1, { timestamp: Date.now() }); //
      // Log directly as listeners are removed
      this.deps.logger?.info('[EventBusSystem] Shutdown complete.');

    } catch (error) {
      this.state.status = SYSTEM_STATUS.ERROR; //
      this.recordMetric('eventbussystem.shutdown.failure', 1, { error: error.code, timestamp: Date.now() }); //
      await this._handleInternalError(error, { phase: 'shutdown' }); //
      throw error instanceof EventError ? error : new EventError( //
        ErrorCodes.EVENT.SHUTDOWN_FAILED, //
        'EventBusSystem failed to shutdown.', //
        { originalMessage: error.message }, //
        { cause: error } //
      );
    }
    return this; //
  }

  // --- State, Health, Metrics ---
  setupDefaultHealthChecks() { //
    this.registerHealthCheck('eventbussystem.state', this.checkSystemState.bind(this)); //
    this.registerHealthCheck('eventbussystem.corebus', this.checkCoreBusHealth.bind(this)); //
  }

  recordMetric(name, value, tags = {}) { //
    this.state.metrics.set(name, { value, timestamp: Date.now(), tags }); //
  }

  getMetrics() { //
    const metrics = {}; //
    for (const [name, data] of this.state.metrics) { //
      metrics[name] = data; //
    }
    // Optionally include metrics from CoreEventBus if desired
    // if (this.eventBus && typeof this.eventBus.getMetrics === 'function') {
    //   metrics.coreEventBus = this.eventBus.getMetrics();
    // }
    return metrics; //
  }

  registerHealthCheck(name, checkFn) { //
    if (typeof checkFn !== 'function') {
      const err = new EventError(ErrorCodes.EVENT.INVALID_HANDLER, `Health check '${name}' must be a function.`); //
      this._handleInternalError(err); // Log, but rethrow
      throw err;
    }
    this.state.healthChecks.set(name, checkFn); //
  }

  async checkHealth() { //
    const results = {}; //
    let overallStatus = SYSTEM_STATUS.HEALTHY; //

    for (const [name, checkFn] of this.state.healthChecks) { //
      try {
        const checkResult = await checkFn(); // Expects { status, detail, errors }
        results[name] = checkResult; //
        if (checkResult.status !== SYSTEM_STATUS.HEALTHY) { //
          overallStatus = (overallStatus === SYSTEM_STATUS.HEALTHY) ? SYSTEM_STATUS.DEGRADED : SYSTEM_STATUS.UNHEALTHY; //
          if (checkResult.status === SYSTEM_STATUS.UNHEALTHY) overallStatus = SYSTEM_STATUS.UNHEALTHY; //
        }
      } catch (error) {
        results[name] = createStandardHealthCheckResult(SYSTEM_STATUS.UNHEALTHY, { error: 'Health check threw an exception' }, [error]); //
        overallStatus = SYSTEM_STATUS.UNHEALTHY; //
      }
    }
    return { //
      name: this.constructor.name, //
      version: EventBusSystem.version, //
      status: overallStatus, //
      timestamp: new Date().toISOString(), //
      uptime: this.state.startTime ? Date.now() - this.state.startTime : 0,
      errorCount: this.state.errors.length,
      checks: results, //
    };
  }

  async checkSystemState() { //
    return createStandardHealthCheckResult( //
      this.state.status === SYSTEM_STATUS.RUNNING ? SYSTEM_STATUS.HEALTHY : SYSTEM_STATUS.UNHEALTHY, //
      { //
        status: this.state.status, //
        uptime: this.state.startTime ? Date.now() - this.state.startTime : 0, //
        internalErrorCount: this.state.errors.length //
      }
    );
  }

  async checkCoreBusHealth() { //
    if (!this.eventBus || typeof this.eventBus.checkHealth !== 'function') { //
      return createStandardHealthCheckResult( //
        SYSTEM_STATUS.UNHEALTHY, //
        { reason: 'CoreEventBus not available or does not support health checks.' } //
      );
    }
    try {
      // CoreEventBus.checkHealth() already returns the full standardized health object.
      return await this.eventBus.checkHealth(); //
    } catch (error) {
      return createStandardHealthCheckResult(SYSTEM_STATUS.UNHEALTHY, { error: 'CoreEventBus health check failed.' }, [error]); //
    }
  }

  getSystemStatus() { //
    return { //
        name: this.constructor.name, //
        version: EventBusSystem.version, //
        status: this.state.status, //
        uptime: this.state.startTime ? Date.now() - this.state.startTime : 0, //
        initialized: this.state.status === SYSTEM_STATUS.RUNNING, //
        errorCount: this.state.errors.length, //
        timestamp: new Date().toISOString(), //
        coreEventBusStatus: this.eventBus ? this.eventBus.getSystemStatus().status : SYSTEM_STATUS.UNAVAILABLE || 'unavailable'
    };
  }
}

/**
 * Factory function for creating an EventBusSystem instance.
 * @param {object} [deps={}] - Dependencies for the EventBusSystem.
 * @returns {EventBusSystem}
 */
export function createEventBusSystem(deps = {}) { //
  // Original factory provided default no-op errorSystem and empty config
  // This is good, but dependencies are now validated in constructor.
  // Consider if this factory should also perform preliminary checks or if constructor validation is enough.
  return new EventBusSystem(deps); //
}


// src/core/event/eventbus-system.md

# TSMIS EventBusSystem & CoreEventBus Documentation
Version: 2.0.0 (Refactored Core)

## Table of Contents

1.  [Introduction to the Eventing System](#1-introduction-to-the-eventing-system)
    * [1.1. Purpose & Philosophy](#11-purpose--philosophy)
    * [1.2. Key Components: `EventBusSystem` and `CoreEventBus`](#12-key-components-eventbussystem-and-coreeventbus)
2.  [Component: `CoreEventBus.js` - The Eventing Engine](#2-component-coreeventbusjs---the-eventing-engine)
    * [2.1. Overview & Primary Responsibility](#21-overview--primary-responsibility)
    * [2.2. Key Functionalities & API (`CoreEventBus`)](#22-key-functionalities--api-coreeventbus)
        * [2.2.1. Standard Event Object Structure](#221-standard-event-object-structure)
        * [2.2.2. `emit(eventName, data, options)`](#222-emiteventname-data-options)
        * [2.2.3. `subscribe(pattern, handler, options)`](#223-subscribepattern-handler-options)
        * [2.2.4. `unsubscribe(subscriptionId)`](#224-unsubscribesubscriptionid)
        * [2.2.5. Event Queuing (`queueEvent`, `processQueue`, `processAllQueues`)](#225-event-queuing-queueevent-processqueue-processallqueues)
        * [2.2.6. Event History (`trackEvent`, `getHistory`, `getAllHistory`)](#226-event-history-trackevent-gethistory-getallhistory)
        * [2.2.7. `handleError(error, context)` (for Listeners)](#227-handleerrorerror-context-for-listeners)
        * [2.2.8. `reset()`](#228-reset)
    * [2.3. Wildcard and Pattern Subscription Details](#23-wildcard-and-pattern-subscription-details)
    * [2.4. State Management (`CoreEventBus` Specifics)](#24-state-management-coreeventbus-specifics)
    * [2.5. Lifecycle Management (`CoreEventBus` Specifics)](#25-lifecycle-management-coreeventbus-specifics)
    * [2.6. Error Handling within `CoreEventBus`](#26-error-handling-within-coreeventbus)
    * [2.7. Health Monitoring (`CoreEventBus` Specifics)](#27-health-monitoring-coreeventbus-specifics)
    * [2.8. Metrics Tracking (`CoreEventBus` Specifics)](#28-metrics-tracking-coreeventbus-specifics)
    * [2.9. Static Factory (`createEventBus`)](#29-static-factory-createeventbus)
3.  [Component: `EventBusSystem.js` - The Managing Facade](#3-component-eventbussystemjs---the-managing-facade)
    * [3.1. Overview & Primary Responsibility](#31-overview--primary-responsibility)
    * [3.2. Key Functionalities & API (`EventBusSystem`)](#32-key-functionalities--api-eventbussystem)
        * [3.2.1. `initialize()`](#321-initialize)
        * [3.2.2. `getEventBus()`](#322-geteventbus)
        * [3.2.3. `emit(eventName, ...args)`](#323-emiteventname-args)
        * [3.2.4. `shutdown()`](#324-shutdown)
    * [3.3. Adherence to Standardization Pillars (Recap for `EventBusSystem`)](#33-adherence-to-standardization-pillars-recap-for-eventbussystem)
    * [3.4. State Management (`EventBusSystem` Specifics)](#34-state-management-eventbussystem-specifics)
    * [3.5. Lifecycle Management (`EventBusSystem` Specifics)](#35-lifecycle-management-eventbussystem-specifics)
    * [3.6. Error Handling within `EventBusSystem`](#36-error-handling-within-eventbussystem)
    * [3.7. Event Integration (`EventBusSystem` Specifics - Forwarding)](#37-event-integration-eventbussystem-specifics---forwarding)
    * [3.8. Health Monitoring (`EventBusSystem` Specifics)](#38-health-monitoring-eventbussystem-specifics)
    * [3.9. Metrics Tracking (`EventBusSystem` Specifics)](#39-metrics-tracking-eventbussystem-specifics)
    * [3.10. Static Factory (`createEventBusSystem`)](#310-static-factory-createeventbussystem)
4.  [Integrations (Eventing System Level)](#4-integrations-eventing-system-level)
5.  [Overall Eventing Flow Diagram](#5-overall-eventing-flow-diagram)
6.  [Usage Examples & Best Practices](#6-usage-examples--best-practices)
    * [6.1. Emitting an Event](#61-emitting-an-event)
    * [6.2. Subscribing to Events (Exact, Pattern, Wildcard)](#62-subscribing-to-events-exact-pattern-wildcard)
    * [6.3. Using Event Queuing](#63-using-event-queuing)
    * [6.4. Accessing Event History](#64-accessing-event-history)
    * [6.5. Error Handling in Event Listeners](#65-error-handling-in-event-listeners)
7.  [Testing Strategy Notes](#7-testing-strategy-notes)
8.  [Future Considerations & Potential Enhancements](#8-future-considerations--potential-enhancements)

---

## 1. Introduction to the Eventing System

### 1.1. Purpose & Philosophy
The TSMIS Eventing System, comprising `EventBusSystem` and its managed `CoreEventBus`, is a cornerstone of the application's architecture, designed to facilitate decoupled, asynchronous communication between various components, particularly business modules. The philosophy behind it is to enable a more modular, scalable, and maintainable system where components can react to occurrences (events) without being tightly bound to the components that produce those events. This promotes an event-driven architecture (EDA) pattern.

Key goals include:
* **Decoupling**: Publishers of events do not need to know about subscribers, and vice-versa.
* **Asynchronicity**: Allows for non-blocking operations and better system responsiveness.
* **Extensibility**: New listeners can be added to react to existing events without modifying the event publishers.
* **Standardization**: Provides a consistent way to define, emit, subscribe to, and manage events.
* **Observability**: Offers built-in features for history, health monitoring, and metrics related to event processing.

### 1.2. Key Components: `EventBusSystem` and `CoreEventBus`
* **`CoreEventBus.js`**: This is the engine of the eventing system. It extends Node.js's `EventEmitter` and provides the core functionalities:
    * Emitting events with a standardized structure.
    * Managing subscriptions (exact name, pattern-based, and global wildcard).
    * Optional event queuing for deferred processing.
    * Optional event history for debugging and auditing.
    * Its own standardized state, lifecycle, error handling, health, and metrics.
* **`EventBusSystem.js`**: This system acts as a managing facade for `CoreEventBus`. Its responsibilities include:
    * Creating, initializing, and shutting down the `CoreEventBus` instance.
    * Providing a controlled access point to the `CoreEventBus` instance for the rest of the application (`getEventBus()`).
    * Integrating the eventing subsystem into the application's overall lifecycle, error reporting, health monitoring, and metrics collection through its adherence to the TSMIS core standardization pillars.
    * Potentially forwarding or reacting to specific system-level events from `CoreEventBus`.

Application components (like business modules) will primarily interact with the `CoreEventBus` instance obtained via `EventBusSystem.getEventBus()`.

## 2. Component: `CoreEventBus.js` - The Eventing Engine

**(This section details the `CoreEventBus` class. Full individual documentation would be in `core-event-bus-docs.md`.)**

### 2.1. Overview & Primary Responsibility
`CoreEventBus` is the central workhorse for event management in TSMIS. It provides a robust implementation for emitting events, managing complex subscription patterns (exact, wildcard, regex-like), queuing events for later processing, and maintaining a history of emitted events. It ensures all events adhere to a standard structure.

### 2.2. Key Functionalities & API (`CoreEventBus`)

#### 2.2.1. Standard Event Object Structure
All events emitted and received via `CoreEventBus.emit()` and subscriber handlers are wrapped in a standard object:

**CoreEventBus**: Standard Event Object Structure Example

```javascript
// {
//   id: "a1b2c3d4-e5f6-7890-1234-567890abcdef", // Unique event ID (e.g., UUID)
//   name: "user.created",                         // The original emitted eventName
//   data: {                                       // The event payload/data
//     userId: "usr_123",
//     username: "alice_wonder",
//     email: "alice@example.com"
//   },
//   timestamp: "2025-05-18T23:30:00.000Z",       // ISO 8601 timestamp of event creation
//   metadata: {                                   // User-supplied options.metadata or an empty object
//     correlationId: "corr_id_789",
//     sourceService: "AuthModule"
//   }
// }
```

This standardization simplifies handler logic as the event structure is predictable.

#### 2.2.2. `emit(eventName: string, data: any, options = {}): Promise<boolean>`
The primary method for publishing events.
* **`eventName`**: The string identifier of the event (e.g., `user.created`).
* **`data`**: The payload associated with the event.
* **`options`**: An optional object which can include:
    * `options.queue: boolean` (default: `false`): If `true`, the event is added to a named queue (based on `eventName`) for deferred processing instead of immediate emission to listeners.
    * `options.immediate: boolean` (default: `false`): If `options.queue` is `true`, setting this to `true` attempts to process the queue immediately after this event is added.
    * `options.metadata: object` (default: `{}`): Allows attaching additional, non-payload information to the event.
* Wraps `data` and `metadata` into the standard event object.
* Adds the event to history using `trackEvent()`.
* Records an `eventbus.events.emitted` metric.
* Handles queuing or direct emission to subscribers.
* **Returns**: `Promise<boolean>` indicating if the event had listeners (for direct emit) or was successfully queued.
* **Throws**: `EventError` for invalid `eventName` or internal processing issues.

#### 2.2.3. `subscribe(pattern: string, handler: Function, options = {}): string`
Registers a handler function to listen for events matching the given `pattern`.
* **`pattern`**: Can be an exact event name, a pattern with wildcards (e.g., `domain.*`, `*.action`), or a global wildcard (`*`).
* **`handler`**: An `async function(event: object)` that will be invoked with the single, full standard event object when a matching event is emitted.
* **`options`**: Reserved for future subscription-specific options.
* **Returns**: A unique `subscriptionId` (string) which can be used with `unsubscribe()`.
* **Throws**: `EventError` for invalid `pattern` or `handler`.

#### 2.2.4. `unsubscribe(subscriptionId: string): boolean`
Removes a previously established subscription.
* **`subscriptionId`**: The ID returned by `subscribe()`.
* **Returns**: `true` if a subscription was found and successfully removed, `false` otherwise.

#### 2.2.5. Event Queuing (`queueEvent`, `processQueue`, `processAllQueues`)
* **`async queueEvent(event: object, options = {}): Promise<boolean>`**: Internally used by `emit` (if `options.queue` is true) to add a fully formed standard event object to a named queue.
* **`async processQueue(queueName: string): Promise<number>`**: Processes a batch of events (size configurable via `config.eventBus.queueBatchSize`) from the specified queue by emitting them to their respective subscribers. Errors thrown by individual event handlers during queue processing are caught and reported via `this.handleError()`.
* **`async processAllQueues(): Promise<object>`**: Iterates through all existing queues and calls `processQueue()` for each, returning an object with processed counts per queue.

#### 2.2.6. Event History (`trackEvent`, `getHistory`, `getAllHistory`)
* **`trackEvent(event: object)`**: Automatically called by `emit` to add the event object to an in-memory, capped history list maintained per event name. The maximum history size is configurable via `this.maxHistorySize` (from `config.eventBus.maxHistorySize` or a default).
* **`getHistory(eventName: string, options = { limit?: number }): Array<object>`**: Retrieves the recorded history for a specific event name, optionally limited to the most recent `limit` events.
* **`getAllHistory(options = { limit?: number }): object`**: Retrieves history for all event names.

#### 2.2.7. `async handleError(error: Error, context = {}): Promise<void>`
A public method designed for event *listeners* to report errors they encounter during their own execution. This method standardizes how listener errors are reported to the central `ErrorSystem` by using `safeHandleError(this.deps.errorSystem, error, context)`.

#### 2.2.8. `async reset(): Promise<void>`
Clears all event queues, history, and removes all application-level event listeners and subscriptions. It also disables wildcard forwarding if it was active. This is a destructive operation typically used during testing or a controlled system reset.

### 2.3. Wildcard and Pattern Subscription Details
A key aspect of the refactored `CoreEventBus` is the consistent and predictable behavior of wildcard and pattern-based subscriptions:
* **Handler Signature**: All event handlers, regardless of whether they subscribe to an exact event name, a pattern (e.g., `user.*`), or the global wildcard (`*`), receive a **single argument**: the full, standardized event object (`{ id, name, data, timestamp, metadata }`).
* **Wildcard Forwarding (`*`)**: `CoreEventBus` dynamically manages an internal "wildcard forwarding" mechanism.
    * When the first listener subscribes to `*`, `CoreEventBus` wraps its native `emit` method (`this._enableWildcardForwarding()`). This wrapper ensures that after an event is emitted to its specific listeners, the same complete event object is also dispatched to the `"*"` channel if the original event name was not `"*"`.
    * This wrapper is removed when the last `"*"` listener unsubscribes (`this._disableWildcardForwarding()`).
* **Pattern Subscription (e.g., `item.*`)**: These subscriptions internally listen on the `"*"` channel. When they receive an event object (which is always the full standard object), their internal handler then applies a regular expression (generated from the pattern like `item.*`) against the `event.name` property to determine if their specific user-provided handler should be invoked.

This ensures that event data is consistently presented to all types of handlers, simplifying developer experience.

### 2.4. State Management (`CoreEventBus` Specifics)
`CoreEventBus` implements the standard `this.state` object. Key operational data is stored as instance properties:
* **`this.queues: Map<string, Array<object>>`**: Stores events waiting for processing, keyed by event name.
* **`this.subscriptions: Map<string, object>`**: Stores active subscription details (pattern, handler, etc.), keyed by a unique subscription ID.
* **`this.history: Map<string, Array<object>>`**: Stores recent event objects, keyed by event name.
* **`this.maxHistorySize: number`**: Configuration for history length.
* **`this._originalEmit: Function | null`**: Stores the original `super.emit` when wildcard forwarding is active.
* **`this._processingNewListener: boolean`**: Internal guard for `newListener` recursion.

### 2.5. Lifecycle Management (`CoreEventBus` Specifics)
* **`async initialize()`**: Sets up initial state. Wildcard forwarding logic is now primarily driven by `newListener` and `removeListener` hooks set up in the constructor. Emits `system:initializing`, `system:initialized`, `system:running`.
* **`async shutdown()`**: Calls `reset()` to clear all operational data (queues, history, listeners, subscriptions) and then removes all its own listeners (including internal ones for wildcard management). Emits `system:shutting_down` and logs `system:shutdown` (as listeners are removed).

### 2.6. Error Handling within `CoreEventBus`
* Uses a private `_handleInternalError(error, context)` method for its own operational errors (e.g., invalid arguments to `emit` or `subscribe`, unexpected issues in queuing/history). This logs to `this.state.errors`, records metrics, and reports to `ErrorSystem` via `safeHandleError`.
* Throws `EventError` with specific codes from `ErrorCodes.EVENT` for such failures.
* Catches errors from individual event handlers during `processQueue` and reports them via its public `handleError` method, allowing other events in the queue to be processed.

### 2.7. Health Monitoring (`CoreEventBus` Specifics)
Provides `checkHealth()`. Default checks:
* **`eventbus.state`**: Its lifecycle `status`, uptime, internal error count.
* **`eventbus.queues`**: Number of active queues and total events across all queues.
* **`eventbus.subscriptions`**: Number of active subscriptions and a list of their patterns.

### 2.8. Metrics Tracking (`CoreEventBus` Specifics)
Records detailed metrics:
* Lifecycle: `eventbus.initialized.success/failure`, `eventbus.shutdown.success/failure`.
* Errors: `eventbus.errors.internal`, `eventbus.errors.reported_by_listener`.
* Operations: `eventbus.wildcard.enabled/disabled`, `eventbus.events.emitted` (tags: `eventName`, `queued`), `eventbus.events.queued` (tags: `eventName`, `queueSize`), `eventbus.queue.processed` (tags: `queueName`, `processingTimeMs`), `eventbus.queue.remaining`, `eventbus.all_queues.processed_total`, `eventbus.subscriptions.added/removed` (tags: `pattern`), `eventbus.history.size` (tags: `eventName`), `eventbus.reset`.

### 2.9. Static Factory (`createEventBus`)
**`createEventBus(deps = {}): CoreEventBus`** for instantiation.

---
## 3. Component: `EventBusSystem.js` - The Managing Facade

**(This section details the `EventBusSystem` class. Full individual documentation would be in `event-bus-system-docs.md`.)**

### 3.1. Overview & Primary Responsibility
`EventBusSystem` acts as a managing facade for the `CoreEventBus` instance. Its main roles are to handle the lifecycle (creation, initialization, shutdown) of the `CoreEventBus`, provide a controlled access point (`getEventBus()`) for the rest of the application, and integrate the eventing subsystem's health and metrics into the standardized TSMIS monitoring framework.

### 3.2. Key Functionalities & API (`EventBusSystem`)

#### 3.2.1. `async initialize(): Promise<EventBusSystem>`
Validates its own dependencies (`errorSystem`, `config`). Creates a new instance of `CoreEventBus`, passing necessary dependencies. Calls `await coreEventBusInstance.initialize()`. Sets up event forwarding from `CoreEventBus` to `EventBusSystem` if needed.

#### 3.2.2. `getEventBus(): CoreEventBus`
The primary method for application components to retrieve the fully initialized and operational `CoreEventBus` instance. Throws an `EventError` if `EventBusSystem` (and by extension `CoreEventBus`) is not yet running.

#### 3.2.3. `async emit(eventName, ...args)`
While `EventBusSystem` is an `EventEmitter`, its `emit` method is primarily intended for its own lifecycle events (e.g., `system:initialized`). If used for other event names (not prefixed with `system:` or `coreEventBus:`), it forwards the emission to the managed `CoreEventBus` instance. Application components should generally use `getEventBus().emit()` for business events.

#### 3.2.4. `async shutdown(): Promise<EventBusSystem>`
Manages the graceful shutdown of the `CoreEventBus` (by calling its `shutdown()` method) and then cleans up its own resources and listeners.

### 3.3. Adherence to Standardization Pillars (Recap for `EventBusSystem`)
* **State Management**: Implements the standard `this.state` object. Also holds the `eventBus` (CoreEventBus instance) and `_forwardingInitialized` flag.
* **Lifecycle Management**: Manages its own lifecycle (`initialize`, `shutdown`) which includes managing `CoreEventBus`'s lifecycle. Emits standard `LIFECYCLE_EVENTS`.
* **Error Handling**: Uses `_handleInternalError` for its own operational errors, reporting via `safeHandleError`. Throws `EventError`.
* **Health Monitoring**: `checkHealth()` aggregates its own state with the health of the managed `CoreEventBus` (via `eventbussystem.corebus` check).
* **Metrics Tracking**: Records metrics for its own lifecycle and internal errors.
* **Factory Function**: `createEventBusSystem(deps = {})` is provided.

### 3.4. State Management (`EventBusSystem` Specifics)
(Covered by 3.3 - Standard `this.state` plus `eventBus` instance and `_forwardingInitialized` flag).

### 3.5. Lifecycle Management (`EventBusSystem` Specifics)
* **`initialize()`**: Instantiates and initializes `CoreEventBus`. Calls `_setupEventForwarding()`.
* **`shutdown()`**: Ensures `CoreEventBus.shutdown()` is called. Clears its own state.

### 3.6. Error Handling within `EventBusSystem`
Uses `_handleInternalError` for its own operational errors (e.g., if `CoreEventBus` fails to initialize). These are reported to the global `ErrorSystem`.

### 3.7. Event Integration (`EventBusSystem` Specifics - Forwarding)
`_setupEventForwarding()` listens to the managed `CoreEventBus` instance (typically via `on('*', eventHandler)`).
* It may re-emit certain non-system events from `CoreEventBus` on the `EventBusSystem` instance itself, allowing components holding only an `EventBusSystem` reference to listen.
* It also forwards specific lifecycle events from `CoreEventBus` (e.g., `CoreEventBus`'s own `system:initialized`) by emitting new events on `EventBusSystem` with a differentiating prefix (e.g., `coreEventBus:initialized`).

### 3.8. Health Monitoring (`EventBusSystem` Specifics)
Default health checks:
* **`eventbussystem.state`**: Its own lifecycle `status`, uptime, internal error count.
* **`eventbussystem.corebus`**: Calls `this.eventBus.checkHealth()` and includes the full, standardized health report from `CoreEventBus`.

### 3.9. Metrics Tracking (`EventBusSystem` Specifics)
Key metrics:
* `eventbussystem.initialized.success/failure`
* `eventbussystem.shutdown.success/failure`
* `eventbussystem.errors.internal`

### 3.10. Static Factory (`createEventBusSystem`)
**`createEventBusSystem(deps = {}): EventBusSystem`** for instantiation.

---
## 4. Integrations (Eventing System Level)

The Eventing System (`EventBusSystem` providing `CoreEventBus`) integrates with virtually all other parts of TSMIS:
* **`ContainerSystem`**: Instantiates `EventBusSystem` and provides its dependencies (`ErrorSystem`, `config`). `ContainerSystem` may also emit its own operational events that could be listened to via `CoreEventBus` if a bridge component were set up.
* **`ModuleSystem` & `CoreModule`s**: `ModuleSystem` injects `EventBusSystem` into `CoreModule`s. `CoreModule`s then use `eventBusSystem.getEventBus()` to obtain the `CoreEventBus` instance for:
    * Emitting domain-specific events (`this.emit()` in `CoreModule` uses it).
    * Subscribing to events from other modules or systems (in `setupEventHandlers()`).
* **`RouterSystem` & `CoreRouter`**: `CoreRouter` subscribes to `router.route.*` events (emitted by `RoutableModule`s via `CoreEventBus`) to learn about route definitions.
* **`ErrorSystem`**: `CoreEventBus` (via its public `handleError` method used by listeners) and `EventBusSystem` (via its `_handleInternalError`) report their errors to `ErrorSystem` using `safeHandleError`.
* **Application Services & Business Logic**: Any component needing to publish information or react to occurrences without direct coupling uses the `CoreEventBus`.

## 5. Overall Eventing Flow Diagram

**Eventing System**: Overall Event Flow

```mermaid
graph TD
    subgraph EventBusSystem_Facade [EventBusSystem Facade]
        direction LR
        EBS_State[("this.state (System)")]
        EBS_CEBInst(["Managed CoreEventBus Instance"])
    end

    subgraph CoreEventBus_Engine [CoreEventBus Engine]
        direction TB
        CEB_State[("this.state (Bus)")]
        CEB_Queues[("Queues Map")]
        CEB_History[("History Map")]
        CEB_Subscriptions[("Subscriptions Map")]
        CEB_WildcardLogic["Wildcard/Pattern Logic"]
    end
    
    EventBusSystem_Facade -- Manages/Creates & Initializes --> CoreEventBus_Engine;

    AppModuleA["App Module A (Emitter)"] -- "1. getEventBus()" --> EventBusSystem_Facade;
    EventBusSystem_Facade -- "2. Returns instance" --> AppModuleA;
    AppModuleA -- "3. coreEventBus.emit('eventX', data, options)" --> CoreEventBus_Engine;
    
    CoreEventBus_Engine -- "4. Create Event Object" --> StandardEvent["{id, name, data, ts, meta}"];
    StandardEvent -- "5. Track History" --> CEB_History;
    StandardEvent -- "6. Queue if options.queue" --> CEB_Queues;
    
    alt Direct Emission (Not Queued)
        StandardEvent -- "7. Find Subscribers" --> CEB_Subscriptions;
        CEB_Subscriptions -- "8. Match 'eventX' (Direct/Pattern/Wildcard)" --> CEB_WildcardLogic;
        CEB_WildcardLogic -- "9. Invoke Handler" --> HandlerB["AppModuleB.onEventX(eventObject)"];
        HandlerB -- "10. Processes Event" --> LogicB["Module B Logic Executed"];
    else Queued Event
        CEB_Queues -- Later via processQueue() --> StandardEvent; 
        StandardEvent -- "Re-enters Emission Flow (steps 7-10)" --> CEB_Subscriptions;
    end

    HandlerB -- "Optional: Reports Error via coreEventBus.handleError()" --> CoreEventBus_Engine;
    CoreEventBus_Engine -- "Forwards error via safeHandleError" --> ErrorSystemGlobal["ErrorSystem"];


    classDef stateNode fill:#f9f,stroke:#333,stroke-width:2px;
    classDef component fill:#D6EAF8,stroke:#5DADE2,stroke-width:2px;
    classDef appComp fill:#E8F8F5,stroke:#76D7C4,stroke-width:2px;

    class EBS_State, CEB_State, CEB_Queues, CEB_History, CEB_Subscriptions stateNode;
    class EventBusSystem_Facade, CoreEventBus_Engine component;
    class AppModuleA, HandlerB, LogicB, ErrorSystemGlobal appComp;
```

## 6. Usage Examples & Best Practices

### 6.1. Emitting an Event
(From a `CoreModule` subclass or any component with access to `CoreEventBus`)

**CoreEventBus**: Emitting an Event Example

```javascript
// Assuming 'eventBus' is an instance of CoreEventBus obtained via eventBusSystem.getEventBus()
// import { ErrorCodes } from '../core/errors/ErrorCodes.js'; // If emitting specific error codes

// async function publishUserCreation(userData) {
//   try {
//     const eventName = 'user.created'; // Consistent event name
//     const data = {
//       userId: userData.id,
//       username: userData.username,
//       email: userData.email,
//       registrationDate: new Date().toISOString()
//     };
//     const options = {
//       metadata: {
//         source: 'UserModule', // Or specific service name
//         correlationId: 'some-request-id-123' // For tracing
//       }
//       // To queue this event:
//       // queue: true,
//       // immediate: false, // Process queue later via processQueue('user.created')
//     };

//     const wasEmittedOrQueued = await eventBus.emit(eventName, data, options);

//     if (wasEmittedOrQueued) {
//       console.log(`Event '${eventName}' emitted/queued successfully.`);
//     } else {
//       // This might indicate no direct listeners if not queued,
//       // though emit itself usually doesn't throw for no listeners.
//       console.warn(`Event '${eventName}' had no direct listeners (if not queued).`);
//     }
//   } catch (error) {
//     // This catch block is for errors from the eventBus.emit() process itself
//     // (e.g., invalid eventName, internal history/queueing error),
//     // NOT for errors thrown by event listeners.
//     console.error(`Failed to emit event: ${error.message}`, error);
//     // Potentially report this critical failure to ErrorSystem if eventBus.emit itself fails
//     // await errorSystem.handleError(error, { operation: 'publishUserCreationEvent' });
//   }
// }

// // Example usage:
// // publishUserCreation({ id: 'usr_456', username: 'bob_the_builder', email: 'bob@example.com' });
```

### 6.2. Subscribing to Events (Exact, Pattern, Wildcard)
(Typically within a `CoreModule`'s `setupEventHandlers` method)

**CoreEventBus**: Subscription Examples

```javascript
// Assuming 'eventBus' is an instance of CoreEventBus
// Assuming INVENTORY_EVENTS and USER_EVENTS are imported objects with event name constants

// // --- Example 1: Subscribing to an exact event name ---
// const userCreatedSubId = eventBus.subscribe(
//   USER_EVENTS.CREATED, // e.g., 'user.created'
//   async (event) => { // Handler receives the full standard event object
//     console.log(`[UserCreationHandler] Received event: ${event.name} (ID: ${event.id})`);
//     console.log('User Data:', event.data);
//     console.log('Metadata:', event.metadata);
//     // Perform actions like sending a welcome email, setting up user profile, etc.
//     try {
//       // await welcomeEmailService.sendWelcomeEmail(event.data.email);
//     } catch (error) {
//       // Report errors from within the handler
//       await eventBus.handleError(error, {
//         handler: 'UserCreationHandler',
//         eventId: event.id,
//         eventName: event.name
//       });
//     }
//   }
// );
// // To unsubscribe later (e.g., in a module's onShutdown):
// // eventBus.unsubscribe(userCreatedSubId);


// // --- Example 2: Subscribing to a pattern (e.g., all item events in inventory) ---
// const inventoryItemSubId = eventBus.subscribe(
//   'inventory.item.*', // Matches inventory.item.added, inventory.item.updated, etc.
//   async (event) => { // Handler receives the full standard event object
//     console.log(`[InventoryItemEventHandler] Received event: ${event.name} (ID: ${event.id})`);
//     // event.name will be the specific event like 'inventory.item.added'
//     switch (event.name) {
//       case INVENTORY_EVENTS.ITEM_ADDED:
//         // console.log('Item Added:', event.data);
//         break;
//       case INVENTORY_EVENTS.STOCK_UPDATED:
//         // console.log('Stock Updated:', event.data);
//         break;
//       // default:
//         // console.log('Unhandled inventory item event:', event.name);
//     }
//   }
// );


// // --- Example 3: Subscribing to all events (global wildcard) ---
// const allEventsSubId = eventBus.subscribe(
//   '*', // Global wildcard
//   async (event) => { // Handler receives the full standard event object
//     // This can be very verbose, use with caution for debugging or specific auditing.
//     console.log(`[GlobalAuditLogger] Event Received - Name: ${event.name}, ID: ${event.id}, Timestamp: ${event.timestamp}`);
//     // console.log(`Data:`, event.data);
//     // console.log(`Metadata:`, event.metadata);
//   }
// );

// Remember: Handlers should be async if they perform asynchronous operations.
// The CoreEventBus (specifically for queue processing) expects handlers might be async.
```

### 6.3. Using Event Queuing

**CoreEventBus**: Event Queuing Example

```javascript
// Assuming 'eventBus' is an instance of CoreEventBus
// Assuming 'logger' is available

// async function sendBatchNotifications(notifications) {
//   for (const notification of notifications) {
//     try {
//       // Queue the notification event for sending
//       await eventBus.emit(
//         'notification.send', // Event name, also serves as queue name
//         notification,        // e.g., { userId, message, type: 'email' }
//         {
//           queue: true,       // Enable queuing for this event
//           immediate: false,  // Don't process immediately, let a worker/timer do it
//           metadata: { priority: 'low' }
//         }
//       );
//       logger.info(`Notification queued for user: ${notification.userId}`);
//     } catch (error) {
//       // Handle error from the emit/queueing process itself
//       logger.error(`Failed to queue notification for user ${notification.userId}: ${error.message}`);
//       // Potentially report this to ErrorSystem
//       // await errorSystem.handleError(error, { operation: 'queueNotification' });
//     }
//   }
// }

// // --- Later, in a separate worker or a scheduled task ---
// async function processNotificationQueue() {
//   logger.info('Starting to process notification queue...');
//   try {
//     const processedCount = await eventBus.processQueue('notification.send');
//     if (processedCount > 0) {
//       logger.info(`Processed ${processedCount} notifications from the queue.`);
//     } else {
//       logger.info('Notification queue was empty or no new items processed in this batch.');
//     }
//   } catch (error) {
//     // Handle error from the processQueue operation itself (not handler errors)
//     logger.error(`Error during notification queue processing: ${error.message}`);
//     // await errorSystem.handleError(error, { operation: 'processNotificationQueue' });
//   }
// }

// // Example: Queue some notifications
// // await sendBatchNotifications([
// //   { userId: 'user1', message: 'Your order has shipped!' },
// //   { userId: 'user2', message: 'Your subscription is about to renew.' }
// // ]);

// // Example: Process the queue (e.g., called by a cron job or after a certain interval)
// // setInterval(async () => {
// //   await processNotificationQueue();
// // }, 60000); // Process every minute

// // --- Handler for 'notification.send' (subscribed elsewhere) ---
// // eventBus.subscribe('notification.send', async (event) => {
// //   const notificationData = event.data;
// //   logger.info(`Handler invoked for 'notification.send': Sending to ${notificationData.userId}`);
// //   try {
// //     // await actualEmailOrPushNotificationService.send(notificationData);
// //     logger.info(`Notification successfully sent to ${notificationData.userId}`);
// //   } catch (handlerError) {
// //     logger.error(`Handler for 'notification.send' failed for user ${notificationData.userId}: ${handlerError.message}`);
// //     // Report error from within the handler using CoreEventBus's public handleError
// //     await eventBus.handleError(handlerError, {
// //       handler: 'NotificationSendHandler',
// //       eventId: event.id,
// //       notificationData
// //     });
// //     // Depending on policy, you might want to re-queue or move to a dead-letter queue
// //   }
// // });
```

### 6.4. Accessing Event History

**CoreEventBus**: Accessing Event History Example

```javascript
// Assuming 'eventBus' is an instance of CoreEventBus
// Assuming 'logger' is available

// async function inspectRecentUserEvents() {
//   const eventName = 'user.created';
//   try {
//     // Get the last 5 'user.created' events
//     const recentUserCreations = eventBus.getHistory(eventName, { limit: 5 });

//     if (recentUserCreations.length > 0) {
//       logger.info(`Last ${recentUserCreations.length} '${eventName}' events:`);
//       recentUserCreations.forEach(event => {
//         logger.info(`  ID: ${event.id}, Timestamp: ${event.timestamp}, Data: ${JSON.stringify(event.data)}`);
//       });
//     } else {
//       logger.info(`No recent history found for event '${eventName}'.`);
//     }

//     // Get all history for all events (potentially very large, use with caution or limits)
//     // const allHistory = eventBus.getAllHistory({ limit: 2 }); // Get last 2 events for each event type
//     // logger.info('Sample of all event history (last 2 per type):');
//     // for (const [name, events] of Object.entries(allHistory)) {
//     //   logger.info(`  Event Type: ${name}`);
//     //   events.forEach(event => {
//     //     logger.info(`    ID: ${event.id}, Timestamp: ${event.timestamp}`);
//     //   });
//     // }

//   } catch (error) {
//     // Handle error from getHistory or getAllHistory methods themselves
//     logger.error(`Failed to retrieve event history: ${error.message}`);
//     // await errorSystem.handleError(error, { operation: 'inspectRecentUserEvents' });
//   }
// }

// // Example: After some 'user.created' events have been emitted...
// // await eventBus.emit('user.created', { userId: 'user001', name: 'Alice' });
// // await eventBus.emit('user.created', { userId: 'user002', name: 'Bob' });
// // ...
// // inspectRecentUserEvents();
```

### 6.5. Error Handling in Event Listeners

**CoreEventBus**: Error Handling within Event Listeners

```javascript
// Assuming 'eventBus' is an instance of CoreEventBus
// Assuming 'logger' and 'ErrorSystem' (or a way to report to it) are available

// // Example event listener (subscriber handler)
// const orderProcessingSubId = eventBus.subscribe(
//   'order.created',
//   async (event) => { // Handler receives the full standard event object
//     logger.info(`[OrderProcessor] Processing order ID: ${event.data.orderId}, Event ID: ${event.id}`);
//     try {
//       const orderData = event.data;
//       // Simulate some processing that might fail
//       if (orderData.totalAmount <= 0) {
//         // For business rule violations, throw a specific CoreError subclass
//         throw new ValidationError(
//           ErrorCodes.VALIDATION.INVALID_INPUT, // Assuming this specific code exists
//           'Order total amount must be greater than zero.',
//           { orderId: orderData.orderId, totalAmount: orderData.totalAmount }
//         );
//       }

//       if (orderData.isFraudulent) { // Simulate another potential error
//         throw new Error("Simulated critical processing error for fraudulent order.");
//       }

//       // ... successful processing logic ...
//       logger.info(`[OrderProcessor] Successfully processed order ID: ${event.data.orderId}`);
//       // await someOtherService.finalizeOrder(orderData.orderId);

//     } catch (error) {
//       logger.error(`[OrderProcessor] Error handling event '${event.name}' (ID: ${event.id}): ${error.message}`);
//       // Report the error using CoreEventBus's public handleError method.
//       // This ensures the error is processed by the central ErrorSystem.
//       await eventBus.handleError(error, {
//         handlerName: 'OrderCreatedHandler',
//         eventName: event.name,
//         eventId: event.id,
//         eventDataSummary: { orderId: event.data.orderId, customerId: event.data.customerId } // Example context
//       });

//       // Depending on the error and system design, you might:
//       // - Let the error propagate (if not an async handler and not caught by event bus queue processing)
//       // - Emit a specific failure event (e.g., 'order.processing.failed')
//       // - Retry the operation (with caution, implement backoff/limits)
//       // - Move the event to a dead-letter queue (if using advanced queuing)
//     }
//   }
// );

// // Example of how an error reported by a listener might be handled by ErrorSystem:
// // errorSystem.registerHandler('ValidationError', async (validationError, context) => {
// //   logger.warn(`[GlobalValidationErrorHandler] Caught by ErrorSystem: ${validationError.message}`, {
// //     code: validationError.code,
// //     details: validationError.details,
// //     contextFromListener: context
// //   });
// //   // Maybe send to a specific channel or metrics system
// // });
```

**Best Practices:**
* **Obtain `CoreEventBus` via `EventBusSystem`**: Don't attempt to create standalone `CoreEventBus` instances; use the centrally managed one.
* **Clear Event Naming**: Use the `domain.entity.action` convention from `NamingConventions`. Define event name constants (e.g., in `module.events.js`).
* **Immutable Event Data**: Treat `event.data` as immutable within handlers.
* **Idempotent Handlers**: Design handlers to be idempotent if they might process the same logical event more than once (especially with queues or potential retries).
* **Focused Handlers**: Keep event handlers focused on a single responsibility. Complex logic should be delegated to services.
* **Unsubscribe**: In components with a lifecycle (like `CoreModule`), always `unsubscribe` from events in their shutdown/cleanup phase to prevent memory leaks.
* **Contextual Error Reporting**: When using `coreEventBus.handleError()` in a listener, provide rich context.
* **Queuing Strategy**: Use queuing for non-critical events or tasks that can be deferred to improve immediate responsiveness. Have a strategy for processing queues.

## 7. Testing Strategy Notes
* **`CoreEventBus`**:
    * Test `emit` with and without listeners, with and without queuing.
    * Test `subscribe` for exact, pattern, and wildcard matches, ensuring handlers receive the correct standardized event object. Test `unsubscribe`.
    * Test `queueEvent`, `processQueue` (including batching and error handling in listeners during processing), `processAllQueues`.
    * Test `trackEvent`, `getHistory`, `getAllHistory`, and `maxHistorySize` enforcement.
    * Test `reset()` and `shutdown()` for complete cleanup.
    * Test `handleError` correctly forwards to a mock `ErrorSystem`.
    * Test internal error handling (`_handleInternalError`) paths.
    * Verify all metrics and health check outputs.
* **`EventBusSystem`**:
    * Test `initialize` correctly creates and initializes `CoreEventBus`.
    * Test `getEventBus()` returns the correct instance or throws if not ready.
    * Test `shutdown()` correctly calls `CoreEventBus.shutdown()`.
    * Test event forwarding logic from `CoreEventBus` to `EventBusSystem` listeners if specific forwarding rules are maintained beyond lifecycle.
    * Verify its own lifecycle, health, metrics, and internal error handling.

## 8. Future Considerations & Potential Enhancements
(Drawn from `event-bus-docs.md` and broader EDA patterns)
* **Advanced Event Routing**: Introduce topic-based routing, content-based filtering, or even a dedicated message broker for more complex scenarios.
* **Event Schema Validation**: Implement schema validation for event payloads (e.g., using JSON Schema) upon emission or before handler invocation to ensure data integrity.
* **Event Versioning**: Support for versioning event schemas to manage changes over time without breaking existing subscribers.
* **Dead Letter Queues (DLQ)**: For events that consistently fail processing in queues, move them to a DLQ for later inspection and manual intervention.
* **Event Persistence & Sourcing**: Option to durably store all events, enabling event replay, auditing, and event sourcing patterns.
* **Distributed Event Bus**: For microservice architectures or distributed deployments, integrate or evolve towards a distributed event bus solution (e.g., Kafka, RabbitMQ, NATS) that ensures reliable cross-service communication.
* **Enhanced Observability**: Integrate event flows with distributed tracing systems for better end-to-end visibility of asynchronous operations.
* **Transactional Outbox Pattern**: For ensuring atomicity between database state changes and event emissions.


// src/core/event/index.js

/**
 * @file src/core/event/index.js
 * @description Barrel file for exporting event system components.
 */

import { CoreEventBus, createEventBus } from './CoreEventBus.js';
import { EventBusSystem, createEventBusSystem } from './EventBusSystem.js';

export {
  CoreEventBus,
  createEventBus,
  EventBusSystem,
  createEventBusSystem,
};

// Optional default export:
// export default {
//   CoreEventBus,
//   createEventBus,
//   EventBusSystem,
//   createEventBusSystem,
// };


// src/core/module/CoreModule.js

/**
 * @file CoreModule.js
 * @description Base class for all business logic modules in the TSMIS.
 * Provides standardized lifecycle, dependency management, error handling, eventing,
 * health monitoring, and metrics tracking.
 */

import { EventEmitter } from 'events';
import { CoreEventBus } from '../event/CoreEventBus.js'; // Only needed for type hint in createModule default
import { ModuleError, ValidationError } from '../errors/index.js'; // Assuming errors/index.js exports these
import { ErrorCodes } from '../errors/ErrorCodes.js';
import { SYSTEM_STATUS, LIFECYCLE_EVENTS, DEFAULT_CONFIG } from '../common/SystemConstants.js';
import { safeHandleError, createStandardHealthCheckResult } from '../common/ErrorUtils.js';

export class CoreModule extends EventEmitter {
  static dependencies = ['errorSystem', 'eventBusSystem', 'config']; // [cite: 764]
  static version = '2.0.0'; // Example version bump

  /**
   * Creates a new CoreModule instance.
   * @param {object} [deps={}] - Dependencies for the CoreModule.
   * @param {object} [deps.errorSystem] - The ErrorSystem instance.
   * @param {object} [deps.eventBusSystem] - The EventBusSystem instance.
   * @param {object} [deps.config={}] - Module-specific configuration.
   */
  constructor(deps = {}) { // [cite: 765]
    super();
    this.deps = { // Ensure all declared dependencies are at least null or an empty object if not provided
      errorSystem: deps.errorSystem,
      eventBusSystem: deps.eventBusSystem,
      config: deps.config || {}, // Module specific config is under this.config directly
      ...deps // Spread other dependencies like 'database'
    };
    this.config = this.deps.config; // Direct access to module's own config section [cite: 766]

    // Attempt to get eventBus instance early, may be null if eventBusSystem not ready
    // Modules should ideally use this.eventBus only after their own onInitialize.
    try {
        this.eventBus = deps.eventBusSystem?.getEventBus(); // [cite: 766]
    } catch (e) {
        // eventBusSystem might not be initialized when module constructor runs
        // this.eventBus will be re-fetched in initialize()
        this.eventBus = null;
    }


    // this.initialized is driven by this.state.status [cite: 766]
    this.healthCheckInterval = null; // [cite: 769]
    this.healthCheckIntervalMs = this.config?.healthCheckIntervalMs || DEFAULT_CONFIG.DEFAULT_HEALTH_CHECK_INTERVAL;

    this.state = {
      status: SYSTEM_STATUS.CREATED,
      startTime: null,
      errors: [],
      metrics: new Map(),
      healthChecks: new Map(),
      lastHealthCheck: null, // [cite: 767]
    };

    // Validate dependencies immediately upon construction [cite: 768]
    // This might be too early if dependencies are resolved by a container later.
    // Moved to initialize() to ensure dependencies are resolved by a container first.
    // this.validateDependencies();

    this.registerHealthCheck(`${this.constructor.name.toLowerCase()}.state`, this.checkModuleState.bind(this));
  }

  /**
   * Validates that required dependencies are provided and are valid.
   * This should be called by the ModuleSystem or Container after instantiation and DI.
   * Or at the beginning of this.initialize().
   * @private
   */
  _validateDependencies() { //
    const missing = CoreModule.dependencies.filter(dep => !this.deps[dep]); //
    if (missing.length > 0) { // [cite: 770]
      throw new ModuleError( //
        ErrorCodes.MODULE.MISSING_DEPENDENCIES, // [cite: 770]
        `${this.constructor.name}: Missing required dependencies: ${missing.join(', ')}`, //
        { moduleName: this.constructor.name, missingDeps: missing } //
      );
    }
    if (this.deps.eventBusSystem && typeof this.deps.eventBusSystem.getEventBus !== 'function') { // [cite: 771]
      throw new ModuleError( //
        ErrorCodes.MODULE.INVALID_DEPENDENCY, //
        `${this.constructor.name}: EventBusSystem dependency is invalid (missing getEventBus method).`, // [cite: 772]
        { moduleName: this.constructor.name, dependency: 'eventBusSystem' }
      );
    }
    if (this.deps.errorSystem && typeof this.deps.errorSystem.handleError !== 'function') { // [cite: 772]
      throw new ModuleError( //
        ErrorCodes.MODULE.INVALID_DEPENDENCY, //
        `${this.constructor.name}: ErrorSystem dependency is invalid (missing handleError method).`, // [cite: 773]
        { moduleName: this.constructor.name, dependency: 'errorSystem' }
      );
    }
  }

  /**
   * Handles internal operational errors of the CoreModule.
   * @private
   */
  async _handleInternalError(error, context = {}) {
    const errorToLog = !(error instanceof ModuleError || error instanceof ValidationError)
      ? new ModuleError(ErrorCodes.MODULE.INTERNAL_ERROR || 'INTERNAL_ERROR', error.message, context, { cause: error })
      : error;

    this.state.errors.push({ error: errorToLog, timestamp: new Date().toISOString(), context });
    if (this.state.errors.length > (this.config?.maxErrorHistory || DEFAULT_CONFIG.MAX_ERROR_HISTORY)) {
      this.state.errors.shift();
    }
    this.recordMetric(`${this.constructor.name.toLowerCase()}.errors.internal`, 1, { errorName: errorToLog.name, errorCode: errorToLog.code });
    await safeHandleError(this.deps.errorSystem, errorToLog, { source: this.constructor.name, ...context });
  }

  /**
   * Validates the module's configuration.
   * Calls the onValidateConfig hook for module-specific validation.
   * @returns {Promise<boolean>} True if configuration is valid.
   * @throws {ModuleError} if validation fails.
   */
  async validateConfig() { //
    try {
      if (this.config === null || typeof this.config !== 'object') { // [cite: 774]
        throw new ValidationError( //
          ErrorCodes.CONFIG.INVALID_CONFIG, //
          `${this.constructor.name}: Configuration must be an object.`,
           { moduleName: this.constructor.name }
        );
      }
      await this.onValidateConfig(); // [cite: 774]
      this.recordMetric(`${this.constructor.name.toLowerCase()}.config.validation.success`, 1);
      return true; //
    } catch (error) {
      this.recordMetric(`${this.constructor.name.toLowerCase()}.config.validation.failure`, 1, { error: error.code });
      // Wrap in ModuleError if not already one from onValidateConfig
      const configError = error instanceof ModuleError || error instanceof ValidationError ? error : new ModuleError(
        ErrorCodes.MODULE.CONFIG_VALIDATION_FAILED, // [cite: 775]
        `${this.constructor.name}: Failed to validate configuration.`, //
        { moduleName: this.constructor.name, originalMessage: error.message }, //
        { cause: error } //
      );
      await this._handleInternalError(configError, { phase: 'validateConfig' });
      throw configError; //
    }
  }

  /**
   * Initializes the module. This is the main entry point for module startup.
   * @returns {Promise<CoreModule>} This instance.
   */
  async initialize() { //
    if (this.state.status === SYSTEM_STATUS.RUNNING || this.state.status === SYSTEM_STATUS.INITIALIZING) {
      const err = new ModuleError(ErrorCodes.MODULE.ALREADY_INITIALIZED, `${this.constructor.name} is already initialized or initializing.`); // [cite: 777]
      await this._handleInternalError(err);
      return this;
    }

    // Emit module-specific initializing event
    super.emit(`${LIFECYCLE_EVENTS.INITIALIZING}:${this.constructor.name.toLowerCase()}`);
    this.state.status = SYSTEM_STATUS.INITIALIZING; // [cite: 778]
    this.state.startTime = Date.now(); // [cite: 778]

    try {
      this._validateDependencies(); // Validate dependencies now that they should be injected

      // Re-fetch eventBus here, as eventBusSystem should be initialized now
      if (this.deps.eventBusSystem && typeof this.deps.eventBusSystem.getEventBus === 'function') {
          try {
            this.eventBus = this.deps.eventBusSystem.getEventBus();
          } catch (e) {
            // eventBusSystem might throw if it's not running, treat as dependency issue
             throw new ModuleError(
                ErrorCodes.MODULE.DEPENDENCY_NOT_READY,
                `${this.constructor.name}: EventBusSystem is not ready.`,
                { moduleName: this.constructor.name, dependency: 'eventBusSystem' },
                { cause: e }
            );
          }
      } else if (!this.eventBus) { // If still no eventBus and eventBusSystem was expected
          throw new ModuleError(ErrorCodes.MODULE.INVALID_DEPENDENCY, `${this.constructor.name}: EventBus could not be obtained from EventBusSystem.`);
      }


      await this.validateConfig(); // [cite: 778]
      await this.onConfigure(); // [cite: 778]
      await this.setupEventHandlers(); // [cite: 779]
      await this.setupHealthChecks(); // [cite: 779]
      await this.onInitialize(); // [cite: 780]

      this.startHealthChecks(); // [cite: 781]

      this.state.status = SYSTEM_STATUS.RUNNING; // [cite: 782]
      this.recordMetric(`${this.constructor.name.toLowerCase()}.initialized.success`, 1);
      // Emit module-specific initialized event
      await this.emit(`module:initialized`, { // Original event name
        name: this.constructor.name,
        timestamp: new Date().toISOString(),
      });
      // Also emit standardized system event
      super.emit(`${LIFECYCLE_EVENTS.INITIALIZED}:${this.constructor.name.toLowerCase()}`, { timestamp: new Date().toISOString() });
      super.emit(`${LIFECYCLE_EVENTS.RUNNING}:${this.constructor.name.toLowerCase()}`, { timestamp: new Date().toISOString() });


    } catch (error) {
      this.state.status = SYSTEM_STATUS.ERROR; // [cite: 783]
      this.recordMetric(`${this.constructor.name.toLowerCase()}.initialized.failure`, 1, { error: error.code }); //
      // Log this initialization failure using internal handler
      await this._handleInternalError(error, { phase: 'initialization' }); // [cite: 785] (adapted)
      // Re-throw to signal failure to the ModuleSystem or Container
      const initFailedError = error instanceof ModuleError || error instanceof ValidationError ? error : new ModuleError(
        ErrorCodes.MODULE.INITIALIZATION_FAILED, // [cite: 785]
        `${this.constructor.name}: Failed to initialize.`, //
        { moduleName: this.constructor.name, originalMessage: error.message }, //
        { cause: error } //
      );
      // Emit specific error event
      await this.emit('module:error', { module: this.constructor.name, error: initFailedError, context: { phase: 'initialization' }});
      throw initFailedError; //
    }
    return this; // [cite: 783]
  }

  /**
   * Sets up default and module-specific health checks.
   */
  async setupHealthChecks() { //
    // Default state health check is already registered in constructor
    await this.onSetupHealthChecks(); // [cite: 787] Hook for subclasses
  }

  registerHealthCheck(name, checkFn) { //
    if (typeof checkFn !== 'function') { //
      const err = new ModuleError(ErrorCodes.MODULE.INVALID_HEALTH_CHECK, `${this.constructor.name}: Health check '${name}' must be a function.`); // [cite: 789]
      this._handleInternalError(err);
      throw err;
    }
    this.state.healthChecks.set(name, checkFn); //
  }

  /**
   * Starts periodic health check monitoring for this module.
   */
  startHealthChecks() { //
    if (this.healthCheckInterval) {
      clearInterval(this.healthCheckInterval);
    }
    this.healthCheckInterval = setInterval(async () => { //
      try {
        const health = await this.checkHealth(); //
        this.state.lastHealthCheck = health; //
        if (health.status !== SYSTEM_STATUS.HEALTHY) { //
          const healthError = new ModuleError( //
            ErrorCodes.MODULE.UNHEALTHY, // Assuming this code exists [cite: 790]
            `${this.constructor.name} health check reported: ${health.status}`, //
            { moduleName: this.constructor.name, healthDetails: health } //
          );
          // Use public handleError for health issues as they are operational, not internal setup errors
          await this.handleError(healthError, { phase: 'periodic-health-check' });
        }
      } catch (error) {
        // Error in the checkHealth logic itself
        await this._handleInternalError(error, { phase: 'execute-periodic-health-check' });
      }
    }, this.healthCheckIntervalMs); // [cite: 791]
  }

  /**
   * Performs all registered health checks for this module.
   * @returns {Promise<object>} Aggregated health check result.
   */
  async checkHealth() { //
    const results = {}; //
    let overallStatus = SYSTEM_STATUS.HEALTHY; //

    for (const [name, checkFn] of this.state.healthChecks) { // [cite: 792]
      try {
        const checkResult = await checkFn(); // Expects { status, detail, errors } from createStandardHealthCheckResult
        results[name] = checkResult; //
        if (checkResult.status !== SYSTEM_STATUS.HEALTHY) { // [cite: 793]
          overallStatus = (overallStatus === SYSTEM_STATUS.HEALTHY && checkResult.status === SYSTEM_STATUS.DEGRADED)
            ? SYSTEM_STATUS.DEGRADED
            : SYSTEM_STATUS.UNHEALTHY; // If any is unhealthy, overall is unhealthy [cite: 794]
        }
      } catch (error) {
        results[name] = createStandardHealthCheckResult(SYSTEM_STATUS.UNHEALTHY, { error: 'Health check threw an exception' }, [error]); // [cite: 795]
        overallStatus = SYSTEM_STATUS.UNHEALTHY; // [cite: 795]
      }
    }
    return { //
      name: this.constructor.name, //
      version: this.constructor.version, //
      status: overallStatus, //
      timestamp: new Date().toISOString(), //
      uptime: this.state.startTime ? Date.now() - this.state.startTime : 0,
      errorCount: this.state.errors.length, // Internal errors of this module
      checks: results, //
    };
  }

  /**
   * Public method to handle errors occurring within the module's operations.
   * Logs the error, forwards to ErrorSystem, and emits a module:error event.
   * @param {Error} error - The error object.
   * @param {object} [context={}] - Additional context.
   * @returns {Promise<CoreModule>} This instance.
   */
  async handleError(error, context = {}) { //
    // Ensure error is an instance of CoreError or its subclasses
    const errorToHandle = !(error instanceof CoreError)
        ? new ModuleError(ErrorCodes.MODULE.OPERATION_FAILED || 'OPERATION_FAILED', error.message, context, { cause: error })
        : error;

    // Log to internal state errors array
    this.state.errors.push({ error: errorToHandle, timestamp: new Date().toISOString(), context: context || {} }); // [cite: 797]
    if (this.state.errors.length > (this.config?.maxErrorHistory || DEFAULT_CONFIG.MAX_ERROR_HISTORY)) { //
      this.state.errors.shift(); // [cite: 798]
    }
    this.recordMetric(`${this.constructor.name.toLowerCase()}.errors.operational`, 1, { errorName: errorToHandle.name, errorCode: errorToHandle.code });

    // Forward to global ErrorSystem
    await safeHandleError(this.deps.errorSystem, errorToHandle, { //
      module: this.constructor.name, //
      ...(context || {}) //
    });

    // Emit module-specific error event
    // Use super.emit to avoid potential loop if this.emit is overridden with complex logic
    // that itself could error and call handleError.
    super.emit('module:error', { //
      module: this.constructor.name, //
      error: errorToHandle, //
      context: context || {} //
    });
    return this; // [cite: 802]
  }

  /**
   * Emits an event locally on this module instance and broadcasts it via the global EventBus.
   * @param {string} eventName - The name of the event.
   * @param {...any} args - Arguments to pass to the event listeners and EventBus.
   * @returns {Promise<boolean>} Result of local emission.
   */
  async emit(eventName, ...args) { //
    // Local emission using EventEmitter's emit
    const localEmitResult = super.emit(eventName, ...args); // [cite: 803]

    // Broadcast through global EventBus if available and the module is running
    if (this.eventBus && typeof this.eventBus.emit === 'function' && this.state.status === SYSTEM_STATUS.RUNNING) { // [cite: 803]
      try {
        // CoreEventBus.emit expects (eventName, data, options)
        // Assume args[0] is data, and args[1] (if present) is options for CoreEventBus
        await this.eventBus.emit(eventName, args[0], args[1] || {}); // [cite: 804]
      } catch (busError) {
        // Handle error from eventBus.emit itself
        await this.handleError(busError, { //
          phase: 'event-bus-emit', //
          event: eventName, //
          argsSummary: args.map(arg => typeof arg).join(', ')
        });
        // Do not rethrow busError here as localEmit might have succeeded.
        // The error is handled and logged.
      }
    }
    return localEmitResult; // [cite: 806]
  }

  /**
   * Shuts down the module, cleaning up resources.
   * @returns {Promise<CoreModule>} This instance.
   */
  async shutdown() { //
    if (this.state.status === SYSTEM_STATUS.SHUTDOWN || this.state.status === SYSTEM_STATUS.SHUTTING_DOWN) { // [cite: 807]
      return this; //
    }
    super.emit(`${LIFECYCLE_EVENTS.SHUTTING_DOWN}:${this.constructor.name.toLowerCase()}`);
    this.state.status = SYSTEM_STATUS.SHUTTING_DOWN; // [cite: 807]
    const shutdownStartTime = Date.now();

    if (this.healthCheckInterval) { // [cite: 808]
      clearInterval(this.healthCheckInterval); //
      this.healthCheckInterval = null; // [cite: 808]
    }

    try {
      await this.onShutdown(); // Hook for subclass cleanup [cite: 809]

      this.state.status = SYSTEM_STATUS.SHUTDOWN; // [cite: 809]
      this.state.startTime = null; // [cite: 809]
      const shutdownTime = Date.now() - shutdownStartTime;
      this.recordMetric(`${this.constructor.name.toLowerCase()}.shutdown.time`, shutdownTime);
      this.recordMetric(`${this.constructor.name.toLowerCase()}.shutdown.success`, 1);
      // Emit module-specific shutdown event
      await this.emit('module:shutdown', { // Original event name
        name: this.constructor.name,
        timestamp: new Date().toISOString(),
      });
      // Also emit standardized system event
      super.emit(`${LIFECYCLE_EVENTS.SHUTDOWN}:${this.constructor.name.toLowerCase()}`, { timestamp: new Date().toISOString(), durationMs: shutdownTime });

    } catch (error) {
      this.state.status = SYSTEM_STATUS.ERROR; // [cite: 811]
      this.recordMetric(`${this.constructor.name.toLowerCase()}.shutdown.failure`, 1, { error: error.code }); // [cite: 813] (adapted)
      await this._handleInternalError(error, { phase: 'shutdown' }); // (adapted)
      const shutdownFailedError = error instanceof ModuleError || error instanceof ValidationError ? error : new ModuleError( //
        ErrorCodes.MODULE.SHUTDOWN_FAILED, // [cite: 813]
        `${this.constructor.name}: Failed to shutdown.`, //
        { moduleName: this.constructor.name, originalMessage: error.message }, //
        { cause: error } //
      );
      await this.emit('module:error', { module: this.constructor.name, error: shutdownFailedError, context: { phase: 'shutdown' }});
      throw shutdownFailedError; //
    }
    return this; // [cite: 811]
  }

  // --- Lifecycle Hooks for subclasses to override ---
  async onValidateConfig() { return true; } //
  async onConfigure() { /* Default: no-op */ } //
  async setupEventHandlers() { /* Default: no-op */ } //
  async onSetupHealthChecks() { /* Default: no-op */ } //
  async onInitialize() { /* Default: no-op */ } //
  async onShutdown() { /* Default: no-op */ } //

  // --- Metrics ---
  recordMetric(name, value, tags = {}) { // [cite: 821]
    this.state.metrics.set(name, { value, timestamp: Date.now(), tags }); //
  }

  getMetrics() {
    const metrics = {};
    for (const [name, data] of this.state.metrics) {
      metrics[name] = data;
    }
    return metrics;
  }

  // --- Health Check State & Status ---
  async checkModuleState() {
    return createStandardHealthCheckResult(
      this.state.status === SYSTEM_STATUS.RUNNING ? SYSTEM_STATUS.HEALTHY : SYSTEM_STATUS.UNHEALTHY,
      {
        currentStatus: this.state.status,
        uptime: this.state.startTime ? Date.now() - this.state.startTime : 0,
        internalErrorCount: this.state.errors.length,
        lastHealthCheckStatus: this.state.lastHealthCheck?.status || 'N/A'
      }
    );
  }

  getSystemStatus() {
    return {
        name: this.constructor.name,
        version: CoreModule.version,
        status: this.state.status,
        uptime: this.state.startTime ? Date.now() - this.state.startTime : 0,
        initialized: this.state.status === SYSTEM_STATUS.RUNNING,
        errorCount: this.state.errors.length,
        timestamp: new Date().toISOString(),
        lastHealthCheck: this.state.lastHealthCheck ? {
            status: this.state.lastHealthCheck.status,
            timestamp: this.state.lastHealthCheck.timestamp
        } : null
    };
  }
}

/**
 * Factory function for creating a CoreModule instance.
 * Provides default no-op dependencies if not supplied, useful for testing or basic modules.
 * @param {object} [deps={}] - Dependencies for the CoreModule.
 * @returns {CoreModule}
 */
export function createModule(deps = {}) { //
  const defaultDeps = { //
    errorSystem: { //
      handleError: async (error, context) => { console.error("Default No-Op ErrorSystem:", error, context); }
    },
    eventBusSystem: { //
      getEventBus: () => { //
        // Return a simple EventEmitter or a minimal CoreEventBus mock if no full bus needed for tests
        // For robustness, if createEventBus is available, use it.
        // This default is primarily for isolated testing or if eventBus is truly optional.
        try {
            return new CoreEventBus({ // [cite: 822] (adjusted to use CoreEventBus)
                errorSystem: deps.errorSystem || { handleError: async () => {} },
                config: deps.config || {}
            });
        } catch(e) {
            console.warn("Failed to create default CoreEventBus in createModule, falling back to EventEmitter", e);
            return new EventEmitter();
        }
      }
    },
    config: {} // [cite: 822]
  };
  const mergedDeps = { //
    ...defaultDeps,
    ...deps,
    // Ensure specific config for the module is under the 'config' key passed to constructor
    config: deps.config || defaultDeps.config // This `deps.config` is the module-specific config
  };
  return new CoreModule(mergedDeps); //
}

// Default export was an object in original file. Exporting class and factory separately is more common for ES Modules.
// export default { CoreModule, createModule };


// src/core/module/ModuleSystem.js

/**
 * @file ModuleSystem.js
 * @description Manages the lifecycle, registration, and dependencies of CoreModules.
 */

import { EventEmitter } from 'events';
import { CoreModule } from './CoreModule.js'; //
import { ModuleError, ValidationError } from '../errors/index.js'; //
import { ErrorCodes } from '../errors/ErrorCodes.js';
import { SYSTEM_STATUS, LIFECYCLE_EVENTS, DEFAULT_CONFIG } from '../common/SystemConstants.js';
import { safeHandleError, createStandardHealthCheckResult } from '../common/ErrorUtils.js';

export class ModuleSystem extends EventEmitter {
  static dependencies = ['errorSystem', 'eventBusSystem', 'config']; // [cite: 825]
  static version = '2.0.0'; // Example version bump

  /**
   * Creates a new ModuleSystem instance.
   * @param {object} [deps={}] - Dependencies for the ModuleSystem.
   * @param {object} [deps.errorSystem] - The ErrorSystem instance.
   * @param {object} [deps.eventBusSystem] - The EventBusSystem instance.
   * @param {object} [deps.config={}] - Global configuration.
   */
  constructor(deps = {}) { // Constructor now uses deps = {}
    super();
    this.deps = { // Ensure all declared dependencies are at least null or an empty object
      errorSystem: deps.errorSystem,
      eventBusSystem: deps.eventBusSystem,
      config: deps.config || {},
      ...deps
    };

    this.modules = new Map(); // [cite: 826]
    // this.initialized is driven by this.state.status

    // Attempt to get eventBus instance early
    try {
        this.eventBus = this.deps.eventBusSystem?.getEventBus(); // [cite: 827]
    } catch(e) {
        this.eventBus = null; // Will be re-fetched in initialize
    }


    this.state = {
      status: SYSTEM_STATUS.CREATED,
      startTime: null,
      errors: [], // For internal errors of ModuleSystem itself
      metrics: new Map(),
      moduleHealth: new Map(), // Stores last known health of each module [cite: 828]
      healthCheckIntervals: new Map(), // Tracks intervals for health monitoring [cite: 828]
      healthChecks: new Map(), // Health checks for ModuleSystem itself
    };

    this._validateDependencies(); // Validate early in constructor [cite: 829]
    this.setupDefaultHealthChecks();
  }

  /**
   * Validates that required dependencies are provided and are valid.
   * @private
   */
  _validateDependencies() { //
    const missing = ModuleSystem.dependencies.filter(dep => !this.deps[dep]); //
    if (missing.length > 0) { //
      throw new ModuleError( //
        ErrorCodes.MODULE.MISSING_DEPENDENCIES, //
        `ModuleSystem: Missing required dependencies: ${missing.join(', ')}`, //
        { missingDeps: missing } //
      );
    }
    if (!this.deps.eventBusSystem || typeof this.deps.eventBusSystem.getEventBus !== 'function') { //
      throw new ModuleError(ErrorCodes.MODULE.INVALID_DEPENDENCY, 'ModuleSystem: EventBusSystem is invalid.'); //
    }
    if (!this.deps.errorSystem || typeof this.deps.errorSystem.handleError !== 'function') { //
      throw new ModuleError(ErrorCodes.MODULE.INVALID_DEPENDENCY, 'ModuleSystem: ErrorSystem is invalid.'); //
    }
  }

  /**
   * Handles internal operational errors of the ModuleSystem.
   * @private
   */
  async _handleInternalError(error, context = {}) {
    const errorToLog = !(error instanceof ModuleError || error instanceof ValidationError)
      ? new ModuleError(ErrorCodes.MODULE.SYSTEM_ERROR || 'SYSTEM_ERROR', error.message, context, { cause: error })
      : error;

    this.state.errors.push({ error: errorToLog, timestamp: new Date().toISOString(), context });
    if (this.state.errors.length > (this.deps.config?.moduleSystem?.maxErrorHistory || DEFAULT_CONFIG.MAX_ERROR_HISTORY)) {
      this.state.errors.shift();
    }
    this.recordMetric('modulesystem.errors.internal', 1, { errorName: errorToLog.name, errorCode: errorToLog.code });
    await safeHandleError(this.deps.errorSystem, errorToLog, { source: 'ModuleSystem', ...context });
  }

  /**
   * Handles errors reported by individual modules (e.g., via 'module:error' event or health checks).
   * @param {string} moduleName - The name of the module reporting the error.
   * @param {Error} error - The error object from the module.
   * @param {object} [moduleContext={}] - Context provided by the module.
   */
  async handleModuleError(moduleName, error, moduleContext = {}) { //
    // Log this as an operational error received by ModuleSystem
    this.state.errors.push({
      error, // Store the original error from the module
      timestamp: new Date().toISOString(),
      context: { moduleName, ...moduleContext, type: 'moduleReported' }
    });
    if (this.state.errors.length > (this.deps.config?.moduleSystem?.maxErrorHistory || DEFAULT_CONFIG.MAX_ERROR_HISTORY)) {
      this.state.errors.shift();
    }
    this.recordMetric('modulesystem.errors.module_reported', 1, { moduleName, errorName: error.name, errorCode: error.code });

    // Forward the error to the global ErrorSystem.
    // The module itself should have already used its own handleError,
    // so this is ModuleSystem ensuring it's also seen at a higher level if needed.
    // However, the original handleModuleError was directly calling errorSystem.handleError
    // This implies that 'module:error' events are directly handled by ModuleSystem's errorSystem binding.
    // Let's keep that direct forwarding behavior.
    await safeHandleError(this.deps.errorSystem, error, {
      source: 'ModuleSystemRelay', // Indicate it's relayed by ModuleSystem
      module: moduleName,
      originalContext: moduleContext,
      timestamp: new Date().toISOString()
    });

    // Emit a system-level event about the module error
    // Use super.emit to avoid potential loop with ModuleSystem's own emit override
    super.emit('module:error', { //
      module: moduleName,
      error, // The original error from the module
      context: moduleContext, // Context from the module
      timestamp: new Date().toISOString()
    });
  }


  /**
   * Emits an event locally on this ModuleSystem instance and broadcasts it via the global EventBus.
   * @param {string} eventName - The name of the event.
   * @param {...any} args - Arguments to pass to the event listeners and EventBus.
   */
  async emit(eventName, ...args) { //
    const localEmitResult = super.emit(eventName, ...args); //

    if (this.eventBus && typeof this.eventBus.emit === 'function' && this.state.status === SYSTEM_STATUS.RUNNING) { //
      try {
        // Assume args[0] is data, args[1] is options for CoreEventBus
        await this.eventBus.emit(eventName, args[0], args[1] || {}); //
      } catch (busError) {
        await this._handleInternalError(busError, { // (adapted)
          phase: 'event-bus-emit', eventName,
          argsSummary: args.map(arg => typeof arg).join(', ')
        });
      }
    }
    return localEmitResult; //
  }

  /**
   * Registers a module with the system.
   * @param {string} name - The unique name for the module.
   * @param {typeof CoreModule} ModuleClass - The class of the module to register (must extend CoreModule).
   * @param {object} [config={}] - Module-specific configuration.
   * @returns {Promise<CoreModule>} The registered module instance.
   */
  async register(name, ModuleClass, config = {}) { //
    if (!(ModuleClass && ModuleClass.prototype instanceof CoreModule)) { //
      throw new ValidationError( //
        ErrorCodes.VALIDATION.INVALID_MODULE, //
        `${name}: ModuleClass must extend CoreModule.` //
      );
    }
    if (this.modules.has(name)) { //
      throw new ModuleError( //
        ErrorCodes.MODULE.DUPLICATE_MODULE, //
        `${name}: Module is already registered.` //
      );
    }

    try {
      // Merge global config for the module with instance-specific config
      const moduleSpecificGlobalConfig = this.deps.config?.[name] || {};
      const finalConfig = { ...moduleSpecificGlobalConfig, ...config };

      const moduleInstance = new ModuleClass({ //
        ...this.deps, // Pass all ModuleSystem dependencies
        config: finalConfig, // Pass merged config specific to this module instance
      });
      this.modules.set(name, moduleInstance); // [cite: 840]

      // Listen for 'module:error' events directly from this module instance
      // to use ModuleSystem's centralized handling.
      moduleInstance.on('module:error', async ({ module: modNameIgnored, error, context }) => {
        // modNameIgnored should be `name`
        await this.handleModuleError(name, error, context);
      });

      this.recordMetric('modulesystem.modules.registered', 1, { moduleName: name });
      await this.emit('module:registered', { name, timestamp: new Date().toISOString() }); //
      return moduleInstance; //
    } catch (error) {
      const regError = new ModuleError( //
        ErrorCodes.MODULE.REGISTRATION_FAILED, //
        `Failed to register module ${name}.`, //
        { moduleName: name, originalMessage: error.message },
        { cause: error } //
      );
      await this._handleInternalError(regError);
      throw regError; //
    }
  }

  async unregister(name) { //
    const moduleInstance = this.modules.get(name); //
    if (!moduleInstance) return false; //

    try {
      if (moduleInstance.state.status === SYSTEM_STATUS.RUNNING || moduleInstance.state.status === SYSTEM_STATUS.INITIALIZING) { //
        await moduleInstance.shutdown(); //
      }
      // Stop health monitoring for this module
      this.stopModuleHealthMonitoring(name);

      this.modules.delete(name); // [cite: 846]
      this.state.moduleHealth.delete(name); // Clean up health state
      this.recordMetric('modulesystem.modules.unregistered', 1, { moduleName: name });
      await this.emit('module:unregistered', { name, timestamp: new Date().toISOString() }); //
      return true;
    } catch (error) {
      const unregError = new ModuleError( //
        ErrorCodes.MODULE.UNREGISTER_FAILED, //
        `Failed to unregister module ${name}.`, //
        { moduleName: name, originalMessage: error.message },
        { cause: error } //
      );
      await this._handleInternalError(unregError);
      throw unregError; //
    }
  }

  async resolve(name) { //
    const moduleInstance = this.modules.get(name); //
    if (!moduleInstance) { //
      throw new ModuleError(ErrorCodes.MODULE.NOT_FOUND, `Module ${name} is not registered.`); //
    }
    return moduleInstance; //
  }

  /**
   * Initializes all registered modules in their correct dependency order.
   * @returns {Promise<void>}
   */
  async initialize() { //
    if (this.state.status === SYSTEM_STATUS.RUNNING || this.state.status === SYSTEM_STATUS.INITIALIZING) {
      const err = new ModuleError(ErrorCodes.MODULE.ALREADY_INITIALIZED, 'ModuleSystem is already initialized or initializing.'); //
      await this._handleInternalError(err);
      return;
    }

    super.emit(LIFECYCLE_EVENTS.INITIALIZING, { system: 'ModuleSystem' }); // Use super.emit for own lifecycle
    this.state.status = SYSTEM_STATUS.INITIALIZING; //
    this.state.startTime = Date.now(); //

    // Re-fetch eventBus here
     if (this.deps.eventBusSystem && typeof this.deps.eventBusSystem.getEventBus === 'function') {
          try {
            this.eventBus = this.deps.eventBusSystem.getEventBus();
          } catch (e) {
             throw new ModuleError(
                ErrorCodes.MODULE.DEPENDENCY_NOT_READY,
                `ModuleSystem: EventBusSystem is not ready during initialization.`,
                { dependency: 'eventBusSystem' },
                { cause: e }
            );
          }
      } else if (!this.eventBus) {
          throw new ModuleError(ErrorCodes.MODULE.INVALID_DEPENDENCY, `ModuleSystem: EventBus could not be obtained.`);
      }


    try {
      const initOrder = this.resolveDependencyOrder(); //
      for (const name of initOrder) { //
        const moduleInstance = this.modules.get(name); //
        if(moduleInstance) { // Ensure module exists
            await moduleInstance.initialize(); //
            await this.startModuleHealthMonitoring(name); //
        } else {
            // Should ideally not happen if resolveDependencyOrder is correct
            throw new ModuleError(ErrorCodes.MODULE.INTERNAL_ERROR, `Module ${name} found in initOrder but not in registered modules.`);
        }
      }

      this.state.status = SYSTEM_STATUS.RUNNING; //
      this.recordMetric('modulesystem.initialized.success', 1);
      await this.emit('system:initialized', { //
        timestamp: new Date().toISOString(), //
        modules: Array.from(this.modules.keys()), //
      });
      super.emit(LIFECYCLE_EVENTS.INITIALIZED, { system: 'ModuleSystem', timestamp: new Date().toISOString() }); //
      super.emit(LIFECYCLE_EVENTS.RUNNING, { system: 'ModuleSystem', timestamp: new Date().toISOString() });


    } catch (error) {
      this.state.status = SYSTEM_STATUS.ERROR; //
      this.recordMetric('modulesystem.initialized.failure', 1, { error: error.code });
      await this._handleInternalError(error, { phase: 'initialization' }); //
      const initError = error instanceof ModuleError ? error : new ModuleError( //
        ErrorCodes.MODULE.INITIALIZATION_FAILED, //
        'ModuleSystem failed to initialize.', //
        { originalMessage: error.message },
        { cause: error } //
      );
      super.emit('system:error', { system: 'ModuleSystem', error: initError, context: {phase: 'initialization'}});
      throw initError; //
    }
  }

  resolveDependencyOrder() { //
    const visited = new Set(); //
    const visiting = new Set(); //
    const order = []; //

    const visit = (name) => { //
      if (visited.has(name)) return; //
      if (visiting.has(name)) { //
        throw new ModuleError( //
          ErrorCodes.MODULE.CIRCULAR_DEPENDENCY, //
          `Circular dependency detected for module: ${name}. Path: ${Array.from(visiting).join(' -> ')} -> ${name}` //
        );
      }
      visiting.add(name); //

      const moduleInstance = this.modules.get(name); //
      if (!moduleInstance) {
          visiting.delete(name);
          // This case should ideally be caught by dependency checks within modules if a listed dep isn't registered at all.
          // Or if ModuleSystem tries to init a non-existent module.
          throw new ModuleError(ErrorCodes.MODULE.NOT_FOUND, `Module ${name} not found during dependency resolution.`);
      }
      // Use static dependencies from the ModuleClass constructor
      const deps = moduleInstance.constructor.dependencies || []; //

      for (const depName of deps) { //
        // CoreSystem dependencies (like 'errorSystem') are not modules managed by ModuleSystem
        // So, only try to visit if 'depName' refers to another module *registered in this ModuleSystem*
        if (this.modules.has(depName)) { //
          visit(depName); //
        } else if (!ModuleSystem.dependencies.includes(depName) && !CoreModule.dependencies.includes(depName)) {
          // If it's not a known core/system dep and not a registered module, it's a missing module dependency
          throw new ModuleError( //
            ErrorCodes.MODULE.MISSING_DEPENDENCY, //
            `Module '${name}' requires missing module: '${depName}', which is not a registered module or a known core system dependency.`, //
            { requiringModule: name, missingModule: depName }
          );
        }
      }
      visiting.delete(name); //
      visited.add(name); //
      order.push(name); //
    };

    for (const name of this.modules.keys()) { //
      visit(name); //
    }
    return order; //
  }

  async startModuleHealthMonitoring(name) { //
    const moduleInstance = this.modules.get(name); //
    if (!moduleInstance || typeof moduleInstance.checkHealth !== 'function') return; //

    this.stopModuleHealthMonitoring(name); // Clear existing interval for this module

    const intervalMs = moduleInstance.config?.healthCheckIntervalMs ||
                       this.deps.config?.moduleSystem?.defaultHealthCheckIntervalMs ||
                       DEFAULT_CONFIG.DEFAULT_HEALTH_CHECK_INTERVAL;

    const intervalId = setInterval(async () => { //
      try {
        const health = await moduleInstance.checkHealth(); //
        this.state.moduleHealth.set(name, health); // Store the full health object
        this.recordMetric(`modulesystem.module.${name}.health.status`, health.status === SYSTEM_STATUS.HEALTHY ? 1 : 0, { status: health.status });

        if (health.status !== SYSTEM_STATUS.HEALTHY) { //
          // Module's own health check interval might also report this.
          // ModuleSystem logging it provides a central view.
          // The error created by moduleInstance.startHealthChecks already uses moduleInstance.handleError
          // So, this might be redundant unless we want MS to explicitly log it.
          // For now, let module's own health check error reporting (via its handleError) be primary.
          // ModuleSystem's role here is to *collect* the health status.
          // It can emit a generic event if a module becomes unhealthy.
          super.emit('module:unhealthy', { moduleName: name, healthStatus: health.status, healthDetails: health });
        }
      } catch (error) {
        // This error is if moduleInstance.checkHealth() itself throws, not if it returns unhealthy
        const healthCheckError = new ModuleError(
            ErrorCodes.MODULE.HEALTH_CHECK_FAILED,
            `Error executing health check for module ${name}.`,
            { moduleName: name, originalMessage: error.message },
            { cause: error }
        );
        this.state.moduleHealth.set(name, createStandardHealthCheckResult(SYSTEM_STATUS.UNHEALTHY, { error: 'checkHealth execution failed' }, [healthCheckError]));
        await this.handleModuleError(name, healthCheckError, { phase: 'health-monitoring' }); // Use ModuleSystem's handler
      }
    }, intervalMs); //
    this.state.healthCheckIntervals.set(name, intervalId); //
  }

  stopModuleHealthMonitoring(name) {
    if (this.state.healthCheckIntervals.has(name)) {
      clearInterval(this.state.healthCheckIntervals.get(name)); //
      this.state.healthCheckIntervals.delete(name);
    }
  }

  /**
   * Shuts down all registered modules in reverse dependency order.
   * @returns {Promise<void>}
   */
  async shutdown() { //
    if (this.state.status === SYSTEM_STATUS.SHUTDOWN || this.state.status === SYSTEM_STATUS.SHUTTING_DOWN) { //
      return;
    }
    super.emit(LIFECYCLE_EVENTS.SHUTTING_DOWN, { system: 'ModuleSystem' });
    this.state.status = SYSTEM_STATUS.SHUTTING_DOWN; //
    const shutdownStartTime = Date.now();

    // Clear all health check intervals
    for (const intervalId of this.state.healthCheckIntervals.values()) { //
      clearInterval(intervalId); //
    }
    this.state.healthCheckIntervals.clear(); //

    try {
      const shutdownOrder = this.resolveDependencyOrder().reverse(); //
      for (const name of shutdownOrder) { //
        const moduleInstance = this.modules.get(name); //
        if (moduleInstance) { //
            await moduleInstance.shutdown(); //
        }
      }

      this.modules.clear(); //
      this.state.moduleHealth.clear();
      this.state.status = SYSTEM_STATUS.SHUTDOWN; // [cite: 894]
      this.state.startTime = null;
      const shutdownTime = Date.now() - shutdownStartTime;
      this.recordMetric('modulesystem.shutdown.time', shutdownTime);
      this.recordMetric('modulesystem.shutdown.success', 1);
      await this.emit('system:shutdown', { timestamp: new Date().toISOString() }); //
      super.emit(LIFECYCLE_EVENTS.SHUTDOWN, { system: 'ModuleSystem', durationMs: shutdownTime, timestamp: new Date().toISOString() });


    } catch (error) {
      this.state.status = SYSTEM_STATUS.ERROR; //
      this.recordMetric('modulesystem.shutdown.failure', 1, { error: error.code });
      await this._handleInternalError(error, { phase: 'shutdown' }); //
      const shutdownError = error instanceof ModuleError ? error : new ModuleError( //
        ErrorCodes.MODULE.SHUTDOWN_FAILED, //
        'ModuleSystem failed to shutdown.', //
        { originalMessage: error.message },
        { cause: error } //
      );
      super.emit('system:error', { system: 'ModuleSystem', error: shutdownError, context: { phase: 'shutdown' } });
      throw shutdownError; //
    }
  }

  // --- State, Health, Metrics for ModuleSystem itself ---
  setupDefaultHealthChecks() {
    this.registerHealthCheck('modulesystem.state', this.checkSystemState.bind(this));
    this.registerHealthCheck('modulesystem.module_overview', this.checkModuleOverviewStatus.bind(this));
    this.registerHealthCheck('modulesystem.all_modules_health', this.getSystemHealth.bind(this)); // Renamed from original file for clarity
  }

  recordMetric(name, value, tags = {}) {
    this.state.metrics.set(name, { value, timestamp: Date.now(), tags });
  }

  getMetrics() {
    const metrics = {};
    for (const [name, data] of this.state.metrics) {
      metrics[name] = data;
    }
    // Optionally aggregate metrics from all managed modules
    // for(const [moduleName, moduleInstance] of this.modules) {
    //    if(typeof moduleInstance.getMetrics === 'function') {
    //        metrics[`module.${moduleName}`] = moduleInstance.getMetrics();
    //    }
    // }
    return metrics;
  }

  registerHealthCheck(name, checkFn) {
    if (typeof checkFn !== 'function') {
        const err = new ModuleError(ErrorCodes.MODULE.INVALID_HEALTH_CHECK, `ModuleSystem Health check '${name}' must be a function.`);
        this._handleInternalError(err);
        throw err;
    }
    this.state.healthChecks.set(name, checkFn);
  }

  async checkHealth() { // Health of ModuleSystem itself
    const results = {};
    let overallStatus = SYSTEM_STATUS.HEALTHY;

    for (const [name, checkFn] of this.state.healthChecks) {
      try {
        const checkResult = await checkFn();
        results[name] = checkResult;
        if (checkResult.status !== SYSTEM_STATUS.HEALTHY) {
          overallStatus = (overallStatus === SYSTEM_STATUS.HEALTHY && checkResult.status === SYSTEM_STATUS.DEGRADED)
            ? SYSTEM_STATUS.DEGRADED
            : SYSTEM_STATUS.UNHEALTHY;
        }
      } catch (error) {
        results[name] = createStandardHealthCheckResult(SYSTEM_STATUS.UNHEALTHY, { error: 'Health check threw an exception' }, [error]);
        overallStatus = SYSTEM_STATUS.UNHEALTHY;
      }
    }
    return {
      name: this.constructor.name,
      version: ModuleSystem.version,
      status: overallStatus,
      timestamp: new Date().toISOString(),
      uptime: this.state.startTime ? Date.now() - this.state.startTime : 0,
      errorCount: this.state.errors.length,
      checks: results,
    };
  }

  async checkSystemState() {
    return createStandardHealthCheckResult(
      this.state.status === SYSTEM_STATUS.RUNNING ? SYSTEM_STATUS.HEALTHY : SYSTEM_STATUS.UNHEALTHY,
      {
        currentStatus: this.state.status,
        uptime: this.state.startTime ? Date.now() - this.state.startTime : 0,
        internalErrorCount: this.state.errors.length
      }
    );
  }

  async checkModuleOverviewStatus() {
    const moduleStatuses = {};
    let degradedCount = 0;
    let unhealthyCount = 0;
    for(const [name, health] of this.state.moduleHealth) {
        moduleStatuses[name] = health.status;
        if(health.status === SYSTEM_STATUS.DEGRADED) degradedCount++;
        if(health.status === SYSTEM_STATUS.UNHEALTHY) unhealthyCount++;
    }
    const status = unhealthyCount > 0 ? SYSTEM_STATUS.UNHEALTHY : (degradedCount > 0 ? SYSTEM_STATUS.DEGRADED : SYSTEM_STATUS.HEALTHY);
    return createStandardHealthCheckResult(status, {
        registeredModuleCount: this.modules.size,
        monitoredModuleCount: this.state.moduleHealth.size,
        unhealthyModuleCount: unhealthyCount,
        degradedModuleCount: degradedCount,
        moduleStatuses
    });
  }

  /**
   * Gets the aggregated health of all managed modules.
   * This was previously named getSystemHealth.
   * @returns {Promise<object>}
   */
  async getSystemModulesHealth() { // (renamed for clarity from getSystemHealth)
    const moduleHealthDetails = {}; //
    let overallSystemStatus = SYSTEM_STATUS.HEALTHY; //

    for (const [name, moduleInstance] of this.modules) { //
      try {
        const health = await moduleInstance.checkHealth(); //
        moduleHealthDetails[name] = health; //
        if (health.status !== SYSTEM_STATUS.HEALTHY) { //
          overallSystemStatus = (overallSystemStatus === SYSTEM_STATUS.HEALTHY && health.status === SYSTEM_STATUS.DEGRADED)
            ? SYSTEM_STATUS.DEGRADED
            : SYSTEM_STATUS.UNHEALTHY; //
        }
      } catch (error) {
        moduleHealthDetails[name] = createStandardHealthCheckResult(SYSTEM_STATUS.UNHEALTHY, {error: `Failed to check health for module ${name}`}, [error]); //
        overallSystemStatus = SYSTEM_STATUS.UNHEALTHY; //
      }
    }

    return { // This is the health detail for one of ModuleSystem's own checks
      status: overallSystemStatus,
      timestamp: new Date().toISOString(),
      detail: {
        uptime: this.state.startTime ? Date.now() - this.state.startTime : 0, // Uptime of ModuleSystem
        modules: moduleHealthDetails, //
        moduleErrorCount: this.state.errors.filter(e => e.context?.type === 'moduleReported').length
      }
    };
  }


  getSystemStatus() {
    return {
        name: this.constructor.name,
        version: ModuleSystem.version,
        status: this.state.status,
        uptime: this.state.startTime ? Date.now() - this.state.startTime : 0,
        initialized: this.state.status === SYSTEM_STATUS.RUNNING,
        errorCount: this.state.errors.length,
        registeredModules: this.modules.size,
        timestamp: new Date().toISOString()
    };
  }
}

/**
 * Factory function for creating a ModuleSystem instance.
 * @param {object} [deps={}] - Dependencies for the ModuleSystem.
 * @returns {ModuleSystem}
 */
export function createModuleSystem(deps = {}) { //
  // Constructor now handles its own dependency validation and defaults for errorSystem/eventBusSystem.
  return new ModuleSystem(deps); //
}

// Default export was an object in original file.
// export default { ModuleSystem, createModuleSystem };


// src/core/module/index.js

/**
 * @file src/core/module/index.js
 * @description Barrel file for exporting module system components.
 */

import { CoreModule, createModule } from './CoreModule.js';
import { ModuleSystem, createModuleSystem } from './ModuleSystem.js';

export {
  CoreModule,
  createModule,
  ModuleSystem,
  createModuleSystem,
};

// Optional default export:
// export default {
//   CoreModule,
//   createModule,
//   ModuleSystem,
//   createModuleSystem,
// };


// src/core/module/module-system.md

# TSMIS ModuleSystem & CoreModule Documentation
Version: 2.0.0 (Refactored Core)

## Table of Contents

1.  [Introduction to the Module Architecture](#1-introduction-to-the-module-architecture)
    * [1.1. Purpose & Philosophy](#11-purpose--philosophy)
    * [1.2. Key Components: `ModuleSystem` and `CoreModule`](#12-key-components-modulesystem-and-coremodule)
2.  [Component: `CoreModule.js` - The Business Module Foundation](#2-component-coremodulejs---the-business-module-foundation)
    * [2.1. Overview & Primary Responsibility](#21-overview--primary-responsibility)
    * [2.2. Key Features Provided to Subclasses](#22-key-features-provided-to-subclasses)
    * [2.3. API Reference (`CoreModule` - for Subclass Implementation)](#23-api-reference-coremodule---for-subclass-implementation)
        * [2.3.1. Constructor & Dependencies](#231-constructor--dependencies)
        * [2.3.2. Configuration (`this.config` & `validateConfig`)](#232-configuration-thisconfig--validateconfig)
        * [2.3.3. Lifecycle Hooks (to be Overridden)](#233-lifecycle-hooks-to-be-overridden)
        * [2.3.4. Error Handling (`handleError`)](#234-error-handling-handleerror)
        * [2.3.5. Event Emission (`emit`)](#235-event-emission-emit)
        * [2.3.6. Health Monitoring (`registerHealthCheck`, `checkHealth`, `startHealthChecks`)](#236-health-monitoring-registerhealthcheck-checkhealth-starthealthchecks)
        * [2.3.7. Metrics Tracking (`recordMetric`, `getMetrics`)](#237-metrics-tracking-recordmetric-getmetrics)
        * [2.3.8. Status Reporting (`getSystemStatus`)](#238-status-reporting-getsystemstatus)
    * [2.4. State Management (`CoreModule` Specifics)](#24-state-management-coremodule-specifics)
    * [2.5. Lifecycle Management (`CoreModule` Process)](#25-lifecycle-management-coremodule-process)
    * [2.6. Static Factory (`createModule`)](#26-static-factory-createmodule)
3.  [Component: `ModuleSystem.js` - The Module Orchestrator](#3-component-modulesystemjs---the-module-orchestrator)
    * [3.1. Overview & Primary Responsibility](#31-overview--primary-responsibility)
    * [3.2. Key Functionalities & API (`ModuleSystem`)](#32-key-functionalities--api-modulesystem)
        * [3.2.1. `initialize()` & `shutdown()`](#321-initialize--shutdown)
        * [3.2.2. Module Registration & Management (`register`, `unregister`, `resolve`)](#322-module-registration--management-register-unregister-resolve)
        * [3.2.3. Dependency Resolution (`resolveDependencyOrder`)](#323-dependency-resolution-resolvedependencyorder)
        * [3.2.4. Module Error Handling (`handleModuleError`)](#324-module-error-handling-handlemoduleerror)
        * [3.2.5. Module Health Monitoring (`startModuleHealthMonitoring`, `getSystemModulesHealth`)](#325-module-health-monitoring-startmodulehealthmonitoring-getsystemmoduleshealth)
    * [3.3. Adherence to Standardization Pillars (Recap for `ModuleSystem`)](#33-adherence-to-standardization-pillars-recap-for-modulesystem)
    * [3.4. State Management (`ModuleSystem` Specifics)](#34-state-management-modulesystem-specifics)
    * [3.5. Lifecycle Management (`ModuleSystem` Process)](#35-lifecycle-management-modulesystem-process)
    * [3.6. Error Handling within `ModuleSystem`](#36-error-handling-within-modulesystem)
    * [3.7. Event Integration (`ModuleSystem` Specifics)](#37-event-integration-modulesystem-specifics)
    * [3.8. Health Monitoring (`ModuleSystem` Specifics)](#38-health-monitoring-modulesystem-specifics)
    * [3.9. Metrics Tracking (`ModuleSystem` Specifics)](#39-metrics-tracking-modulesystem-specifics)
    * [3.10. Static Factory (`createModuleSystem`)](#310-static-factory-createmodulesystem)
4.  [Integrations (Module Architecture Level)](#4-integrations-module-architecture-level)
5.  [Module Lifecycle & Management Flow Diagrams](#5-module-lifecycle--management-flow-diagrams)
6.  [Developing a New Business Module (Best Practices & Example Reference)](#6-developing-a-new-business-module-best-practices--example-reference)
7.  [Testing Strategies for Modules and ModuleSystem](#7-testing-strategies-for-modules-and-modulesystem)
8.  [Future Considerations & Potential Enhancements](#8-future-considerations--potential-enhancements)

---

## 1. Introduction to the Module Architecture

### 1.1. Purpose & Philosophy
The TSMIS Module Architecture, centered around `CoreModule` and orchestrated by `ModuleSystem`, is designed to provide a structured, consistent, and manageable way to build and integrate distinct units of business functionality. The philosophy is to promote modular design, where each module encapsulates a specific domain or capability, can be developed and tested somewhat independently, and integrates smoothly into the overall application through standardized interfaces and lifecycle management.

This approach aims to:
* **Encapsulate Business Logic**: Keep domain-specific logic contained within well-defined module boundaries.
* **Promote Reusability**: While full reusability across different applications might be limited by domain specifics, services within modules can be designed for reuse.
* **Simplify Maintenance**: Changes within one module are less likely to impact others if interactions are well-defined (e.g., via events or stable service interfaces).
* **Standardize Development**: Provide developers with a common framework and base class (`CoreModule`) that handles many cross-cutting concerns (lifecycle, errors, events, health, metrics).

### 1.2. Key Components: `ModuleSystem` and `CoreModule`
* **`CoreModule.js`**: This is an abstract base class. All business modules *must* extend `CoreModule` (or its derivative, `RoutableModule`, if they expose HTTP routes). It provides the standardized structure, lifecycle hooks, and built-in utilities for error handling, eventing, health monitoring, metrics, and configuration handling that all modules will share.
* **`ModuleSystem.js`**: This system is the orchestrator of all `CoreModule` instances. It is responsible for:
    * Registering module classes and their configurations.
    * Instantiating modules and injecting their dependencies (which include core systems like `ErrorSystem`, `EventBusSystem`, `config`, and any other services resolved from the `ContainerSystem`).
    * Managing the ordered initialization and shutdown of all registered modules based on their declared dependencies.
    * Periodically monitoring the health of each initialized module and providing an aggregated health view of all modules.

## 2. Component: `CoreModule.js` - The Business Module Foundation

**(This section details the `CoreModule` base class. For developers creating modules, this is their primary starting point.)**

### 2.1. Overview & Primary Responsibility
`CoreModule` is an abstract base class designed to be the parent of all business logic modules within TSMIS. It does not perform business logic itself but provides a rich, standardized framework and a set of inheritable functionalities to its subclasses. Its primary responsibility is to ensure that all business modules adhere to common patterns for lifecycle, configuration, error handling, communication, and observability.

### 2.2. Key Features Provided to Subclasses
Modules extending `CoreModule` automatically gain:
* **Standardized Lifecycle Hooks**: A predefined set of asynchronous methods (`onValidateConfig`, `onConfigure`, `setupEventHandlers`, `onSetupHealthChecks`, `onInitialize`, `onShutdown`) that are called at specific points in the module's lifecycle by `ModuleSystem`.
* **Dependency Injection**: A constructor pattern `constructor(deps = {})` where `deps` (containing core systems like `errorSystem`, `eventBusSystem`, `config`, and other resolved dependencies) is injected by `ModuleSystem`.
* **Configuration Handling**: Access to module-specific configuration via `this.config` and a dedicated hook (`onValidateConfig`) for validation.
* **Integrated Error Handling**: A `this.handleError(error, context)` method for consistent error processing, which logs the error to the module's state, records a metric, reports it to the global `ErrorSystem` via `safeHandleError`, and emits a local `module:error` event.
* **Event Communication**:
    * Access to the global `CoreEventBus` via `this.eventBus` (obtained from `this.deps.eventBusSystem.getEventBus()` during `initialize`).
    * An `async this.emit(eventName, ...args)` method that emits an event both locally on the module instance and broadcasts it via the global `CoreEventBus`.
* **Health Monitoring**:
    * `registerHealthCheck(name, checkFn)` to add custom health checks specific to the module's responsibilities or dependencies.
    * `async checkHealth()` to execute all its registered checks and return a standardized health report.
    * `startHealthChecks()` method to initiate periodic self-monitoring (called by `ModuleSystem` after module initialization).
    * A default `modulename.state` health check.
* **Metrics Tracking**: `recordMetric(name, value, tags)` and `getMetrics()` methods for custom and standardized metric collection.
* **Standardized State**: An internal `this.state` object adhering to the core system standard (`status`, `startTime`, `errors`, `metrics`, `healthChecks`), plus `lastHealthCheck`.

### 2.3. API Reference (`CoreModule` - for Subclass Implementation)

#### 2.3.1. Constructor & Dependencies
* **`constructor(deps = {})`**: Subclasses should call `super(deps)`. The `deps` object is passed by `ModuleSystem` and includes:
    * `errorSystem`: Instance of `ErrorSystem`.
    * `eventBusSystem`: Instance of `EventBusSystem`.
    * `config`: Module-specific configuration object passed during `ModuleSystem.register()`.
    * Any other dependencies listed in the subclass's `static dependencies` array, resolved by `ContainerSystem`.
* **`static dependencies: string[]`**: Subclasses MUST define this array to list names of other components/services (registered in `ContainerSystem`) or other modules (registered in `ModuleSystem`) they depend on. `CoreModule` itself declares `['errorSystem', 'eventBusSystem', 'config']`. Subclasses should extend this: `static dependencies = [...CoreModule.dependencies, 'myCustomService', 'anotherModule'];`.

#### 2.3.2. Configuration (`this.config` & `validateConfig`)
* **`this.config`**: The module-specific configuration object is available as `this.config`.
* **`async validateConfig(): Promise<boolean>`**: This method is called by `CoreModule.initialize()`. It, in turn, calls the `async onValidateConfig()` hook that subclasses should override for their specific configuration validation logic. Throws `ValidationError` or `ModuleError` on failure.

#### 2.3.3. Lifecycle Hooks (to be Overridden)
These `async` methods are placeholders in `CoreModule` and are intended for subclasses to implement their specific logic. They are called in sequence during `CoreModule.initialize()` and `CoreModule.shutdown()`.
* **`async onValidateConfig(): Promise<boolean>`**: Validate `this.config`. Throw error on invalid config.
* **`async onConfigure(): Promise<void>`**: Apply validated `this.config` to instance properties, perform initial setup based on config.
* **`async setupEventHandlers(): Promise<void>`**: Subscribe to `CoreEventBus` events. Store subscription IDs for cleanup.
* **`async onSetupHealthChecks(): Promise<void>`**: Register module-specific health checks using `this.registerHealthCheck()`.
* **`async onInitialize(): Promise<void>`**: Perform final initialization tasks (e.g., connect to resources, start timers, load initial data). For `RoutableModule`, this is where routes are typically defined via `this.registerRoute()`.
* **`async onShutdown(): Promise<void>`**: Clean up all resources, unsubscribe from events, clear intervals/timeouts.

#### 2.3.4. Error Handling (`handleError`)
* **`async handleError(error: Error, context = {}): Promise<CoreModule>`**: Used by subclasses to report operational errors. Logs to module's `this.state.errors`, records a metric, reports to global `ErrorSystem` via `safeHandleError`, and emits a local `module:error` event.

#### 2.3.5. Event Emission (`emit`)
* **`async emit(eventName: string, ...args: any[]): Promise<boolean>`**: Emits an event locally on the module instance and broadcasts it to the global `CoreEventBus` (if available and module is running). `CoreEventBus` expects `(eventName, data, options)`.

#### 2.3.6. Health Monitoring (`registerHealthCheck`, `checkHealth`, `startHealthChecks`)
* **`registerHealthCheck(name: string, checkFn: Function): void`**: Adds a health check function.
* **`async checkHealth(): Promise<object>`**: Executes all registered checks and returns a standard health report object.
* **`startHealthChecks(): void`**: Initiates periodic calls to `this.checkHealth()`, storing results in `this.state.lastHealthCheck` and reporting unhealthy states via `this.handleError()`. The interval is `this.healthCheckIntervalMs` (from config or default).

#### 2.3.7. Metrics Tracking (`recordMetric`, `getMetrics`)
* **`recordMetric(name: string, value: any, tags = {}): void`**: Records a metric to `this.state.metrics`.
* **`getMetrics(): object`**: Returns all metrics for the module.

#### 2.3.8. Status Reporting (`getSystemStatus`)
* **`getSystemStatus(): object`**: Returns a summary object of the module's current status, including lifecycle status, uptime, error count, and last health check status.

### 2.4. State Management (`CoreModule` Specifics)
`CoreModule` implements the standard `this.state` object, and adds one specific property:
* **`lastHealthCheck: object | null`**: Stores the full result object from the most recent periodic execution of `this.checkHealth()`.

### 2.5. Lifecycle Management (`CoreModule` Process)
The `CoreModule.initialize()` method orchestrates the following sequence:
1.  Validates its own dependencies (`_validateDependencies`).
2.  Ensures `this.eventBus` is available from `this.deps.eventBusSystem`.
3.  Calls `this.validateConfig()` (which calls `onValidateConfig`).
4.  Calls `this.onConfigure()`.
5.  Calls `this.setupEventHandlers()`.
6.  Calls `this.setupHealthChecks()` (which calls `onSetupHealthChecks`).
7.  Calls `this.onInitialize()`.
8.  Calls `this.startHealthChecks()`.
9.  Emits `module:initialized` and standard scoped lifecycle events.

The `CoreModule.shutdown()` method orchestrates:
1.  Clearing the health check interval.
2.  Calls `this.onShutdown()`.
3.  Emits `module:shutdown` and standard scoped lifecycle events.

### 2.6. Static Factory (`createModule`)
**`createModule(deps = {}): CoreModule`**: A factory that can create a base `CoreModule` instance. It provides default no-op dependencies for `errorSystem` and `eventBusSystem`, mainly for testing or very simple standalone module scenarios. Subclasses typically have their own named factory functions (e.g., `createInventoryModule`).

---
## 3. Component: `ModuleSystem.js` - The Module Orchestrator

**(This section details the `ModuleSystem` class. Full individual documentation would be in `module-system-docs.md`.)**

### 3.1. Overview & Primary Responsibility
`ModuleSystem.js` defines the `ModuleSystem` class, the central component responsible for managing the entire lifecycle of all business logic modules (`CoreModule` instances) within TSMIS. It handles their registration, resolves inter-module dependencies to ensure correct initialization and shutdown order, and provides an aggregated view of their overall health and status.

### 3.2. Key Functionalities & API (`ModuleSystem`)

#### 3.2.1. `initialize()` & `shutdown()`
* **`async initialize(): Promise<void>`**: Initializes all registered modules in their correct dependency order. For each module, it calls `module.initialize()` and then `this.startModuleHealthMonitoring(moduleName)`.
* **`async shutdown(): Promise<void>`**: Shuts down all registered modules in reverse dependency order, calling `module.shutdown()` on each and clearing health monitoring intervals.

#### 3.2.2. Module Registration & Management (`register`, `unregister`, `resolve`)
* **`async register(name: string, ModuleClass: typeof CoreModule, config = {}): Promise<CoreModule>`**: Instantiates the `ModuleClass` with injected dependencies (including core systems and other services/modules resolved from `ContainerSystem`) and the provided `config`. Stores the instance and sets up error listeners for it.
* **`async unregister(name: string): Promise<boolean>`**: Shuts down (if running) and removes a module from management.
* **`async resolve(name: string): Promise<CoreModule>`**: Retrieves a registered module instance.

#### 3.2.3. Dependency Resolution (`resolveDependencyOrder`)
* **`resolveDependencyOrder(): string[]`**: Internally calculates the correct order for initializing and shutting down modules based on their `static dependencies` arrays, using a topological sort. Detects and throws `ModuleError` for circular dependencies.

#### 3.2.4. Module Error Handling (`handleModuleError`)
* **`async handleModuleError(moduleName: string, error: Error, moduleContext = {}): Promise<void>`**: Centralized method for processing errors reported by or related to managed modules. Logs the error, reports it to `ErrorSystem` via `safeHandleError`, and emits a `module:error` event.

#### 3.2.5. Module Health Monitoring (`startModuleHealthMonitoring`, `getSystemModulesHealth`)
* **`async startModuleHealthMonitoring(moduleName: string)`**: Initiates periodic health checks for the specified module by calling its `checkHealth()` method at a configurable interval. Stores the latest health status in `this.state.moduleHealth`.
* **`async getSystemModulesHealth(): Promise<object>`**: Aggregates and returns the health status from all managed modules.

### 3.3. Adherence to Standardization Pillars (Recap for `ModuleSystem`)
* **State Management**: Implements standard `this.state`. Adds `modules` (Map), `moduleHealth` (Map), `healthCheckIntervals` (Map).
* **Lifecycle Management**: Standard `initialize`/`shutdown` orchestrating module lifecycles. Emits `LIFECYCLE_EVENTS`.
* **Error Handling**: Uses `_handleInternalError` for its own errors. Uses `handleModuleError` for issues related to managed modules. Reports via `safeHandleError`. Throws `ModuleError`.
* **Health Monitoring**: `checkHealth()` for its own status. `getSystemModulesHealth()` for aggregated module health. Default checks: `modulesystem.state`, `modulesystem.module_overview`, `modulesystem.all_modules_health`.
* **Metrics Tracking**: Records metrics for its lifecycle, module registrations/unregistrations, reported module errors, and module health statuses.
* **Factory Function**: `createModuleSystem(deps = {})` provided.

### 3.4. State Management (`ModuleSystem` Specifics)
Beyond the standard `this.state`, `ModuleSystem` manages:
* **`this.modules: Map<string, CoreModule>`**: Stores instances of all registered modules.
* **`this.state.moduleHealth: Map<string, object>`**: Caches the last reported health object for each monitored module.
* **`this.state.healthCheckIntervals: Map<string, NodeJS.Timeout>`**: Keeps track of the `setInterval` IDs for each module's periodic health check.

### 3.5. Lifecycle Management (`ModuleSystem` Process)
* **`initialize()`**: Validates dependencies, (re-)fetches `this.eventBus`, calls `resolveDependencyOrder()`. Then, for each module in order, calls `module.initialize()` and `this.startModuleHealthMonitoring(moduleName)`.
* **`shutdown()`**: Stops all module health monitoring intervals. Calls `resolveDependencyOrder().reverse()`. Then, for each module in reverse order, calls `module.shutdown()`. Clears internal module registries.

### 3.6. Error Handling within `ModuleSystem`
* **Internal Errors**: Uses `_handleInternalError` for errors in its own orchestration logic (e.g., failure in `resolveDependencyOrder`, issues starting/stopping health monitors if not module-specific).
* **Module-Related Errors**: Uses `handleModuleError` when a module emits a `module:error` event (to which `ModuleSystem` subscribes upon module registration), or when a module's health check (polled by `ModuleSystem`) indicates a failure or throws an error.

### 3.7. Event Integration (`ModuleSystem` Specifics)
* **Emits Events**:
    * Standard lifecycle events for itself (e.g., `system:initialized`).
    * Module management events (via `this.emit`, which also broadcasts to `CoreEventBus`): `module:registered`, `module:unregistered`, `module:error` (when relaying/processing a module's error), `module:unhealthy` (when periodic health check finds an issue).
* **Listens for Events**:
    * After registering a module instance, `ModuleSystem` internally subscribes to that instance's `module:error` event to trigger `this.handleModuleError`.

### 3.8. Health Monitoring (`ModuleSystem` Specifics)
Provides `checkHealth()` for its own operational status. Key checks include:
* **`modulesystem.state`**: Its own lifecycle status, uptime, internal error count.
* **`modulesystem.module_overview`**: Summary of managed modules (counts, how many are healthy/degraded/unhealthy based on `this.state.moduleHealth`).
* **`modulesystem.all_modules_health`**: This check calls `this.getSystemModulesHealth()` which performs an on-demand `checkHealth()` for every currently managed module and returns a detailed, nested report.

### 3.9. Metrics Tracking (`ModuleSystem` Specifics)
Records metrics for:
* Its own lifecycle: `modulesystem.initialized.success/failure`, `modulesystem.shutdown.success/failure/time`.
* Its internal errors: `modulesystem.errors.internal`.
* Module management: `modulesystem.modules.registered`, `modulesystem.modules.unregistered`.
* Errors related to modules: `modulesystem.errors.module_reported` (tags: `moduleName`, `errorName`, `errorCode`).
* Module health: `modulesystem.module.{name}.health.status` (tags: `status`).

### 3.10. Static Factory (`createModuleSystem`)
**`createModuleSystem(deps = {}): ModuleSystem`** for standardized instantiation.

## 4. Integrations (Module Architecture Level)

The Module Architecture (`ModuleSystem` and `CoreModule`) is deeply integrated with other core TSMIS systems:

* **`ContainerSystem`**:
    * `ModuleSystem` itself is typically a component registered with and managed by `ContainerSystem`.
    * `ContainerSystem` injects `ErrorSystem`, `EventBusSystem`, and `config` into `ModuleSystem`.
    * When `ModuleSystem` registers a new `CoreModule`, it passes these core dependencies along. Crucially, if a `CoreModule` declares additional dependencies in its `static dependencies` array (e.g., `'myCustomService'`), `ModuleSystem` relies on the `ContainerSystem` (implicitly, via the `deps` it received) to resolve these additional dependencies and inject them into the `CoreModule` instance.
* **`EventBusSystem` / `CoreEventBus`**:
    * `ModuleSystem` uses the `CoreEventBus` (via `eventBusSystem.getEventBus()`) to emit its own operational events (e.g., `module:registered`).
    * It ensures all `CoreModule` instances it creates receive the `eventBusSystem` dependency, so they can obtain the `CoreEventBus` for inter-module communication (`this.emit` in `CoreModule` uses it, and `setupEventHandlers` in modules uses it for subscriptions).
* **`ErrorSystem`**:
    * Both `ModuleSystem` (for its own errors and when handling module errors via `handleModuleError`) and individual `CoreModule` instances (via their `handleError` method) use the `ErrorSystem` (typically through the `safeHandleError` utility) for centralized error reporting.
* **`RouterSystem` (Indirectly via `RoutableModule`)**:
    * While `ModuleSystem` itself doesn't directly interact with `RouterSystem`, it manages `RoutableModule` instances. `RoutableModule`s, during their lifecycle (managed by `ModuleSystem`), emit route registration events to `CoreEventBus`, which are then consumed by `CoreRouter` (managed by `RouterSystem`).

## 5. Module Lifecycle & Management Flow Diagrams

**ModuleSystem**: Module Management & High-Level Interaction

```mermaid
graph TD
    Container["ContainerSystem"] -- Resolves & Provides Deps --> ModSys["ModuleSystem"];
    ModSys -- Instantiates with Deps --> ModA["ModuleA (extends CoreModule)"];
    ModSys -- Instantiates with Deps --> ModB["ModuleB (extends CoreModule)"];
    
    ModSys -- Calls initialize() in order --> ModA;
    ModSys -- Calls initialize() in order --> ModB;
    
    ModSys -- Periodically calls checkHealth() --> ModA;
    ModSys -- Periodically calls checkHealth() --> ModB;
    ModSys -- Aggregates Health --> OverallModuleHealth["Aggregated Module Health"];

    ModA -- Emits 'module:error' --> ModSys;
    ModB -- Emits 'module:error' --> ModSys;
    ModSys -- handleModuleError() --> ErrorSys["ErrorSystem"];
    
    ModA -- Uses --> EventBus["CoreEventBus (via EventBusSystem)"];
    ModB -- Uses --> EventBus;
    EventBus -- Enables communication --> ModA;
    EventBus -- Enables communication --> ModB;

    classDef system fill:#D6EAF8,stroke:#5DADE2,stroke-width:2px;
    classDef module fill:#E8F8F5,stroke:#76D7C4,stroke-width:2px;
    class ModSys, Container, ErrorSys, EventBus system;
    class ModA, ModB module;
```

**CoreModule**: Internal Initialization Sequence (Called by ModuleSystem

```mermaid
sequenceDiagram
    participant ModSys as ModuleSystem
    participant MyMod as MyModule (extends CoreModule)
    participant EvBus as CoreEventBus (via MyMod.eventBus)
    participant ErrSys as ErrorSystem (via MyMod.deps.errorSystem & safeHandleError)

    ModSys->>MyMod: initialize()
    MyMod->>MyMod: _validateDependencies()
    MyMod->>MyMod: (Re-fetch this.eventBus)
    MyMod->>MyMod: validateConfig() --> calls onValidateConfig()
    MyMod->>MyMod: onConfigure()
    MyMod->>MyMod: setupEventHandlers()
        Note over MyMod,EvBus: Subscribes to events on EvBus
    MyMod->>MyMod: setupHealthChecks() --> calls onSetupHealthChecks()
        Note over MyMod: Registers health checks (e.g., this.registerHealthCheck(...))
    MyMod->>MyMod: onInitialize()
        Note over MyMod: Module-specific init logic
    MyMod->>MyMod: startHealthChecks()
        Note over MyMod: Starts periodic self-health check
    MyMod-->>ModSys: Initialization Complete / Error
```

## 6. Developing a New Business Module (Best Practices & Example Reference)

This topic is covered extensively in **Section 7: Developing Business Modules** of the main "TSMIS Core Architecture - Source of Truth" document. It includes:
* Guiding principles for module design.
* How to extend `CoreModule` or `RoutableModule`.
* A detailed example (`InventoryModule`) covering directory structure, specific error/event files, service separation, schema definition, and implementation of the main module class with lifecycle hooks, route handling, etc.
* How to register modules and their services.
* Module-specific configuration.
* Unit testing strategies for modules.

## 7. Testing Strategies for Modules and ModuleSystem

* **`CoreModule` Subclasses**:
    * Mock all dependencies (`errorSystem`, `eventBusSystem`, `config`, custom services).
    * Test each lifecycle hook's specific logic (e.g., did `onConfigure` set properties correctly? Did `setupEventHandlers` call `eventBus.subscribe`?).
    * Test business methods for correct outputs, side effects (event emissions, metric recording), and error handling (verify `this.handleError` is called).
    * For `RoutableModule`, test route handlers by mocking request/reply objects and asserting interactions with services and response generation (or error throwing for global handler).
* **`ModuleSystem`**:
    * Test `register`/`unregister` with valid and invalid `ModuleClass` inputs, duplicate names.
    * Test `resolveDependencyOrder` with various dependency graphs (including valid order and circular dependencies resulting in errors).
    * Test `initialize`/`shutdown`: Mock `CoreModule` instances and spy on their `initialize`/`shutdown` methods to ensure they are called in the correct order. Test error propagation if a module fails to initialize/shutdown.
    * Test `startModuleHealthMonitoring`: Mock `module.checkHealth()` and timers to verify health state updates and `module:unhealthy` / `handleModuleError` calls.
    * Test `getSystemModulesHealth` aggregates results correctly.
    * Test its own state, health, metrics, and error handling (`_handleInternalError`, `handleModuleError`).

## 8. Future Considerations & Potential Enhancements
(Adapted from original Module System docs)
* **Dynamic Module Loading/Unloading/Hot-Reloading**: For greater flexibility, especially in development or for plugin-based architectures.
* **Module Versioning**: Introduce more explicit support for managing different versions of modules and their dependencies.
* **Module Composition Patterns**: Explore advanced patterns like mixins, traits, or decorators for sharing common functionalities or cross-cutting concerns among modules beyond simple inheritance from `CoreModule`.
* **Inter-Module Contracts/Interfaces**: Formalize contracts for direct inter-module service calls (if used) to improve robustness as the system evolves.
* **Module Federation**: For very large systems, investigate patterns for distributing modules across different services or processes while maintaining a cohesive operational model.
* **Advanced Health Monitoring Aggregation**: More sophisticated health aggregation in `ModuleSystem`, potentially including dependency-aware degradation status or anomaly detection based on module health trends.


// src/core/router/CoreRouter.js

/**
 * @file CoreRouter.js
 * @description Core router for managing HTTP routes, adapters, and middleware.
 * It listens for route registration events and applies them via framework-specific adapters.
 */

import { EventEmitter } from 'events';
import { RouterError } from '../errors/index.js'; // Assuming errors/index.js exports RouterError
import { ErrorCodes } from '../errors/ErrorCodes.js';
import { SYSTEM_STATUS, LIFECYCLE_EVENTS, DEFAULT_CONFIG } from '../common/SystemConstants.js';
import { safeHandleError, createStandardHealthCheckResult } from '../common/ErrorUtils.js';

export class CoreRouter extends EventEmitter {
  static dependencies = ['errorSystem', 'eventBusSystem', 'config']; // [cite: 1081]
  static version = '2.0.0'; // Example version bump

  /**
   * Creates a new CoreRouter instance.
   * @param {object} [deps={}] - Dependencies for the CoreRouter.
   * @param {object} [deps.errorSystem] - The ErrorSystem instance.
   * @param {object} [deps.eventBusSystem] - The EventBusSystem instance for subscribing to route events.
   * @param {object} [deps.config={}] - Configuration object.
   */
  constructor(deps = {}) { // Changed from constructor(deps) [cite: 1082]
    super();
    this.deps = {
      errorSystem: deps.errorSystem,
      eventBusSystem: deps.eventBusSystem,
      config: deps.config || {},
    };

    this.routes = new Map(); // [cite: 1082]
    this.adapters = new Map(); // [cite: 1082]
    this.middleware = new Map(); // [cite: 1082]
    this.subscriptions = []; // To keep track of event bus subscriptions for cleanup

    this.state = { // (aligning with standard)
      status: SYSTEM_STATUS.CREATED,
      startTime: null,
      errors: [], // For internal errors of CoreRouter
      metrics: new Map(),
      healthChecks: new Map(),
    };

    this.setupDefaultHealthChecks(); // [cite: 1085]
  }

  /**
   * Handles internal operational errors of the CoreRouter.
   * @private
   */
  async _handleInternalError(error, context = {}) {
    const errorToLog = !(error instanceof RouterError)
      ? new RouterError(ErrorCodes.ROUTER.INTERNAL_SYSTEM_ERROR || 'INTERNAL_SYSTEM_ERROR', error.message, context, { cause: error })
      : error;

    this.state.errors.push({ error: errorToLog, timestamp: new Date().toISOString(), context });
    if (this.state.errors.length > (this.deps.config?.router?.maxErrorHistory || DEFAULT_CONFIG.MAX_ERROR_HISTORY)) {
      this.state.errors.shift();
    }
    this.recordMetric('corerouter.errors.internal', 1, { errorName: errorToLog.name, errorCode: errorToLog.code });
    await safeHandleError(this.deps.errorSystem, errorToLog, { source: 'CoreRouter', ...context });
  }

  /**
   * Initializes the CoreRouter.
   * Subscribes to route registration and management events from the EventBus.
   * @returns {Promise<CoreRouter>} This instance.
   */
  async initialize() { //
    if (this.state.status === SYSTEM_STATUS.RUNNING || this.state.status === SYSTEM_STATUS.INITIALIZING) {
      const err = new RouterError(ErrorCodes.ROUTER.ALREADY_INITIALIZED, 'CoreRouter is already initialized or initializing.'); // [cite: 1097]
      await this._handleInternalError(err, { currentStatus: this.state.status });
      return this;
    }

    super.emit(LIFECYCLE_EVENTS.INITIALIZING, { system: 'CoreRouter' }); // Use super.emit for own lifecycle
    this.state.status = SYSTEM_STATUS.INITIALIZING;
    this.state.startTime = Date.now();

    try {
      if (!this.deps.eventBusSystem || !this.deps.eventBusSystem.getEventBus) {
        throw new RouterError(ErrorCodes.ROUTER.INVALID_DEPENDENCY, 'CoreRouter: EventBusSystem is not available or invalid for event subscriptions.');
      }
      const eventBus = this.deps.eventBusSystem.getEventBus();
      if (!eventBus || typeof eventBus.subscribe !== 'function') {
          throw new RouterError(ErrorCodes.ROUTER.INVALID_DEPENDENCY, 'CoreRouter: CoreEventBus instance is not available for event subscriptions.');
      }

      // Subscribe to route management events
      this.subscriptions.push(
        eventBus.subscribe('router.route.register', this.handleRouteRegistration.bind(this)),
        eventBus.subscribe('router.route.unregister', this.handleRouteUnregistration.bind(this)), // New subscription
        eventBus.subscribe('router.routes.clear', this.handleRoutesClear.bind(this)),
        eventBus.subscribe('router.module.unregister', this.handleModuleUnregister.bind(this))
      );

      this.state.status = SYSTEM_STATUS.RUNNING;
      this.recordMetric('corerouter.initialized.success', 1, { timestamp: Date.now() });
      super.emit(LIFECYCLE_EVENTS.INITIALIZED, { system: 'CoreRouter', timestamp: new Date().toISOString() }); //
      super.emit(LIFECYCLE_EVENTS.RUNNING, { system: 'CoreRouter', timestamp: new Date().toISOString() });

    } catch (error) {
      this.state.status = SYSTEM_STATUS.ERROR;
      this.recordMetric('corerouter.initialized.failure', 1, { error: error.code, timestamp: Date.now() }); //
      await this._handleInternalError(error, { phase: 'initialization' }); // [cite: 1105]
      // Re-throw standardized error
      throw error instanceof RouterError ? error : new RouterError(
        ErrorCodes.ROUTER.INITIALIZATION_FAILED,
        'CoreRouter failed to initialize.',
        { originalMessage: error.message },
        { cause: error }
      );
    }
    return this;
  }

  /**
   * Registers a route definition internally.
   * @param {string} moduleId - The ID of the module defining the route.
   * @param {string} method - HTTP method (e.g., 'GET', 'POST').
   * @param {string} path - Route path.
   * @param {Function} handler - The route handler function.
   * @param {object} [options={}] - Route-specific options.
   * @returns {CoreRouter} This instance.
   * @throws {RouterError} if route conflicts or parameters are invalid.
   */
  registerRoute(moduleId, method, path, handler, options = {}) { //
    if (this.state.status !== SYSTEM_STATUS.RUNNING) {
      const err = new RouterError(ErrorCodes.ROUTER.NOT_INITIALIZED, 'CoreRouter is not running, cannot register route.'); //
      this._handleInternalError(err, { method, path }); // Log, but throw as it's likely a programming error
      throw err;
    }
    // Parameter validations
    if (!moduleId || typeof moduleId !== 'string') throw new RouterError(ErrorCodes.ROUTER.INVALID_MODULE_ID, 'Module ID is required for route registration.'); //
    if (!method || typeof method !== 'string') throw new RouterError(ErrorCodes.ROUTER.INVALID_METHOD, 'HTTP method must be a non-empty string.'); //
    if (!path || typeof path !== 'string') throw new RouterError(ErrorCodes.ROUTER.INVALID_PATH, 'Route path must be a non-empty string.'); //
    if (typeof handler !== 'function') throw new RouterError(ErrorCodes.ROUTER.INVALID_HANDLER, 'Route handler must be a function.'); //

    const upperMethod = method.toUpperCase();
    const routeKey = `${upperMethod}:${path}`;

    if (this.routes.has(routeKey)) { //
      const existing = this.routes.get(routeKey);
      throw new RouterError(
        ErrorCodes.ROUTER.ROUTE_CONFLICT, //
        `Route conflict: ${routeKey} already registered by module '${existing.moduleId}'. New registration attempt by '${moduleId}'.`,
        { existingRoute: existing, newRoute: { moduleId, method: upperMethod, path } }
      );
    }

    this.routes.set(routeKey, { moduleId, method: upperMethod, path, handler, options: options || {} }); //
    this.recordMetric('corerouter.routes.registered', 1, { moduleId, method: upperMethod }); //
    super.emit('route:registered', { moduleId, method: upperMethod, path, timestamp: new Date().toISOString() }); //
    return this;
  }

  /**
   * Registers a framework adapter.
   * @param {string} name - A unique name for the adapter.
   * @param {IRouterAdapter} adapter - An instance of a class implementing IRouterAdapter.
   * @returns {CoreRouter} This instance.
   */
  registerAdapter(name, adapter) { //
    if (!name || typeof name !== 'string') throw new RouterError(ErrorCodes.ROUTER.INVALID_ADAPTER_NAME, 'Adapter name must be a non-empty string.'); // [cite: 1117]
    if (!adapter || typeof adapter.applyRoutes !== 'function') throw new RouterError(ErrorCodes.ROUTER.INVALID_ADAPTER, `Adapter '${name}' must implement an async applyRoutes method.`); //

    this.adapters.set(name, adapter); //
    this.recordMetric('corerouter.adapters.registered', 1, { adapterName: name }); // [cite: 1119]
    super.emit('adapter:registered', { name, timestamp: new Date().toISOString() }); //
    return this;
  }

  /**
   * Registers a named middleware.
   * @param {string} name - A unique name for the middleware.
   * @param {Function} handler - The middleware handler function.
   * @param {object} [options={}] - Middleware options (e.g., order, paths, methods).
   * @returns {CoreRouter} This instance.
   */
  registerMiddleware(name, handler, options = {}) { //
    if (!name || typeof name !== 'string') throw new RouterError(ErrorCodes.ROUTER.INVALID_MIDDLEWARE_NAME, 'Middleware name must be a non-empty string.'); // [cite: 1121]
    if (typeof handler !== 'function') throw new RouterError(ErrorCodes.ROUTER.INVALID_MIDDLEWARE, `Middleware handler for '${name}' must be a function.`); //

    this.middleware.set(name, { handler, options: options || {}, order: options?.order || 100 }); //
    this.recordMetric('corerouter.middleware.registered', 1, { middlewareName: name }); //
    super.emit('middleware:registered', { name, timestamp: new Date().toISOString() }); //
    return this;
  }

  /**
   * Retrieves and sorts applicable middleware for a given route.
   * @param {object} route - The route object { method, path, options }.
   * @returns {Array<object>} Sorted array of middleware { name, handler, order }.
   */
  getMiddlewareForRoute(route) { //
    const routeSpecificMiddlewareNames = route.options?.middleware || []; // [cite: 1126]
    const applicableMiddleware = [];

    // Global middleware (applied based on options.paths/methods)
    for (const [name, midDef] of this.middleware) { //
      // Avoid re-adding if it's also route-specific and already processed, or ensure unique add
      if (this._shouldApplyMiddleware(name, midDef, route)) { // [cite: 1127]
        applicableMiddleware.push({ name, handler: midDef.handler, order: midDef.order });
      }
    }

    // Route-specific middleware by name
    for (const name of routeSpecificMiddlewareNames) { //
      if (this.middleware.has(name)) {
        const midDef = this.middleware.get(name);
        // Avoid duplicates if already added as global
        if (!applicableMiddleware.some(m => m.name === name)) {
            applicableMiddleware.push({ name, handler: midDef.handler, order: midDef.order }); //
        }
      } else {
        this.deps.logger?.warn(`[CoreRouter] Middleware '${name}' requested by route ${route.method} ${route.path} not found.`);
      }
    }
    return applicableMiddleware.sort((a, b) => a.order - b.order); // [cite: 1130]
  }

  /** @private */
  _shouldApplyMiddleware(middlewareName, middlewareDef, route) { //
    const { paths, methods } = middlewareDef.options || {};
    if (!paths && !methods) return true; // [cite: 1131]

    let matchesPath = !paths; // If no path patterns, it's a path match by default
    if (paths) {
      matchesPath = paths.some(pattern => this._pathMatchesPattern(route.path, pattern)); //
    }
    if (!matchesPath) return false; //

    let matchesMethod = !methods; // If no method patterns, it's a method match
    if (methods) {
      matchesMethod = methods.map(m => m.toUpperCase()).includes(route.method.toUpperCase()); //
    }
    return matchesMethod; //
  }

  /** @private */
  _pathMatchesPattern(path, pattern) { //
    if (pattern.endsWith('*')) {
      const prefix = pattern.slice(0, -1); //
      return path.startsWith(prefix); // [cite: 1137]
    }
    return path === pattern; // [cite: 1138]
  }

  /**
   * Applies all registered routes to a given HTTP framework instance using a specified adapter.
   * @param {object} framework - The HTTP framework instance (e.g., Fastify app, Express app).
   * @param {string} adapterName - The name of the registered adapter to use.
   * @returns {Promise<object>} The framework instance with routes applied.
   */
  async applyRoutes(framework, adapterName) { //
    if (this.state.status !== SYSTEM_STATUS.RUNNING) throw new RouterError(ErrorCodes.ROUTER.NOT_INITIALIZED, 'CoreRouter is not running.'); // [cite: 1139]
    if (!framework) throw new RouterError(ErrorCodes.ROUTER.INVALID_FRAMEWORK, 'Framework instance is required to apply routes.'); //
    if (!adapterName || !this.adapters.has(adapterName)) throw new RouterError(ErrorCodes.ROUTER.ADAPTER_NOT_FOUND, `Adapter '${adapterName}' not found.`); //

    try {
      const adapter = this.adapters.get(adapterName); //
      // Prepare routes with their applicable middleware
      const routesWithMiddleware = Array.from(this.routes.values()).map(route => ({
          ...route,
          // Resolve middleware just before applying, allowing dynamic middleware registration
          resolvedMiddleware: this.getMiddlewareForRoute(route).map(m => m.handler)
      }));

      const result = await adapter.applyRoutes(framework, routesWithMiddleware); // (Pass routesWithMiddleware)
      this.recordMetric('corerouter.routes.applied', routesWithMiddleware.length, { adapter: adapterName }); //
      super.emit('routes:applied', { adapter: adapterName, count: routesWithMiddleware.length, timestamp: new Date().toISOString() }); //
      return result; //
    } catch (error) {
      const applyError = new RouterError( //
        ErrorCodes.ROUTER.ROUTES_APPLICATION_FAILED, //
        `Failed to apply routes using adapter '${adapterName}'.`, //
        { adapter: adapterName, originalMessage: error.message }, //
        { cause: error } //
      );
      await this._handleInternalError(applyError, { phase: 'applyRoutes', adapterName }); // (adapted)
      throw applyError; //
    }
  }

  getRoutes() { return Array.from(this.routes.values()); } //
  getRoute(method, path) { return this.routes.get(`${method.toUpperCase()}:${path}`) || null; } //
  getModuleRoutes(moduleId) { return Array.from(this.routes.values()).filter(r => r.moduleId === moduleId); } //

  unregisterRoute(method, path) { //
    const routeKey = `${method.toUpperCase()}:${path}`; // [cite: 1151]
    const route = this.routes.get(routeKey);
    if (!route) return false; //

    const unregistered = this.routes.delete(routeKey); //
    if (unregistered) {
      this.recordMetric('corerouter.routes.unregistered', 1, { moduleId: route.moduleId, method: route.method }); //
      super.emit('route:unregistered', { moduleId: route.moduleId, method: route.method, path, timestamp: new Date().toISOString() }); //
    }
    return unregistered;
  }

  unregisterModuleRoutes(moduleId) { //
    const moduleRoutes = this.getModuleRoutes(moduleId); // [cite: 1155]
    let count = 0;
    for (const route of moduleRoutes) { // [cite: 1155]
      if (this.unregisterRoute(route.method, route.path)) { //
        count++;
      }
    }
    if (count > 0) {
        this.recordMetric('corerouter.module.routes.unregistered', count, { moduleId });
    }
    return count; // [cite: 1157]
  }

  clearRoutes() { //
    const count = this.routes.size; // [cite: 1158]
    this.routes.clear(); // [cite: 1158]
    if (count > 0) {
        this.recordMetric('corerouter.routes.cleared', count); //
        super.emit('routes:cleared', { count, timestamp: new Date().toISOString() }); // [cite: 1159]
    }
    return this;
  }

  /**
   * Utility to register a versioned route.
   * This is primarily for convenience if RouterSystem exposes it. CoreRouter itself just registers what it's given.
   * @param {string} moduleId
   * @param {string|number} version
   * @param {string} method
   * @param {string} path
   * @param {Function} handler
   * @param {object} [options={}]
   * @returns {CoreRouter}
   */
  registerVersionedRoute(moduleId, version, method, path, handler, options = {}) { //
    const basePath = path.startsWith('/') ? path : `/${path}`;
    const versionedPath = `/api/v${version}${basePath}`; // [cite: 1160]
    return this.registerRoute(moduleId, method, versionedPath, handler, { ...options, apiVersion: version }); //
  }

  generateOpenApiDoc(info = {}) { //
    const paths = {}; // [cite: 1162]
    const tags = new Set(); // [cite: 1162]

    for (const route of this.getRoutes()) { //
      const { method, path, options } = route;
      if (options.tags && Array.isArray(options.tags)) options.tags.forEach(tag => tags.add(tag)); //

      const pathParams = []; //
      const openApiPath = path.replace(/:([^/]+)/g, (_, paramName) => { // [cite: 1165]
        pathParams.push({ name: paramName, in: 'path', required: true, schema: { type: 'string' } }); // [cite: 1165]
        return `{${paramName}}`; //
      });

      if (!paths[openApiPath]) paths[openApiPath] = {}; //
      paths[openApiPath][method.toLowerCase()] = { // [cite: 1167]
        tags: options.tags || [], //
        summary: options.summary || '', //
        description: options.description || '', //
        parameters: [
          ...pathParams,
          ...(options.schema?.parameters || []), // Assuming schema might define other params
        ], //
        requestBody: options.schema?.body ? { content: { 'application/json': { schema: options.schema.body } } } : undefined,
        responses: options.schema?.responses || { '200': { description: 'Success' } }, // [cite: 1171]
        security: options.auth ? [{ bearerAuth: [] }] : [], //
      };
    }

    return { //
      openapi: '3.0.0',
      info: { // [cite: 1173]
        title: info.title || 'API Documentation', //
        version: info.version || CoreRouter.version, // [cite: 1174]
        description: info.description || '', // [cite: 1175]
      },
      tags: Array.from(tags).map(tag => ({ name: tag, description: '' })), // [cite: 1175]
      paths, // [cite: 1175]
      components: { // [cite: 1176]
        securitySchemes: { // [cite: 1176]
          bearerAuth: { type: 'http', scheme: 'bearer', bearerFormat: 'JWT' }, // [cite: 1176]
        },
        schemas: info.components?.schemas || {} // Allow passing in shared schemas
      },
    };
  }


  // --- Event Handlers ---
  async handleRouteRegistration(event) { //
    // Event data is expected to be the full event object from CoreEventBus
    const routeData = event.data || event; // Adapt if event structure varies
    try {
      const { moduleId, method, path, handler, options } = routeData; // [cite: 1184]
      this.registerRoute(moduleId, method, path, handler, options || {}); //
    } catch (error) {
      // This error is from CoreRouter's own registerRoute (e.g. conflict)
      // It's already a RouterError. _handleInternalError will log and forward.
      await this._handleInternalError(error, { eventName: event.name, receivedData: routeData }); // (adapted)
      // No need to re-emit router:error here as registerRoute itself or _handleInternalError would emit.
    }
  }

  async handleRouteUnregistration(event) { // New handler
    const routeData = event.data || event;
    try {
        const { method, path } = routeData;
        this.unregisterRoute(method, path);
    } catch (error) {
        await this._handleInternalError(error, { eventName: event.name, receivedData: routeData });
    }
  }


  async handleRoutesClear(event) { //
    try {
      this.clearRoutes(); // [cite: 1186]
    } catch (error) {
      await this._handleInternalError(error, { eventName: event.name }); // (adapted)
    }
  }

  async handleModuleUnregister(event) { //
    const eventData = event.data || event;
    try {
      const { moduleId } = eventData; // [cite: 1188]
      if (moduleId) {
        this.unregisterModuleRoutes(moduleId); //
      } else {
          throw new RouterError(ErrorCodes.ROUTER.INVALID_PAYLOAD, "moduleId missing in router.module.unregister event payload.");
      }
    } catch (error) {
      await this._handleInternalError(error, { eventName: event.name, receivedData: eventData }); // [cite: 1189] (adapted)
    }
  }

  /**
   * Shuts down the CoreRouter.
   * Clears routes, adapters, middleware, and unsubscribes from events.
   * @returns {Promise<void>}
   */
  async shutdown() { //
    if (this.state.status === SYSTEM_STATUS.SHUTDOWN || this.state.status === SYSTEM_STATUS.SHUTTING_DOWN) { // [cite: 1190]
      return;
    }
    super.emit(LIFECYCLE_EVENTS.SHUTTING_DOWN, { system: 'CoreRouter' });
    this.state.status = SYSTEM_STATUS.SHUTTING_DOWN; // [cite: 1191]
    const shutdownStartTime = Date.now();

    try {
      if (this.deps.eventBusSystem && this.deps.eventBusSystem.getEventBus) {
        const eventBus = this.deps.eventBusSystem.getEventBus();
        if (eventBus && typeof eventBus.unsubscribe === 'function') {
          for (const subId of this.subscriptions) { // [cite: 1192]
            eventBus.unsubscribe(subId); //
          }
        }
      }
      this.subscriptions = [];

      this.routes.clear(); //
      this.adapters.clear(); //
      this.middleware.clear(); //

      this.state.status = SYSTEM_STATUS.SHUTDOWN; // [cite: 1194]
      this.state.startTime = null;
      const shutdownTime = Date.now() - shutdownStartTime;
      this.recordMetric('corerouter.shutdown.time', shutdownTime);
      this.recordMetric('corerouter.shutdown.success', 1, { timestamp: Date.now() }); //
      super.emit(LIFECYCLE_EVENTS.SHUTDOWN, { system: 'CoreRouter', durationMs: shutdownTime, timestamp: new Date().toISOString() }); // (adapted)

    } catch (error) {
      this.state.status = SYSTEM_STATUS.ERROR; //
      this.recordMetric('corerouter.shutdown.failure', 1, { error: error.code, timestamp: Date.now() }); //
      await this._handleInternalError(error, { phase: 'shutdown' }); // [cite: 1197]
      // Do not re-throw from CoreRouter shutdown itself unless critical, error is logged.
      // Original code threw a new RouterError.
      // It's safer for system stability not to throw from a core component's shutdown.
    }
  }


  // --- Health Checks & Metrics ---
  setupDefaultHealthChecks() { // [cite: 1085]
    this.registerHealthCheck('corerouter.state', this.checkSystemState.bind(this)); //
    this.registerHealthCheck('corerouter.routes', this.checkRouteStatus.bind(this)); //
    this.registerHealthCheck('corerouter.adapters', this.checkAdapterStatus.bind(this)); //
    this.registerHealthCheck('corerouter.middleware', this.checkMiddlewareStatus.bind(this));
  }

  recordMetric(name, value, tags = {}) { //
    this.state.metrics.set(name, { value, timestamp: Date.now(), tags });
  }

  getMetrics() {
    const metrics = {};
    for (const [name, data] of this.state.metrics) {
      metrics[name] = data;
    }
    return metrics;
  }

  registerHealthCheck(name, checkFn) { //
    if (typeof checkFn !== 'function') {
        const err = new RouterError(ErrorCodes.ROUTER.INVALID_HANDLER, `CoreRouter Health check '${name}' must be a function.`); // [cite: 1090] (adapted)
        this._handleInternalError(err); // Log, but rethrow
        throw err;
    }
    this.state.healthChecks.set(name, checkFn);
  }

  async checkHealth() { //
    const results = {};
    let overallStatus = SYSTEM_STATUS.HEALTHY;

    for (const [name, checkFn] of this.state.healthChecks) {
      try {
        const checkResult = await checkFn();
        results[name] = checkResult;
        if (checkResult.status !== SYSTEM_STATUS.HEALTHY) { //
          overallStatus = (overallStatus === SYSTEM_STATUS.HEALTHY && checkResult.status === SYSTEM_STATUS.DEGRADED)
            ? SYSTEM_STATUS.DEGRADED
            : SYSTEM_STATUS.UNHEALTHY; //
        }
      } catch (error) {
        results[name] = createStandardHealthCheckResult(SYSTEM_STATUS.UNHEALTHY, { error: 'Health check threw an exception' }, [error]); // (adapted)
        overallStatus = SYSTEM_STATUS.UNHEALTHY; // [cite: 1094]
      }
    }
    return { //
      name: this.constructor.name,
      version: CoreRouter.version,
      status: overallStatus,
      timestamp: new Date().toISOString(),
      uptime: this.state.startTime ? Date.now() - this.state.startTime : 0,
      errorCount: this.state.errors.length,
      checks: results,
    };
  }

  async checkSystemState() {
    return createStandardHealthCheckResult(
      this.state.status === SYSTEM_STATUS.RUNNING ? SYSTEM_STATUS.HEALTHY : SYSTEM_STATUS.UNHEALTHY,
      {
        currentStatus: this.state.status,
        uptime: this.state.startTime ? Date.now() - this.state.startTime : 0,
        internalErrorCount: this.state.errors.length
      }
    );
  }

  async checkRouteStatus() { // (adapted)
    const routes = Array.from(this.routes.values());
    const routesByMethod = {};
    for (const route of routes) {
      routesByMethod[route.method] = (routesByMethod[route.method] || 0) + 1;
    }
    return createStandardHealthCheckResult(SYSTEM_STATUS.HEALTHY, {
      count: routes.length, // [cite: 1087]
      byMethod: routesByMethod, // [cite: 1087]
      // Example: include first 5 route keys for quick check, if desired and not too verbose
      // sampleRouteKeys: Array.from(this.routes.keys()).slice(0, 5)
    });
  }

  async checkAdapterStatus() { // (adapted)
    return createStandardHealthCheckResult(SYSTEM_STATUS.HEALTHY, {
      count: this.adapters.size, //
      adapterNames: Array.from(this.adapters.keys()), // [cite: 1089]
    });
  }

  async checkMiddlewareStatus() {
    return createStandardHealthCheckResult(SYSTEM_STATUS.HEALTHY, {
      count: this.middleware.size,
      middlewareNames: Array.from(this.middleware.keys()),
    });
  }

  getSystemStatus() {
    return {
        name: this.constructor.name,
        version: CoreRouter.version,
        status: this.state.status,
        uptime: this.state.startTime ? Date.now() - this.state.startTime : 0,
        initialized: this.state.status === SYSTEM_STATUS.RUNNING,
        errorCount: this.state.errors.length,
        routeCount: this.routes.size,
        adapterCount: this.adapters.size,
        middlewareCount: this.middleware.size,
        timestamp: new Date().toISOString()
    };
  }
}

// No default factory function for CoreRouter, as it's typically managed by RouterSystem
// export default CoreRouter; // Original file had this. Named export is generally preferred.


// src/core/router/RoutableModule.js

/**
 * @file RoutableModule.js
 * @description Extends CoreModule to provide route registration capabilities for modules.
 * Routes are declared by the module and emitted as events for the RouterSystem to process.
 */

import { CoreModule } from '../module/CoreModule.js';
import { RouterError } from '../errors/types/RouterError.js'; // Assuming this is in types/RouterError.js
import { ErrorCodes } from '../errors/ErrorCodes.js';
import { SYSTEM_STATUS } from '../common/SystemConstants.js'; // For checking module state

export class RoutableModule extends CoreModule {
  // Inherits static dependencies and version from CoreModule.
  // If RoutableModule had specific additional dependencies, they'd be added here.
  // static dependencies = [...CoreModule.dependencies, 'anotherDependency'];
  static version = '2.0.0'; // Override CoreModule's version if specific to Routable features

  /**
   * Creates a new RoutableModule instance.
   * @param {object} [deps={}] - Dependencies for the RoutableModule.
   */
  constructor(deps = {}) {
    super(deps); //
    this.routes = []; // Stores route definitions before the module (and router) is initialized
                     // or for immediate registration if already initialized.
    // Health check for routes will be registered in onInitialize or onSetupHealthChecks
  }

  /**
   * Registers an HTTP route.
   * If the module is already initialized and running, it attempts to register immediately
   * by emitting an event. Otherwise, stores the route for batch registration during onInitialize.
   *
   * @param {string} method - HTTP method (e.g., 'GET', 'POST').
   * @param {string} path - Route path (e.g., '/users/:id').
   * @param {Function} handler - The handler function for this route.
   * @param {object} [options={}] - Route-specific options (e.g., schema, middleware, auth requirements).
   * @returns {RoutableModule} This instance for chaining.
   */
  registerRoute(method, path, handler, options = {}) { //
    if (!method || typeof method !== 'string' || !method.trim()) {
      // Use this.handleError for operational errors that are recoverable or need logging by the module
      // For programming errors like invalid arguments, throwing directly is often better.
      throw new RouterError(ErrorCodes.ROUTER.INVALID_METHOD, `${this.constructor.name}: Route method must be a non-empty string.`); //
    }
    if (!path || typeof path !== 'string' || !path.trim()) {
      throw new RouterError(ErrorCodes.ROUTER.INVALID_PATH, `${this.constructor.name}: Route path must be a non-empty string.`); //
    }
    if (typeof handler !== 'function') {
      throw new RouterError(ErrorCodes.ROUTER.INVALID_HANDLER, `${this.constructor.name}: Route handler for ${method} ${path} must be a function.`); //
    }

    const routeDefinition = {
      method: method.toUpperCase(), //
      path, //
      handler: handler.bind(this), // Ensure 'this' context is the module instance [cite: 1054]
      options: options || {}, //
    };

    this.routes.push(routeDefinition); // [cite: 1054]
    this.recordMetric(`${this.constructor.name.toLowerCase()}.routes.defined`, 1, { method: routeDefinition.method, path });

    // If module is already running, emit event for immediate registration by RouterSystem
    // This relies on eventBus being available and RouterSystem listening.
    if (this.state.status === SYSTEM_STATUS.RUNNING && this.eventBus) { // [cite: 1055]
      this._emitRouteRegistration(routeDefinition)
          .catch(error => {
              // Error during immediate emission, log it via module's error handler
              this.handleError(new RouterError(
                  ErrorCodes.ROUTER.ROUTE_REGISTRATION_FAILED,
                  `${this.constructor.name}: Failed to emit immediate registration for ${routeDefinition.method} ${routeDefinition.path}.`,
                  { method: routeDefinition.method, path: routeDefinition.path, originalMessage: error.message },
                  { cause: error }
              ), { phase: 'immediate-route-registration' });
          });
    }
    return this; //
  }

  /**
   * Helper to emit the route registration event.
   * @private
   */
  async _emitRouteRegistration(routeDefinition) {
    if (!this.eventBus) {
        // This might happen if eventBus wasn't ready when module was initialized.
        // The route is stored in this.routes and will be registered by registerAllRoutes later.
        console.warn(`[${this.constructor.name}] EventBus not available for emitting route: ${routeDefinition.method} ${routeDefinition.path}. It will be registered during batch registration.`);
        return;
    }
    await this.eventBus.emit('router.route.register', { // [cite: 1058]
      moduleId: this.constructor.name, //
      ...routeDefinition, // Spreads method, path, handler, options
    }); //
    this.recordMetric(`${this.constructor.name.toLowerCase()}.routes.emitted_for_registration`, 1, { method: routeDefinition.method, path: routeDefinition.path });
  }


  /**
   * Registers a versioned API route. Prepends `/api/v<version>` to the path.
   * @param {string|number} version - The API version number (e.g., 1, '2.1').
   * @param {string} method - HTTP method.
   * @param {string} path - Route path (e.g., '/users').
   * @param {Function} handler - Route handler.
   * @param {object} [options={}] - Route options.
   * @returns {RoutableModule} This instance.
   */
  registerVersionedRoute(version, method, path, handler, options = {}) { //
    if (!version || (typeof version !== 'string' && typeof version !== 'number')) {
        throw new RouterError(ErrorCodes.ROUTER.INVALID_API_VERSION || 'INVALID_API_VERSION', `${this.constructor.name}: API version must be a non-empty string or number.`);
    }
    const basePath = path.startsWith('/') ? path : `/${path}`; //
    const versionedPath = `/api/v${version}${basePath}`; //
    return this.registerRoute(method, versionedPath, handler, { //
      ...options, //
      apiVersion: version, // Add version to options for RouterSystem/Adapter use
    });
  }

  /**
   * Emits events for all defined routes to be registered by the RouterSystem.
   * Typically called during the module's `onInitialize` lifecycle hook.
   * @returns {Promise<void>}
   */
  async registerAllRoutes() { //
    if (!this.eventBus) {
      await this.handleError(new ModuleError(
          ErrorCodes.MODULE.DEPENDENCY_NOT_READY,
          `${this.constructor.name}: EventBus is not available for registering routes. Ensure EventBusSystem is initialized.`,
          { moduleName: this.constructor.name }
      ), { phase: 'registerAllRoutes' });
      // Do not throw here, as this might be called during initialization where eventBus could be late.
      // Routes remain in this.routes and can be registered later if a mechanism is added.
      return;
    }

    let successfulEmissions = 0;
    for (const route of this.routes) { //
      try {
        await this._emitRouteRegistration(route); //
        successfulEmissions++;
      } catch (error) {
        // Error during batch emission, log it and continue with others
        await this.handleError(new RouterError(
            ErrorCodes.ROUTER.ROUTE_REGISTRATION_FAILED,
            `${this.constructor.name}: Failed to emit registration for ${route.method} ${route.path} during batch.`,
            { method: route.method, path: route.path, originalMessage: error.message },
            { cause: error }
        ), { phase: 'batch-route-registration' });
      }
    }
    this.recordMetric(`${this.constructor.name.toLowerCase()}.routes.batch_emitted`, successfulEmissions, { totalDefined: this.routes.length });
  }

  /**
   * Unregisters a previously registered route by emitting an event.
   * @param {string} method - HTTP method.
   * @param {string} path - Route path.
   * @returns {Promise<boolean>} True if the unregistration event was emitted, false if route not found locally.
   */
  async unregisterRoute(method, path) { //
    const upperMethod = method.toUpperCase(); //
    const index = this.routes.findIndex(r => r.method === upperMethod && r.path === path); //

    if (index === -1) { // [cite: 1069]
      this.deps.logger?.warn(`[${this.constructor.name}] Route ${upperMethod} ${path} not found locally for unregistration.`);
      return false; //
    }

    this.routes.splice(index, 1); //
    this.recordMetric(`${this.constructor.name.toLowerCase()}.routes.removed_local`, 1, { method: upperMethod, path });

    if (this.state.status === SYSTEM_STATUS.RUNNING && this.eventBus) { //
      try {
        await this.eventBus.emit('router.route.unregister', { //
          moduleId: this.constructor.name, //
          method: upperMethod, //
          path, //
        });
        this.recordMetric(`${this.constructor.name.toLowerCase()}.routes.emitted_for_unregistration`, 1, { method: upperMethod, path });
        return true; //
      } catch (error) {
         await this.handleError(new RouterError(
            ErrorCodes.ROUTER.ROUTE_UNREGISTRATION_FAILED || 'ROUTE_UNREGISTRATION_FAILED',
            `${this.constructor.name}: Failed to emit unregistration for ${upperMethod} ${path}.`,
            { method: upperMethod, path: path, originalMessage: error.message },
            { cause: error }
        ), { phase: 'route-unregistration' });
        return false; // Emission failed
      }
    }
    return true; // Removed locally, but not emitted if module not running or no eventBus
  }

  // --- CoreModule Lifecycle Overrides ---

  /**
   * Registers a health check for the routes defined by this module.
   * This is called by CoreModule's `setupHealthChecks`.
   */
  async onSetupHealthChecks() { // // (Hook from CoreModule)
    await super.onSetupHealthChecks(); // Call CoreModule's hook first
    this.registerHealthCheck(`${this.constructor.name.toLowerCase()}.routes`, async () => { //
      return createStandardHealthCheckResult(SYSTEM_STATUS.HEALTHY, { //
        count: this.routes.length, //
        paths: this.routes.map(r => `${r.method} ${r.path}`), //
      });
    });
  }

  /**
   * Hook into CoreModule's initialization to register all defined routes.
   */
  async onInitialize() { // // (Hook from CoreModule)
    await super.onInitialize(); // Call CoreModule's initialization logic first
    // Register all routes that might have been defined before eventBus was ready or if not using immediate registration
    await this.registerAllRoutes(); //
  }

  /**
   * Hook into CoreModule's shutdown to signal unregistration of all this module's routes.
   */
  async onShutdown() { // // (Hook from CoreModule)
    if (this.state.status === SYSTEM_STATUS.RUNNING && this.eventBus) { // Check if it was running
      try {
        await this.eventBus.emit('router.module.unregister', { // [cite: 1075]
          moduleId: this.constructor.name, //
        });
        this.recordMetric(`${this.constructor.name.toLowerCase()}.routes.all_emitted_for_unregistration`, 1);
      } catch (error) {
        await this.handleError(new RouterError(
            ErrorCodes.ROUTER.MODULE_UNREGISTRATION_FAILED || 'MODULE_UNREGISTRATION_FAILED',
            `${this.constructor.name}: Failed to emit module route unregistration event.`,
            { moduleId: this.constructor.name, originalMessage: error.message },
            { cause: error }
        ), { phase: 'module-routes-unregistration' });
      }
    }
    this.routes = []; // Clear local route definitions [cite: 1076]
    await super.onShutdown(); // Call CoreModule's shutdown logic last
  }
}

/**
 * Factory function for creating a RoutableModule instance.
 * @param {object} [deps={}] - Dependencies for the RoutableModule.
 * @returns {RoutableModule}
 */
export function createRoutableModule(deps = {}) { //
  // CoreModule's factory (createModule) already handles default dependencies for errorSystem, eventBusSystem, config.
  // So, we can just pass deps through.
  return new RoutableModule(deps); //
}

// Default export of an object containing the class and factory was present in original file.
// For ES Modules, named exports are generally preferred.
// export default { RoutableModule, createRoutableModule };


// src/core/router/RouterSystem.js

/**
 * @file RouterSystem.js
 * @description System for centralized route management, managing CoreRouter and its integrations.
 */

import { EventEmitter } from "events";
import { CoreRouter } from "./CoreRouter.js";
import { RouterError } from "../errors/index.js"; // Assuming errors/index.js exports RouterError
import { ErrorCodes } from "../errors/ErrorCodes.js";
import { SYSTEM_STATUS, LIFECYCLE_EVENTS, DEFAULT_CONFIG } from '../common/SystemConstants.js';
import { safeHandleError, createStandardHealthCheckResult } from '../common/ErrorUtils.js';

export class RouterSystem extends EventEmitter {
  static dependencies = ["errorSystem", "eventBusSystem", "config"]; // [cite: 1200]
  static version = "2.0.0"; // Example version bump [cite: 1200]

  /**
   * Creates a new RouterSystem instance.
   * @param {object} [deps={}] - Dependencies for the RouterSystem.
   */
  constructor(deps = {}) { // Changed from constructor(deps) [cite: 1201]
    super();
    this.deps = { //
      errorSystem: deps.errorSystem,
      eventBusSystem: deps.eventBusSystem,
      config: deps.config || {},
    };

    this.router = null; // Will be an instance of CoreRouter [cite: 1201]
    // this.initialized is driven by this.state.status

    this.state = { // (aligning with standard)
      status: SYSTEM_STATUS.CREATED,
      startTime: null,
      errors: [], // For internal errors of RouterSystem
      metrics: new Map(),
      healthChecks: new Map(),
    };

    this._validateDependencies(); // [cite: 1202] (called early)
    this.setupDefaultHealthChecks(); //
  }

  /** @private */
  _validateDependencies() { //
    const missing = RouterSystem.dependencies.filter(dep => !this.deps[dep]); // [cite: 1204]
    if (missing.length > 0) {
      throw new RouterError(ErrorCodes.ROUTER.MISSING_DEPENDENCIES, `RouterSystem: Missing required dependencies: ${missing.join(", ")}`, { missingDeps: missing }); //
    }
    if (!this.deps.eventBusSystem || typeof this.deps.eventBusSystem.getEventBus !== "function") { //
      throw new RouterError(ErrorCodes.ROUTER.INVALID_DEPENDENCY, "RouterSystem: EventBusSystem is invalid.", { dependency: "eventBusSystem" });
    }
    if (!this.deps.errorSystem || typeof this.deps.errorSystem.handleError !== "function") { //
      throw new RouterError(ErrorCodes.ROUTER.INVALID_DEPENDENCY, "RouterSystem: ErrorSystem is invalid.", { dependency: "errorSystem" });
    }
  }

  /** @private */
  async _handleInternalError(error, context = {}) {
    const errorToLog = !(error instanceof RouterError)
      ? new RouterError(ErrorCodes.ROUTER.SYSTEM_INTERNAL_ERROR || 'SYSTEM_INTERNAL_ERROR', error.message, context, { cause: error })
      : error;

    this.state.errors.push({ error: errorToLog, timestamp: new Date().toISOString(), context });
    if (this.state.errors.length > (this.deps.config?.routerSystem?.maxErrorHistory || DEFAULT_CONFIG.MAX_ERROR_HISTORY)) {
      this.state.errors.shift();
    }
    this.recordMetric('routersystem.errors.internal', 1, { errorName: errorToLog.name, errorCode: errorToLog.code });
    await safeHandleError(this.deps.errorSystem, errorToLog, { source: 'RouterSystem', ...context });
  }

  /**
   * Initializes the RouterSystem and the underlying CoreRouter.
   * @returns {Promise<RouterSystem>} This instance.
   */
  async initialize() { //
    if (this.state.status === SYSTEM_STATUS.RUNNING || this.state.status === SYSTEM_STATUS.INITIALIZING) {
      const err = new RouterError(ErrorCodes.ROUTER.ALREADY_INITIALIZED, "RouterSystem is already initialized or initializing.", { state: this.state.status }); //
      await this._handleInternalError(err);
      return this;
    }

    super.emit(LIFECYCLE_EVENTS.INITIALIZING, { system: 'RouterSystem' });
    this.state.status = SYSTEM_STATUS.INITIALIZING; //
    this.state.startTime = Date.now(); // [cite: 1217]

    try {
      this.router = new CoreRouter(this.deps); //
      this._setupEventForwarding(); // (renamed from setupEventForwarding)
      await this.router.initialize(); // [cite: 1219]

      this.state.status = SYSTEM_STATUS.RUNNING; //
      this.recordMetric('routersystem.initialized.success', 1); //
      super.emit(LIFECYCLE_EVENTS.INITIALIZED, { system: 'RouterSystem', timestamp: new Date().toISOString() }); // (using super.emit)
      super.emit(LIFECYCLE_EVENTS.RUNNING, { system: 'RouterSystem', timestamp: new Date().toISOString() });

    } catch (error) {
      this.state.status = SYSTEM_STATUS.ERROR; //
      this.recordMetric('routersystem.initialized.failure', 1, { error: error.code }); //
      await this._handleInternalError(error, { phase: 'initialization' }); // [cite: 1225] (adapted)
      throw error instanceof RouterError ? error : new RouterError( //
        ErrorCodes.ROUTER.INITIALIZATION_FAILED, //
        "RouterSystem failed to initialize.", //
        { originalMessage: error.message }, //
        { cause: error } //
      );
    }
    return this;
  }

  /** @private */
  _setupEventForwarding() { // (was setupEventForwarding)
    if (!this.router) return; //

    const forward = (eventName, systemEventName) => {
      this.router.on(eventName, (eventData) => { //
        // Use RouterSystem's own emit for these system-level event aggregations/translations
        this.emit(systemEventName, eventData); //
        // Original also re-emitted with original name, which might be desirable for some listeners
        this.emit(eventName, eventData); //
      });
    };

    forward('route:registered', 'system:route:registered'); //
    forward('route:unregistered', 'system:route:unregistered'); //
    forward('routes:applied', 'system:routes:applied'); //
    forward('routes:cleared', 'system:routes:cleared'); //
    forward('adapter:registered', 'system:adapter:registered'); //
    forward('middleware:registered', 'system:middleware:registered'); //

    this.router.on('router:error', (eventData) => { //
      // For errors from CoreRouter, RouterSystem should handle them via its own error system
      // and then emit a system-level error.
      const { error: crError, context: crContext } = eventData;
      this._handleInternalError(crError, { ...crContext, sourceDetail: 'CoreRouterEvent' }); // Log it as an internal error RouterSystem is aware of
      this.emit('system:error', eventData); // Forward the original event structure
      // this.emit('router:error', eventData); // Also re-emit original
    });
  }

  /**
   * Public method to handle errors, typically forwarded from CoreRouter or other operations.
   * This method is distinct from _handleInternalError which is for RouterSystem's own direct errors.
   * This aligns with the public handleError in the original RouterSystem.
   */
  async handleError(error, context = {}) { // (keeping public handleError)
    // This function is primarily for errors that RouterSystem itself catches from its operations
    // (like calls to this.router.X), not for _every_ error that CoreRouter might emit.
    // CoreRouter's errors are caught by _setupEventForwarding if emitted as 'router:error'.
    this.state.errors.push({ error, timestamp: new Date().toISOString(), context: context || {} }); //
    if (this.state.errors.length > (this.deps.config?.routerSystem?.maxErrorHistory || DEFAULT_CONFIG.MAX_ERROR_HISTORY)) { //
      this.state.errors.shift();
    }
    this.recordMetric('routersystem.errors.operational', 1, { errorName: error.name, errorCode: error.code }); //

    await safeHandleError(this.deps.errorSystem, error, { source: 'RouterSystem', ...context }); //

    super.emit('system:error', { error, context, timestamp: new Date().toISOString() }); // (use super.emit)
  }


  getRouter() { //
    if (this.state.status !== SYSTEM_STATUS.RUNNING) {
      throw new RouterError(ErrorCodes.ROUTER.NOT_INITIALIZED, "RouterSystem is not running, cannot get router.", { state: this.state.status }); //
    }
    return this.router;
  }

  // --- Delegated CoreRouter Methods ---
  // These methods delegate to CoreRouter, adding RouterSystem-level metrics and error handling.

  async registerRoute(moduleId, method, path, handler, options = {}) { //
    if (!this.router) throw new RouterError(ErrorCodes.ROUTER.NOT_INITIALIZED, "Router not available in RouterSystem."); //
    try {
      this.router.registerRoute(moduleId, method, path, handler, options); //
      this.recordMetric('routersystem.routes.registered', 1, { moduleId, method: method.toUpperCase() }); //
      return this; //
    } catch (error) {
      await this.handleError(error, { phase: 'registerRoute', moduleId, method, path }); // (use public handleError)
      throw error; // Re-throw the original RouterError
    }
  }

  async registerVersionedRoute(moduleId, version, method, path, handler, options = {}) { //
    if (!this.router) throw new RouterError(ErrorCodes.ROUTER.NOT_INITIALIZED, "Router not available in RouterSystem."); //
    try {
      this.router.registerVersionedRoute(moduleId, version, method, path, handler, options); //
      this.recordMetric('routersystem.routes.versioned.registered', 1, { moduleId, version, method: method.toUpperCase() }); //
      return this; //
    } catch (error) {
      await this.handleError(error, { phase: 'registerVersionedRoute', moduleId, version, method, path }); //
      throw error;
    }
  }

  registerAdapter(name, adapter) { //
    if (!this.router) throw new RouterError(ErrorCodes.ROUTER.NOT_INITIALIZED, "Router not available in RouterSystem."); //
    try {
      this.router.registerAdapter(name, adapter); //
      this.recordMetric('routersystem.adapters.registered', 1, { adapterName: name }); //
      return this; //
    } catch (error) {
      this.handleError(error, { phase: 'registerAdapter', adapterName: name }); // (error is RouterError from CoreRouter)
      throw error;
    }
  }

  registerMiddleware(name, handler, options = {}) { //
    if (!this.router) throw new RouterError(ErrorCodes.ROUTER.NOT_INITIALIZED, "Router not available in RouterSystem."); //
    try {
      this.router.registerMiddleware(name, handler, options); //
      this.recordMetric('routersystem.middleware.registered', 1, { middlewareName: name }); //
      return this; //
    } catch (error) {
      this.handleError(error, { phase: 'registerMiddleware', middlewareName: name }); //
      throw error;
    }
  }

  async applyRoutes(framework, adapterName) { //
    if (!this.router) throw new RouterError(ErrorCodes.ROUTER.NOT_INITIALIZED, "Router not available in RouterSystem."); //
    try {
      const result = await this.router.applyRoutes(framework, adapterName); //
      this.recordMetric('routersystem.routes.applied', 1, { adapterName, count: this.router.getRoutes().length }); //
      return result; //
    } catch (error) {
      await this.handleError(error, { phase: 'applyRoutes', adapterName }); //
      throw error; // Error is already a RouterError from CoreRouter
    }
  }

  getRoutes() { //
    if (!this.router) throw new RouterError(ErrorCodes.ROUTER.NOT_INITIALIZED, "Router not available in RouterSystem."); //
    try { return this.router.getRoutes(); } //
    catch (error) { this.handleError(error, { phase: 'getRoutes' }); throw error; } //
  }
  getRoute(method, path) { //
    if (!this.router) throw new RouterError(ErrorCodes.ROUTER.NOT_INITIALIZED, "Router not available in RouterSystem."); //
    try { return this.router.getRoute(method, path); } //
    catch (error) { this.handleError(error, { phase: 'getRoute', method, path }); throw error; } //
  }
  getModuleRoutes(moduleId) { //
    if (!this.router) throw new RouterError(ErrorCodes.ROUTER.NOT_INITIALIZED, "Router not available in RouterSystem."); //
    try { return this.router.getModuleRoutes(moduleId); } //
    catch (error) { this.handleError(error, { phase: 'getModuleRoutes', moduleId }); throw error; } //
  }
  unregisterRoute(method, path) { //
    if (!this.router) throw new RouterError(ErrorCodes.ROUTER.NOT_INITIALIZED, "Router not available in RouterSystem."); //
    try {
      const result = this.router.unregisterRoute(method, path); //
      if (result) this.recordMetric('routersystem.routes.unregistered', 1, { method: method.toUpperCase(), path }); //
      return result;
    } catch (error) { this.handleError(error, { phase: 'unregisterRoute', method, path }); throw error; } //
  }
  unregisterModuleRoutes(moduleId) { //
    if (!this.router) throw new RouterError(ErrorCodes.ROUTER.NOT_INITIALIZED, "Router not available in RouterSystem."); //
    try {
      const count = this.router.unregisterModuleRoutes(moduleId); //
      if (count > 0) this.recordMetric('routersystem.module.routes.unregistered', count, { moduleId }); //
      return count;
    } catch (error) { this.handleError(error, { phase: 'unregisterModuleRoutes', moduleId }); throw error; } //
  }
  clearRoutes() { //
    if (!this.router) throw new RouterError(ErrorCodes.ROUTER.NOT_INITIALIZED, "Router not available in RouterSystem."); //
    try {
      const count = this.router.getRoutes().length; //
      this.router.clearRoutes(); //
      if (count > 0) this.recordMetric('routersystem.routes.cleared', count); //
      return this;
    } catch (error) { this.handleError(error, { phase: 'clearRoutes' }); throw error; } //
  }
  generateOpenApiDoc(info = {}) { //
    if (!this.router) throw new RouterError(ErrorCodes.ROUTER.NOT_INITIALIZED, "Router not available in RouterSystem."); //
    try { return this.router.generateOpenApiDoc(info); } //
    catch (error) { this.handleError(error, { phase: 'generateOpenApiDoc' }); throw error; } //
  }


  async shutdown() { //
    if (this.state.status === SYSTEM_STATUS.SHUTDOWN || this.state.status === SYSTEM_STATUS.SHUTTING_DOWN) { //
      return;
    }
    super.emit(LIFECYCLE_EVENTS.SHUTTING_DOWN, { system: 'RouterSystem' });
    this.state.status = SYSTEM_STATUS.SHUTTING_DOWN; //
    const shutdownStartTime = Date.now();

    try {
      if (this.router) { //
        await this.router.shutdown(); //
      }
      super.removeAllListeners(); // Clear RouterSystem's own listeners

      this.router = null; //
      this.state.status = SYSTEM_STATUS.SHUTDOWN; //
      this.state.startTime = null;
      const shutdownTime = Date.now() - shutdownStartTime;
      this.recordMetric('routersystem.shutdown.time', shutdownTime);
      this.recordMetric('routersystem.shutdown.success', 1); // [cite: 1297] (metric call)
      // Log directly as listeners removed
      this.deps.logger?.info('[RouterSystem] Shutdown complete.'); // [cite: 1299] (adapted from emit)

    } catch (error) {
      this.state.status = SYSTEM_STATUS.ERROR; //
      this.recordMetric('routersystem.shutdown.failure', 1, { error: error.code }); //
      // Use _handleInternalError for RouterSystem's own shutdown failure
      await this._handleInternalError(error, { phase: 'shutdown' }); // [cite: 1302] (adapted)
      // Original code re-threw a new RouterError.
      // For system component shutdown, it's often better to log and not prevent other shutdowns.
      // However, if ModuleSystem or Container needs to know, re-throwing might be desired.
      // Let's stick to re-throwing a standardized error for now.
      throw error instanceof RouterError ? error : new RouterError(
        ErrorCodes.ROUTER.SHUTDOWN_FAILED,
        "RouterSystem failed to shutdown.",
        { originalMessage: error.message },
        { cause: error }
      );
    }
  }

  // --- State, Health, Metrics ---
  setupDefaultHealthChecks() { //
    this.registerHealthCheck('routersystem.state', this.checkSystemState.bind(this)); //
    this.registerHealthCheck('routersystem.corerouter', this.checkCoreRouterHealth.bind(this)); // (name changed)
  }

  recordMetric(name, value, tags = {}) { //
    this.state.metrics.set(name, { value, timestamp: Date.now(), tags });
  }

  getMetrics() { //
    const metrics = {};
    for (const [name, data] of this.state.metrics) {
      metrics[name] = data;
    }
    return metrics;
  }

  registerHealthCheck(name, checkFn) { //
    if (typeof checkFn !== 'function') {
        const err = new RouterError(ErrorCodes.ROUTER.INVALID_HEALTH_CHECK || 'INVALID_HEALTH_CHECK', `RouterSystem Health check '${name}' must be a function.`); //
        this._handleInternalError(err); // Log, rethrow
        throw err;
    }
    this.state.healthChecks.set(name, checkFn);
  }

  async checkHealth() { //
    // This is for RouterSystem's own health, including its managed CoreRouter.
    const results = {};
    let overallStatus = SYSTEM_STATUS.HEALTHY;

    for (const [name, checkFn] of this.state.healthChecks) { //
      try {
        const checkResult = await checkFn(); // Expects standard health object
        results[name] = checkResult; //
        if (checkResult.status !== SYSTEM_STATUS.HEALTHY) { //
          overallStatus = (overallStatus === SYSTEM_STATUS.HEALTHY && checkResult.status === SYSTEM_STATUS.DEGRADED)
            ? SYSTEM_STATUS.DEGRADED
            : SYSTEM_STATUS.UNHEALTHY; //
        }
      } catch (error) {
        results[name] = createStandardHealthCheckResult(SYSTEM_STATUS.UNHEALTHY, { error: 'Health check threw an exception' }, [error]); // (adapted)
        overallStatus = SYSTEM_STATUS.UNHEALTHY; //
      }
    }
    return { //
      name: this.constructor.name,
      version: RouterSystem.version,
      status: overallStatus,
      timestamp: new Date().toISOString(),
      uptime: this.state.startTime ? Date.now() - this.state.startTime : 0,
      errorCount: this.state.errors.length,
      checks: results,
    };
  }

  async checkSystemState() {
    return createStandardHealthCheckResult(
      this.state.status === SYSTEM_STATUS.RUNNING ? SYSTEM_STATUS.HEALTHY : SYSTEM_STATUS.UNHEALTHY,
      {
        currentStatus: this.state.status,
        uptime: this.state.startTime ? Date.now() - this.state.startTime : 0,
        internalErrorCount: this.state.errors.length
      }
    );
  }

  async checkCoreRouterHealth() { // (was check for 'router')
    if (!this.router || typeof this.router.checkHealth !== 'function') { //
      return createStandardHealthCheckResult(SYSTEM_STATUS.UNHEALTHY, { reason: 'CoreRouter not available or does not support health checks.' }); //
    }
    try {
      return await this.router.checkHealth(); // // CoreRouter.checkHealth already returns standard object
    } catch (error) {
      return createStandardHealthCheckResult(SYSTEM_STATUS.UNHEALTHY, { error: 'CoreRouter health check failed.' }, [error]); //
    }
  }

  getSystemStatus() { //
    return {
        name: this.constructor.name,
        version: RouterSystem.version,
        status: this.state.status,
        uptime: this.state.startTime ? Date.now() - this.state.startTime : 0,
        initialized: this.state.status === SYSTEM_STATUS.RUNNING,
        errorCount: this.state.errors.length,
        timestamp: new Date().toISOString(),
        coreRouterStatus: this.router ? this.router.getSystemStatus().status : SYSTEM_STATUS.UNAVAILABLE || 'unavailable'
    };
  }
}

/**
 * Factory function for creating a RouterSystem instance.
 * @param {object} [deps={}] - Dependencies for the RouterSystem.
 * @returns {RouterSystem}
 */
export function createRouterSystem(deps = {}) { //
  try {
    // Constructor now handles its own dependency validation.
    // Default deps logic from original factory is useful if deps might be sparse.
    const defaultDeps = { //
      errorSystem: deps.errorSystem || { handleError: async () => { console.error("Default No-Op ErrorSystem used in RouterSystem factory"); } },
      eventBusSystem: deps.eventBusSystem || { getEventBus: () => new EventEmitter() },
      config: deps.config || {},
    };
    return new RouterSystem({ ...defaultDeps, ...deps }); //
  } catch (error) { //
    // This top-level catch in factory is good for creation-time issues
    console.error("[RouterSystem Factory] Failed to create RouterSystem:", error); //
    throw error instanceof RouterError ? error : new RouterError( //
      ErrorCodes.ROUTER.CREATION_FAILED || 'CREATION_FAILED',
      "Failed to create RouterSystem instance.",
      { originalMessage: error.message },
      { cause: error }
    );
  }
}

// Default export was an object containing class and factory.
// export default { RouterSystem, createRouterSystem };


// src/core/router/index.js

/**
 * @file src/core/router/index.js
 * @description Main public interface for the TSMIS Router System.
 * Exports CoreRouter, RouterSystem, RoutableModule, their factory functions,
 * and available framework integration adapters.
 */

import { CoreRouter } from './CoreRouter.js';
import { RouterSystem, createRouterSystem } from './RouterSystem.js';
import { RoutableModule, createRoutableModule } from './RoutableModule.js';

// Import integration components from ./integrations/index.js
// which now exports IRouterAdapter and FastifyAdapter
import {
  IRouterAdapter,
  FastifyAdapter
} from './integrations/index.js';

// Export all core router classes and their factory functions
export {
  CoreRouter,         // The core routing engine
  RouterSystem,       // The managing facade for CoreRouter
  createRouterSystem, // Factory for RouterSystem
  RoutableModule,     // Base class for modules that define routes
  createRoutableModule, // Factory for RoutableModule
};

// Export adapter interface and specific adapters
export {
  IRouterAdapter,     // Interface for all router adapters
  FastifyAdapter,     // Specific adapter for Fastify
  // ExpressAdapter, // Omitted as per user request
};

// Optional: A default export grouping the most common components,
// similar to the original structure, but adapted.
export default {
  CoreRouter,
  RouterSystem,
  createRouterSystem,
  RoutableModule,
  createRoutableModule,
  integrations: {
    IRouterAdapter,
    FastifyAdapter,
    // ExpressAdapter, // Omitted
  },
};


// src/core/router/integrations/IRouterAdapter.js

/**
 * @file src/core/router/integrations/IRouterAdapter.js
 * @description Defines the interface for framework-specific router adapters
 * that integrate with the CoreRouter.
 */

/**
 * @interface IRouterAdapter
 * @description Interface that framework-specific router adapters must implement.
 * These adapters are responsible for taking a list of standardized route definitions
 * from CoreRouter and applying them to a specific HTTP web framework instance.
 */
export class IRouterAdapter {
  /**
   * Applies an array of route definitions to the given web framework instance.
   * Each route object in the array will typically include:
   * - `method`: (string) The HTTP method (e.g., 'GET', 'POST').
   * - `path`: (string) The route path.
   * - `handler`: (Function) The request handler function.
   * - `options`: (object) An object containing any framework-specific options,
   * schema definitions, middleware references, etc.
   * - `resolvedMiddleware`: (Array<Function>) An array of actual middleware handler
   * functions to be applied to this route, pre-resolved by CoreRouter.
   *
   * @param {object} framework - The instance of the web framework (e.g., Fastify app, Express app).
   * @param {Array<object>} routes - An array of route definition objects.
   * @returns {Promise<object|void>|object|void} The framework instance with routes applied, or nothing.
   * Return type can be Promise if adapter's operations are async.
   * @throws {Error} If the framework instance is invalid or if applying routes fails.
   */
  async applyRoutes(framework, routes) {
    // This check ensures that users of this "interface" (which is a class in JS)
    // know that this method MUST be overridden.
    if (this.constructor === IRouterAdapter) {
        throw new Error('IRouterAdapter.applyRoutes() is an abstract method and must be implemented by a subclass.');
    }
    // The actual implementation will be in concrete adapters like FastifyAdapter.js
    // For the purpose of this interface file, we can throw or leave it more abstract.
    // Throwing ensures it's not called directly on an IRouterAdapter instance.
    throw new Error('IRouterAdapter.applyRoutes() must be implemented by subclass.'); // [cite: 1316]
  }

  /**
   * Optional method for adapters to perform any necessary cleanup during shutdown.
   * For example, an adapter might need to release resources or unregister global handlers.
   *
   * @returns {Promise<void>|void}
   */
  async shutdown() {
    // Subclasses can override this if they have specific shutdown logic.
  }
}

// Named export is generally preferred for classes/interfaces in ES Modules.
// export default IRouterAdapter; // Original export [cite: 1316]


// src/core/router/integrations/fastify/FastifyAdapter.js

/**
 * @file src/core/router/integrations/fastify/FastifyAdapter.js
 * @description Implements IRouterAdapter for the Fastify web framework.
 */

import { IRouterAdapter } from '../IRouterAdapter.js';
import { CoreError } from '../../../errors/CoreError.js'; // For throwing specific errors if needed
import { ErrorCodes } from '../../../errors/ErrorCodes.js'; // For standardized error codes

export class FastifyAdapter extends IRouterAdapter {
  /**
   * @type {object|null}
   */
  logger = null;

  /**
   * Creates an instance of FastifyAdapter.
   * @param {object} [options={}] - Optional adapter configuration.
   * @param {object} [options.logger=console] - A logger instance.
   */
  constructor(options = {}) {
    super();
    this.logger = options.logger || console;
  }

  /**
   * Applies an array of route definitions to the given Fastify framework instance.
   *
   * @param {object} fastify - The Fastify framework instance.
   * @param {Array<object>} routes - An array of route definition objects. Each object includes:
   * - `method`: (string) The HTTP method.
   * - `path`: (string) The route path.
   * - `handler`: (Function) The main request handler function.
   * - `options`: (object) Route-specific options, which might include `options.fastify`
   * for Fastify-specific settings and `options.schema` for validation.
   * - `resolvedMiddleware`: (Array<Function>) An array of pre-resolved middleware
   * handler functions to be applied as preHandler hooks.
   * @returns {Promise<object>} The Fastify instance with routes applied.
   * @throws {CoreError} If the Fastify instance is invalid.
   * @override
   */
  async applyRoutes(fastify, routes) { //
    if (!fastify || typeof fastify.route !== 'function') { //
      throw new CoreError(
        ErrorCodes.ROUTER.INVALID_FRAMEWORK || 'ROUTER_INVALID_FRAMEWORK', // Ensure this code exists
        'Invalid Fastify instance provided to FastifyAdapter.'
      );
    }

    this.logger.info(`[FastifyAdapter] Applying ${routes.length} routes to Fastify instance.`);

    for (const route of routes) { //
      const { method, path, handler, options = {}, resolvedMiddleware = [] } = route; //

      // Extract Fastify-specific options and schema from the general route options
      const fastifySpecificOptions = options.fastify || {};
      const schema = options.schema || fastifySpecificOptions.schema || {}; // Prioritize options.schema

      const routeConfig = { //
        method: method.toUpperCase(), // Ensure method is uppercase for Fastify
        url: path, //
        schema,    //
        handler,   //
        ...fastifySpecificOptions, // Spread other Fastify-specific options (e.g., constraints, version)
      };

      // Add resolved middleware as preHandler hooks
      // Fastify's preHandler can be a single function or an array of functions.
      if (resolvedMiddleware && resolvedMiddleware.length > 0) {
        routeConfig.preHandler = resolvedMiddleware; //
      }

      try {
        fastify.route(routeConfig); //
        this.logger.debug(`[FastifyAdapter] Applied route: ${routeConfig.method} ${routeConfig.url}`);
      } catch (error) {
        // Fastify usually handles its own route definition errors well,
        // but catch any unexpected errors during the .route() call.
        const routeApplicationError = new CoreError(
          ErrorCodes.ROUTER.ROUTES_APPLICATION_FAILED,
          `Failed to apply route ${routeConfig.method} ${routeConfig.url} to Fastify.`,
          { routePath: routeConfig.url, routeMethod: routeConfig.method, originalMessage: error.message },
          { cause: error }
        );
        // Log it via the adapter's logger, as this is an adapter operational issue.
        // The caller (CoreRouter.applyRoutes) will catch this and handle it with ErrorSystem.
        this.logger.error(routeApplicationError.message, routeApplicationError.toJSON());
        throw routeApplicationError; // Re-throw for CoreRouter to handle
      }
    }

    this.logger.info(`[FastifyAdapter] Successfully applied ${routes.length} routes.`);
    return fastify; //
  }

  /**
   * Optional shutdown logic for the FastifyAdapter.
   */
  async shutdown() {
    this.logger.info('[FastifyAdapter] Shutdown.');
    // No specific resources to release for this adapter in its current form.
  }
}

// Default export for consistency if other adapters follow this pattern
// export default FastifyAdapter; // Original had this


// src/core/router/integrations/fastify/index.js

/**
 * @file src/core/router/integrations/fastify/index.js
 * @description Barrel file for exporting Fastify integration components for the RouterSystem.
 */

import { FastifyAdapter } from './FastifyAdapter.js';

export {
  FastifyAdapter,
};

// Optional default export:
// export default FastifyAdapter; // If FastifyAdapter is the sole main export


// src/core/router/integrations/index.js

/**
 * @file src/core/router/integrations/index.js
 * @description Barrel file for exporting router integration interfaces and available adapters.
 */

import { IRouterAdapter } from './IRouterAdapter.js';
import { FastifyAdapter } from './fastify/index.js'; // Imports FastifyAdapter from its own index.js

export {
  IRouterAdapter,
  FastifyAdapter,
};

// Optional default export for grouping, if preferred:
// export default {
//   IRouterAdapter,
//   adapters: {
//     FastifyAdapter, // The only adapter currently
//   }
// };


// src/core/router/router-system.md

# TSMIS Routing System Documentation
Version: 2.0.0 (Refactored Core)

## Table of Contents

1.  [Introduction to the Routing System](#1-introduction-to-the-routing-system)
    * [1.1. Purpose & Philosophy](#11-purpose--philosophy)
    * [1.2. Key Components & Their Roles](#12-key-components--their-roles)
2.  [Component: `RoutableModule.js` - Defining Routes in Modules](#2-component-routablemodulejs---defining-routes-in-modules)
    * [2.1. Overview & Purpose](#21-overview--purpose)
    * [2.2. Key API for Route Definition](#22-key-api-for-route-definition)
        * [`registerRoute(method, path, handler, options)`](#registerroutemethod-path-handler-options)
        * [`registerVersionedRoute(version, method, path, handler, options)`](#registerversionedrouteversion-method-path-handler-options)
    * [2.3. Lifecycle Integration for Route Registration/Unregistration](#23-lifecycle-integration-for-route-registrationunregistration)
    * [2.4. Event Emission for Routes](#24-event-emission-for-routes)
3.  [Component: `CoreRouter.js` - The Routing Engine](#3-component-corerouterjs---the-routing-engine)
    * [3.1. Overview & Primary Responsibility](#31-overview--primary-responsibility)
    * [3.2. Key Functionalities & API (`CoreRouter`)](#32-key-functionalities--api-corerouter)
        * [3.2.1. Event-Driven Route Management](#321-event-driven-route-management)
        * [3.2.2. Route Registry & Conflict Detection](#322-route-registry--conflict-detection)
        * [3.2.3. Adapter Management (`registerAdapter`, `IRouterAdapter`)](#323-adapter-management-registeradapter-irouteradapter)
        * [3.2.4. Middleware Management (`registerMiddleware`, `getMiddlewareForRoute`)](#324-middleware-management-registermiddleware-getmiddlewareforroute)
        * [3.2.5. Applying Routes (`applyRoutes`)](#325-applying-routes-applyroutes)
        * [3.2.6. OpenAPI Documentation Generation (`generateOpenApiDoc`)](#326-openapi-documentation-generation-generateopenapidoc)
    * [3.3. State Management (`CoreRouter` Specifics)](#33-state-management-corerouter-specifics)
    * [3.4. Lifecycle Management (`CoreRouter` Specifics)](#34-lifecycle-management-corerouter-specifics)
    * [3.5. Error Handling within `CoreRouter`](#35-error-handling-within-corerouter)
    * [3.6. Event Integration (`CoreRouter` Specifics)](#36-event-integration-corerouter-specifics)
    * [3.7. Health Monitoring (`CoreRouter` Specifics)](#37-health-monitoring-corerouter-specifics)
    * [3.8. Metrics Tracking (`CoreRouter` Specifics)](#38-metrics-tracking-corerouter-specifics)
4.  [Component: `RouterSystem.js` - The Managing Facade](#4-component-routersystemjs---the-managing-facade)
    * [4.1. Overview & Primary Responsibility](#41-overview--primary-responsibility)
    * [4.2. Key Functionalities & API (`RouterSystem`)](#42-key-functionalities--api-routersystem)
        * [4.2.1. `initialize()` & `shutdown()`](#421-initialize--shutdown)
        * [4.2.2. `getRouter()`](#422-getrouter)
        * [4.2.3. Delegated `CoreRouter` Methods](#423-delegated-corerouter-methods)
    * [4.3. Adherence to Standardization Pillars (Recap for `RouterSystem`)](#43-adherence-to-standardization-pillars-recap-for-routersystem)
    * [4.4. State Management (`RouterSystem` Specifics)](#44-state-management-routersystem-specifics)
    * [4.5. Lifecycle Management (`RouterSystem` Specifics)](#45-lifecycle-management-routersystem-specifics)
    * [4.6. Error Handling within `RouterSystem`](#46-error-handling-within-routersystem)
    * [4.7. Event Integration (`RouterSystem` Specifics - Forwarding)](#47-event-integration-routersystem-specifics---forwarding)
    * [4.8. Health Monitoring (`RouterSystem` Specifics)](#48-health-monitoring-routersystem-specifics)
    * [4.9. Metrics Tracking (`RouterSystem` Specifics)](#49-metrics-tracking-routersystem-specifics)
    * [4.10. Static Factory (`createRouterSystem`)](#410-static-factory-createroutersystem)
5.  [Integrations (Routing System Level)](#5-integrations-routing-system-level)
6.  [Overall Routing Flow Diagram (Route Definition to Application)](#6-overall-routing-flow-diagram-route-definition-to-application)
7.  [Usage Examples & Best Practices](#7-usage-examples--best-practices)
    * [7.1. Defining Routes in a `RoutableModule`](#71-defining-routes-in-a-routablemodule)
    * [7.2. Registering a Framework Adapter (e.g., Fastify)](#72-registering-a-framework-adapter-eg-fastify)
    * [7.3. Registering and Using Middleware](#73-registering-and-using-middleware)
    * [7.4. Applying Routes to a Web Framework](#74-applying-routes-to-a-web-framework)
    * [7.5. Generating OpenAPI Documentation](#75-generating-openapi-documentation)
8.  [Testing Strategy Notes](#8-testing-strategy-notes)
9.  [Future Considerations & Potential Enhancements](#9-future-considerations--potential-enhancements)

---

## 1. Introduction to the Routing System

### 1.1. Purpose & Philosophy
The TSMIS Routing System provides a structured, flexible, and framework-agnostic way to define, manage, and serve HTTP routes. Its core philosophy is to decouple the definition of API endpoints (which reside within business modules) from the underlying HTTP web framework (e.g., Fastify) used to serve them. This promotes modularity, testability, and the ability to potentially switch or use multiple web frameworks with minimal changes to business logic.

Key goals include:
* **Framework Agnosticism**: Modules define routes without direct ties to a specific web server's API.
* **Centralized Route Management**: `CoreRouter` acts as a single registry for all application routes.
* **Event-Driven Route Registration**: `RoutableModule`s announce their routes via events, which `CoreRouter` subscribes to.
* **Pluggable Adapters**: `IRouterAdapter` implementations bridge `CoreRouter` to specific web frameworks.
* **Middleware Support**: A consistent way to define and apply middleware to routes.
* **API Documentation**: Automated generation of OpenAPI (Swagger) specifications from route definitions.
* **Standardization**: Adherence to core TSMIS patterns for lifecycle, errors, health, and metrics.

### 1.2. Key Components & Their Roles
* **`RoutableModule.js`**: An extension of `CoreModule` that business modules inherit from if they need to define HTTP routes. It provides `registerRoute()` and `registerVersionedRoute()` methods and emits events for route registration/unregistration during its lifecycle.
* **`CoreRouter.js`**: The engine of the routing system. It listens for route definition events from `RoutableModule`s via the `CoreEventBus`, maintains an internal registry of all routes, checks for conflicts, manages framework adapters (implementations of `IRouterAdapter`), and handles middleware logic. It's responsible for applying these routes to a web framework instance through a chosen adapter and can generate OpenAPI documentation.
* **`RouterSystem.js`**: The high-level facade that manages the `CoreRouter` instance. It handles the lifecycle of `CoreRouter`, provides a simplified API for common tasks like registering adapters and applying routes, and integrates the routing subsystem into the application's standard monitoring and lifecycle frameworks. Application bootstrap code typically interacts with `RouterSystem`.
* **`IRouterAdapter.js`**: An interface defining the contract for framework-specific adapters (e.g., `FastifyAdapter.js`). Adapters are responsible for translating the standardized route definitions from `CoreRouter` into the specific API calls required by a web framework.
* **`FastifyAdapter.js`** (Example Integration): A concrete implementation of `IRouterAdapter` for the Fastify web framework.

## 2. Component: `RoutableModule.js` - Defining Routes in Modules

**(This section provides a summary. Full details are in the standalone `RoutableModule-docs.md`.)**

### 2.1. Overview & Purpose
`RoutableModule` extends `CoreModule` to empower business modules with the ability to define their own HTTP API routes. It provides a standardized API for route definition and integrates this process with the module's lifecycle, emitting events that the `CoreRouter` listens to. This decouples route definition from the central routing mechanism and the specific web framework being used.

### 2.2. Key API for Route Definition
* **`registerRoute(method: string, path: string, handler: Function, options = {}): RoutableModule`**: Allows modules to define a route by specifying the HTTP method, path, handler function (a method of the module), and optional parameters (e.g., schema for validation, middleware names, tags for OpenAPI).
* **`registerVersionedRoute(version: string | number, method: string, path: string, handler: Function, options = {}): RoutableModule`**: A convenience method for creating routes prefixed with a standard API version string (e.g., `/api/v1`).

### 2.3. Lifecycle Integration for Route Registration/Unregistration
* **`async onInitialize()`**: Overridden from `CoreModule`. After calling `super.onInitialize()`, it typically calls an internal `registerAllRoutes()` method which iterates through all routes defined via `registerRoute` (often defined within `onInitialize` itself before the super call) and emits `router.route.register` events for each one.
* **`async onShutdown()`**: Overridden from `CoreModule`. Before calling `super.onShutdown()`, it emits a `router.module.unregister` event with its `moduleId`. This signals `CoreRouter` to remove all routes previously registered by this module.

### 2.4. Event Emission for Routes
* **`router.route.register`**: Emitted for each route defined. Payload includes `moduleId`, `method`, `path`, `handler` (reference), and `options`.
* **`router.route.unregister`**: Emitted by `RoutableModule.unregisterRoute()` (if called manually). Payload: `{ moduleId, method, path }`.
* **`router.module.unregister`**: Emitted during `onShutdown`. Payload: `{ moduleId }`.
These events are broadcast via the `CoreEventBus` (accessed through `this.eventBus`).

## 3. Component: `CoreRouter.js` - The Routing Engine

**(This section provides a summary. Full details are in the standalone `CoreRouter-docs.md`.)**

### 3.1. Overview & Primary Responsibility
`CoreRouter` is the central processing unit for routing. It maintains a definitive registry of all application routes, manages different framework adapters, applies middleware, detects route conflicts, and can generate API documentation. It operates by subscribing to route definition events emitted by `RoutableModule`s.

### 3.2. Key Functionalities & API (`CoreRouter`)

#### 3.2.1. Event-Driven Route Management
During its `initialize()` phase, `CoreRouter` subscribes to events on the `CoreEventBus`:
* `router.route.register`: Handled by `handleRouteRegistration` to add a new route to its internal registry.
* `router.route.unregister`: Handled by `handleRouteUnregistration` to remove a specific route.
* `router.routes.clear`: Handled by `handleRoutesClear` to remove all routes.
* `router.module.unregister`: Handled by `handleModuleUnregister` to remove all routes associated with a specific module.

#### 3.2.2. Route Registry & Conflict Detection
* Routes are stored internally, typically in a `Map` keyed by `METHOD:path`.
* When `registerRoute(moduleId, method, path, handler, options)` is called (usually by an event handler), it checks for conflicts (same method and path). If a conflict exists, it throws a `RouterError`.

#### 3.2.3. Adapter Management (`registerAdapter`, `IRouterAdapter`)
* `registerAdapter(name: string, adapter: IRouterAdapter): CoreRouter`: Allows registration of framework-specific adapters (e.g., `FastifyAdapter`).
* `IRouterAdapter`: An interface that adapters must implement, primarily defining an `async applyRoutes(framework, routes)` method.

#### 3.2.4. Middleware Management (`registerMiddleware`, `getMiddlewareForRoute`)
* `registerMiddleware(name: string, handler: Function, options = {}): CoreRouter`: Registers named middleware functions with options for execution order and applicability (paths/methods).
* `getMiddlewareForRoute(route: object): Array<object>`: For a given route definition, this method resolves all applicable global and route-specific middleware (specified in `route.options.middleware`) and sorts them by their defined order. The output contains the actual middleware handler functions.

#### 3.2.5. Applying Routes (`applyRoutes`)
* `async applyRoutes(framework: object, adapterName: string): Promise<object>`: This crucial method retrieves the specified adapter and calls its `applyRoutes` method, passing the web framework instance and all registered routes. Each route object passed to the adapter includes its `resolvedMiddleware` (an array of handler functions) determined by `getMiddlewareForRoute`.

#### 3.2.6. OpenAPI Documentation Generation (`generateOpenApiDoc`)
* `generateOpenApiDoc(info = {}): object`: Constructs an OpenAPI 3.0 specification object from the current route registry, using route paths, methods, and metadata provided in `route.options` (like `summary`, `description`, `tags`, `schema`, `auth`).

### 3.3. State Management (`CoreRouter` Specifics)
Adheres to standard `this.state`. Manages internal Maps for:
* `this.routes: Map<string, object>` (route definitions).
* `this.adapters: Map<string, IRouterAdapter>` (registered framework adapters).
* `this.middleware: Map<string, object>` (registered named middleware).
* `this.subscriptions: Array<string>` (IDs for `CoreEventBus` subscriptions).

### 3.4. Lifecycle Management (`CoreRouter` Specifics)
* **`initialize()`**: Subscribes to route management events on `CoreEventBus`. Emits standard lifecycle events.
* **`shutdown()`**: Unsubscribes from all `CoreEventBus` events, clears internal registries (routes, adapters, middleware). Emits standard lifecycle events.

### 3.5. Error Handling within `CoreRouter`
* Uses `_handleInternalError` for operational errors (e.g., issues in event handlers), logging to `this.state.errors` and reporting via `safeHandleError`.
* Throws `RouterError` for API misuse or critical failures (e.g., route conflict, adapter not found, initialization failure), using codes from `ErrorCodes.ROUTER`.

### 3.6. Event Integration (`CoreRouter` Specifics)
* **Subscribes to**: `router.route.register`, `router.route.unregister`, `router.routes.clear`, `router.module.unregister` from `CoreEventBus`.
* **Emits (Operational Events via `super.emit`)**: `route:registered`, `route:unregistered`, `routes:cleared`, `adapter:registered`, `middleware:registered`, `routes:applied` to signal its own operational state changes. These are distinct from events on `CoreEventBus`.

### 3.7. Health Monitoring (`CoreRouter` Specifics)
Provides `checkHealth()`. Default checks:
* `corerouter.state`: Its lifecycle `status`, uptime, internal error count.
* `corerouter.routes`: Count of registered routes, often broken down by method.
* `corerouter.adapters`: Count of registered adapters and their names.
* `corerouter.middleware`: Count of registered named middleware and their names.

### 3.8. Metrics Tracking (`CoreRouter` Specifics)
Records metrics for lifecycle, internal errors, routes registered/unregistered/cleared/applied, and adapter/middleware registrations.

## 4. Component: `RouterSystem.js` - The Managing Facade

**(This section details the `RouterSystem` class. Full individual documentation would be in `router-system-docs.md`.)**

### 4.1. Overview & Primary Responsibility
`RouterSystem` serves as the high-level entry point and managing facade for the application's routing capabilities. It simplifies interaction with the routing subsystem by orchestrating the `CoreRouter` instance, handling its lifecycle, and ensuring the routing functionality is integrated with the application's standard error handling, health monitoring, and metrics systems.

### 4.2. Key Functionalities & API (`RouterSystem`)

#### 4.2.1. `initialize()` & `shutdown()`
* **`async initialize(): Promise<RouterSystem>`**: Creates and initializes its internal `CoreRouter` instance. It then sets up event forwarding to re-emit or translate events from `CoreRouter` for system-level observation.
* **`async shutdown(): Promise<void>`**: Manages the shutdown of its `CoreRouter` instance and cleans up its own resources.

#### 4.2.2. `getRouter(): CoreRouter`
Provides access to the managed `CoreRouter` instance. This is generally used if direct interaction with `CoreRouter` features not exposed by `RouterSystem` is needed, or for introspection.

#### 4.2.3. Delegated `CoreRouter` Methods
`RouterSystem` exposes most of `CoreRouter`'s public API as its own methods. When these methods are called on `RouterSystem`, it typically:
1.  Validates its own state (e.g., ensuring it's initialized).
2.  Delegates the actual operation to the corresponding method on its `this.router` (CoreRouter) instance.
3.  Records `RouterSystem`-level metrics for the operation.
4.  Catches any `RouterError` (or other errors) thrown by `CoreRouter`, processes it using `this.handleError()` (which reports to the global `ErrorSystem` and logs to `RouterSystem`'s state), and then re-throws the original error.
Examples: `registerAdapter`, `registerMiddleware`, `applyRoutes`, `getRoutes`, `generateOpenApiDoc`, etc..

### 4.3. Adherence to Standardization Pillars (Recap for `RouterSystem`)
* **State Management**: Implements standard `this.state`. Holds the `router` (CoreRouter instance).
* **Lifecycle Management**: Manages its own lifecycle and that of `CoreRouter`. Emits standard `LIFECYCLE_EVENTS`.
* **Error Handling**: Uses `_handleInternalError` for its own errors. Uses a public `handleError` for processing errors from delegated `CoreRouter` operations, reporting via `safeHandleError`. Throws `RouterError`.
* **Health Monitoring**: `checkHealth()` aggregates its own state with `CoreRouter`'s health (via `routersystem.corerouter` check).
* **Metrics Tracking**: Records metrics for its lifecycle, internal errors, and for high-level delegated operations.
* **Factory Function**: `createRouterSystem(deps = {})` is provided.

### 4.4. State Management (`RouterSystem` Specifics)
(Covered by 4.3 - Standard `this.state` plus the `router: CoreRouter | null` instance property).

### 4.5. Lifecycle Management (`RouterSystem` Specifics)
* **`initialize()`**: Creates and initializes `CoreRouter`. Calls `_setupEventForwarding()`.
* **`shutdown()`**: Ensures `CoreRouter.shutdown()` is called. Clears its own state.

### 4.6. Error Handling within `RouterSystem`
* **Internal Errors**: `_handleInternalError` for its own operational issues (e.g., failure to create `CoreRouter`).
* **Delegated Errors**: Catches errors from `this.router.*` calls, processes them via its public `handleError` (which logs, records metrics, reports to global `ErrorSystem`, emits `system:error`), and re-throws.

### 4.7. Event Integration (`RouterSystem` Specifics - Forwarding)
`_setupEventForwarding()` listens to operational events emitted by its managed `CoreRouter` instance (e.g., `route:registered`, `adapter:registered`). `RouterSystem` then typically re-emits these events:
1.  As a system-level event with a prefix (e.g., `system:route:registered`).
2.  With the original event name (e.g., `route:registered`).
This allows other systems to listen for routing activities at either the specific `CoreRouter` level (if they have a direct reference, though less common) or at the `RouterSystem` facade level. `CoreRouter`'s own `router:error` events are also caught, processed, and re-emitted as `system:error`.

### 4.8. Health Monitoring (`RouterSystem` Specifics)
Default health checks:
* **`routersystem.state`**: Its own lifecycle `status`, uptime, internal error count.
* **`routersystem.corerouter`**: Calls `this.router.checkHealth()` and includes the full, standardized health report from `CoreRouter`.

### 4.9. Metrics Tracking (`RouterSystem` Specifics)
Records metrics for:
* Its own lifecycle: `routersystem.initialized.success/failure`, `routersystem.shutdown.success/failure`.
* Its internal errors: `routersystem.errors.internal`.
* Operational errors from `CoreRouter` (handled by `handleError`): `routersystem.errors.operational`.
* High-level delegated operations: e.g., `routersystem.routes.applied` (tags: `adapterName`, `count`).

### 4.10. Static Factory (`createRouterSystem`)
**`createRouterSystem(deps = {}): RouterSystem`** for standardized instantiation.

## 5. Integrations (Routing System Level)

The overall Routing System (`RouterSystem` managing `CoreRouter`, which processes definitions from `RoutableModule`s) integrates with:

* **`EventBusSystem` / `CoreEventBus`**: This is the backbone for `RoutableModule`s to announce their route definitions and for `CoreRouter` to subscribe to these announcements.
* **HTTP Web Frameworks (e.g., Fastify)**: `CoreRouter` uses `IRouterAdapter` implementations (like `FastifyAdapter`) to translate its internal route registry into framework-specific route configurations. This is typically triggered by an application bootstrap process calling `RouterSystem.applyRoutes()`.
* **`ErrorSystem`**: All components (`RouterSystem`, `CoreRouter`, `RoutableModule`) use the `ErrorSystem` for centralized reporting of their operational errors. `RouterSystem`'s framework integrations (for errors, like `FastifyErrorHandler`) also play a role in how routing errors are ultimately presented in HTTP responses.
* **`ModuleSystem` & `CoreModule`**: `RoutableModule` is a specialized `CoreModule` managed by `ModuleSystem`. The lifecycle of `RoutableModule`s (and thus when they emit route definition events) is controlled by `ModuleSystem`.
* **`ContainerSystem`**: `RouterSystem` (and its dependency `CoreRouter`) is typically registered with and resolved from the `ContainerSystem`. The container injects necessary dependencies like `ErrorSystem`, `EventBusSystem`, and `config` into `RouterSystem`. Modules that `RoutableModule`s might depend on for their route handlers are also resolved by the `ContainerSystem`.

## 6. Overall Routing Flow Diagram (Route Definition to Application)

**Routing System**: Overall Route Definition and Application Flow

```mermaid
graph TD
    subgraph ApplicationBootstrap [Application Bootstrap/Setup]
        direction TB
        AppSetup["App Setup Code"]
        FastifyInst["Fastify Instance"]
    end

    subgraph RoutableModuleInstance [MyRoutableModule (extends RoutableModule)]
        direction TB
        RM_Define["Define Routes (this.registerRoute(...))"]
        RM_OnInit["onInitialize() calls this.registerAllRoutes()"]
        RM_Emit["_emitRouteRegistration()"]
    end

    subgraph EventSystem [EventBusSystem & CoreEventBus]
        direction TB
        EBSys["EventBusSystem"]
        CEBus["CoreEventBus"]
        EBSys -- Provides --> CEBus
    end

    subgraph RouterSystemFacade [RouterSystem Facade]
        direction TB
        RS["RouterSystem"]
        RS_State[("this.state (System)")]
    end
    
    subgraph CoreRouterEngine [CoreRouter Engine]
        direction TB
        CR["CoreRouter"]
        CR_State[("this.state (Router)")]
        CR_Routes[("Route Registry")]
        CR_Adapters[("Adapter Registry")]
        CR_Middleware[("Middleware Registry")]
    end

    %% Initialization and Event Subscription
    AppSetup -- Creates & Initializes --> RS;
    RS -- Creates & Initializes --> CR;
    CR -- Subscribes to 'router.route.register' --> CEBus;

    %% Module Route Definition & Emission
    RM_OnInit --> RM_Emit;
    RM_Emit -- "Emits 'router.route.register' event with route definition" --> CEBus;
    
    %% CoreRouter Processes Event
    CEBus -- Delivers Event --> CR;
    CR -- "handleRouteRegistration(event)" --> CR_Routes;
    CR_Routes -- "Stores route definition" --> CR_Routes;

    %% Application Applies Routes
    AppSetup -- "1. routerSystem.registerAdapter('fastify', FastifyAdapter)" --> RS;
    RS -- Delegates --> CR;
    CR -- "Stores adapter" --> CR_Adapters;
    
    AppSetup -- "2. routerSystem.applyRoutes(FastifyInst, 'fastify')" --> RS;
    RS -- Delegates to --> CR;
    CR -- "applyRoutes(FastifyInst, 'fastify')" --> FastifyAdapterInst["FastifyAdapter Instance (from CR_Adapters)"];
    FastifyAdapterInst -- "Uses Fastify API to define routes" --> FastifyInst;

    classDef system fill:#D6EAF8,stroke:#5DADE2,stroke-width:2px;
    classDef module fill:#E8F8F5,stroke:#76D7C4,stroke-width:2px;
    classDef bus fill:#FEF9E7,stroke:#F7DC6F,stroke-width:2px;
    classDef stateNode fill:#f9f,stroke:#333,stroke-width:2px;

    class RS, CR system;
    class RM_OnInit, RM_Define, RM_Emit module;
    class EBSys, CEBus bus;
    class RS_State, CR_State, CR_Routes, CR_Adapters, CR_Middleware stateNode;
```

## 7. Usage Examples & Best Practices

### 7.1. Defining Routes in a `RoutableModule`
(Refer to Section 7.3.7 "InventoryModule.js (Main Module Class)" in the "Developing Business Modules" part of the main "Source of Truth" document for a detailed example.)
Key aspects:
* Extend `RoutableModule`.
* Call `this.registerRoute()` or `this.registerVersionedRoute()` within `onInitialize()` (typically before `super.onInitialize()` if relying on `registerAllRoutes` from `RoutableModule`'s base `onInitialize`).
* Implement handler methods as async methods of the module class.

### 7.2. Registering a Framework Adapter (e.g., Fastify)
(Typically done during application bootstrap)

**RouterSystem**: Registering a Framework Adapter

```javascript
// // In application bootstrap, after RouterSystem and ErrorSystem are initialized
// // Assuming 'container' is your initialized ContainerSystem instance
// // import { FastifyAdapter } from './core/router/integrations/fastify/FastifyAdapter.js';
// // import { ErrorCodes } from './core/errors/ErrorCodes.js';

// async function setupRouterAdapter(container) {
//   try {
//     const routerSystem = await container.resolve('routerSystem');
//     const logger = await container.resolve('logger'); // Assuming a logger is registered

//     // Create an instance of your adapter
//     const fastifyAdapter = new FastifyAdapter({ logger });

//     // Register the adapter with RouterSystem
//     routerSystem.registerAdapter('fastifyHttp', fastifyAdapter); // Use a descriptive name

//     logger.info('[AppSetup] FastifyAdapter registered with RouterSystem as "fastifyHttp".');
//   } catch (error) {
//     // Handle error (e.g., RouterSystem not resolved, adapter registration failed)
//     const errorSystem = await container.resolve('errorSystem');
//     await errorSystem.handleError(error, {
//       source: 'setupRouterAdapter',
//       message: 'Failed to setup router adapter.'
//     });
//     throw error; // Or handle more gracefully depending on bootstrap strategy
//   }
// }

// // setupRouterAdapter(container);
```

### 7.3. Registering and Using Middleware

**RouterSystem**: Registering and Using Middleware Example

```javascript
// // In application bootstrap or a dedicated middleware setup file
// // Assuming 'routerSystem' is an initialized RouterSystem instance
// // Assuming 'AuthService' is an authentication service that might be used by middleware

// // 1. Define Middleware Handlers
// async function simpleLoggerMiddleware(request, reply) {
//   request.log.info(`Request received for: ${request.method} ${request.url}`);
//   // 'done' is not typically used in Fastify async middleware, just proceed or reply/error
// }

// async function authenticationMiddleware(request, reply) {
//   // const authService = await container.resolve('authService'); // If AuthService is needed
//   const token = request.headers['authorization']?.split(' ')[1];
//   if (!token /* || !authService.isValid(token) */) {
//     request.log.warn('Authentication failed: No token or invalid token.');
//     reply.code(401).send({ message: 'Unauthorized' });
//     return reply; // Important: Signal Fastify that the request is handled and no further processing.
//   }
//   // request.user = authService.decodeToken(token); // Attach user to request
//   request.log.info('Authentication successful.');
// }

// // 2. Register Middleware with RouterSystem (via CoreRouter)
// // routerSystem.registerMiddleware('requestLogger', simpleLoggerMiddleware, { order: 10 });
// // routerSystem.registerMiddleware('authRequired', authenticationMiddleware, {
// //   order: 100,
// //   // This middleware could be applied globally or selectively via route options
// //   // paths: ['/api/v1/secure/*'] // Example: apply only to paths under /api/v1/secure/
// // });

// // 3. Applying Middleware in a RoutableModule
// // Inside a RoutableModule (e.g., SecureDataModule.js onInitialize method):
// // this.registerRoute('GET', '/secure/data', this.handleGetSecureData, {
// //   middleware: ['requestLogger', 'authRequired'] // Names of registered middleware
// // });
// //
// // this.registerRoute('GET', '/public/data', this.handleGetPublicData, {
// //   middleware: ['requestLogger'] // Only logger for this one
// // });
```

### 7.4. Applying Routes to a Web Framework
(Typically done during application bootstrap, after modules are initialized and an adapter is registered)

**RouterSystem**: Applying Routes to Fastify Example

```javascript
// // In application bootstrap, after RouterSystem is initialized,
// // modules have emitted their routes, and an adapter is registered.
// // Assuming 'container' is your initialized ContainerSystem instance
// // import Fastify from 'fastify';

// async function startHttpServer(container) {
//   try {
//     const routerSystem = await container.resolve('routerSystem');
//     const appConfig = await container.resolve('appConfig'); // Assuming config component
//     const logger = await container.resolve('logger');

//     const fastifyApp = Fastify({
//       logger: logger, // Use your application's logger instance if compatible
//       requestIdHeader: 'x-request-id',
//     });

//     // Ensure adapter is registered (example, might be done earlier)
//     // if (!routerSystem.getRouter().adapters.has('fastifyHttp')) {
//     //   routerSystem.registerAdapter('fastifyHttp', new FastifyAdapter({ logger }));
//     // }

//     // Apply all routes known to CoreRouter (via RouterSystem) to the Fastify instance
//     await routerSystem.applyRoutes(fastifyApp, 'fastifyHttp');
//     logger.info('[AppSetup] All routes applied to Fastify.');

//     // Setup global error handler for Fastify using ErrorSystem's integration
//     // (This part requires ErrorSystem and its FastifyErrorHandler to be set up with fastifyApp)
//     // const errorSystem = await container.resolve('errorSystem');
//     // const fastifyErrorHandlerInstance = errorSystem.integrations.get('fastifyMain'); // if named 'fastifyMain'
//     // if (fastifyErrorHandlerInstance && fastifyErrorHandlerInstance.initialized) {
//     //   logger.info('[AppSetup] Fastify global error handler is configured via ErrorSystem integration.');
//     // } else {
//     //   logger.warn('[AppSetup] FastifyErrorHandler integration not found or not initialized. Global errors might not be handled consistently.');
//     // }


//     await fastifyApp.listen({ port: appConfig.port || 3000, host: '0.0.0.0' });
//     // Fastify automatically logs listening address if logger is enabled

//   } catch (error) {
//     console.error('[AppSetup] CRITICAL: Failed to start HTTP server or apply routes:', error);
//     // Use global error system if possible, otherwise console
//     // const errorSystem = container.instances.get('errorSystem'); // Be careful with direct instance access
//     // if (errorSystem) {
//     //   await errorSystem.handleError(error, { source: 'startHttpServer', criticality: 'high' });
//     // }
//     process.exit(1);
//   }
// }

// // startHttpServer(container);
```

### 7.5. Generating OpenAPI Documentation

**RouterSystem**: Generating OpenAPI Documentation Example

```javascript
// // Assuming 'routerSystem' is an initialized RouterSystem instance
// // Assuming 'appConfig' holds application metadata

// async function generateAndServeOpenApiSpec(routerSystem, appConfig) {
//   try {
//     const openApiDocument = routerSystem.generateOpenApiDoc({
//       title: appConfig.appName || 'TSMIS API',
//       version: appConfig.version || '1.0.0',
//       description: 'API documentation for the TSMIS application.',
//       // You can add more info here, like contact, license, servers
//       // And also shared components.schemas if you have common data models
//       components: {
//         schemas: {
//           // ExampleError: {
//           //   type: 'object',
//           //   properties: {
//           //     code: { type: 'string' },
//           //     message: { type: 'string' },
//           //     details: { type: 'object', additionalProperties: true }
//           //   }
//           // }
//         }
//       }
//     });

//     // Now you can do something with this document:
//     // 1. Save it to a file
//     // import fs from 'fs/promises';
//     // await fs.writeFile('openapi.json', JSON.stringify(openApiDocument, null, 2));
//     // console.log('OpenAPI specification written to openapi.json');

//     // 2. Serve it via an API endpoint (e.g., using a RoutableModule itself)
//     // (This would typically be part of a 'DocsModule' or similar)
//     // For example, a route '/docs/openapi.json' could return this object.

//     return openApiDocument;

//   } catch (error) {
//     console.error('Failed to generate OpenAPI document:', error);
//     // await routerSystem.handleError(error, { operation: 'generateOpenApiDoc' }); // If error needs central reporting
//     // Or handle locally
//     return null;
//   }
// }

// // Example usage:
// // generateAndServeOpenApiSpec(routerSystemInstance, appConfigInstance)
// //   .then(doc => {
// //     if (doc) { /* Do something with the doc */ }
// //   });
```

**Best Practices:**
* **Decouple Route Definition**: Modules define routes via `RoutableModule`; `RouterSystem` orchestrates their application.
* **Use `static dependencies`**: For route handlers in modules that need other services.
* **Clear Route Paths & Methods**: Follow RESTful principles or clear conventions.
* **Schema Validation**: Use the `options.schema` in `registerRoute` for request/response validation when using frameworks like Fastify.
* **Middleware for Cross-Cutting Concerns**: Use `CoreRouter`'s middleware for auth, logging, etc., applied globally or per route.

## 8. Testing Strategy Notes
* **`RoutableModule`**: Test route definition logic (are correct events emitted in `onInitialize`?), test route handler logic by mocking request/reply and services.
* **`CoreRouter`**: Test route registration (including conflicts), adapter registration, middleware registration and resolution (`getMiddlewareForRoute`), event handling (simulating `CoreEventBus` events), `applyRoutes` (with a mock adapter), and `generateOpenApiDoc`. Test its lifecycle, health, and metrics.
* **`RouterSystem`**: Test its management of `CoreRouter`'s lifecycle. For delegated methods, mock `CoreRouter` and verify calls are passed through correctly, and that `RouterSystem` adds its own error handling/metrics. Test event forwarding from `CoreRouter`. Test its lifecycle, health, and metrics.
* **Adapters (e.g., `FastifyAdapter`)**: Test the `applyRoutes` method with a mock framework instance and a set of sample routes (including middleware) to ensure the framework's API is called correctly.

## 9. Future Considerations & Potential Enhancements
(Adapted from original Router System docs)
* **Advanced Route Matching**: Support for more complex route patterns (e.g., regex-based), conditional routing based on request properties beyond path/method.
* **Dynamic Routing Updates**: Capabilities to update or re-prioritize routes at runtime without a full restart or re-application of all routes.
* **Enhanced Request/Response Validation**: Deeper integration with schema validation libraries, potentially with automatic type coercion or transformation based on schemas.
* **Performance Optimizations**: For systems with extremely large numbers of routes, explore route tree optimizations or caching for faster matching.
* **More Granular Middleware Control**: More sophisticated ways to apply middleware stacks conditionally.
* **Additional Framework Adapters**: Develop adapters for other popular Node.js web frameworks as needed.

