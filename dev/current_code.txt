/** Folder layout
 * cmd: npx directory-tree-ascii . -b node_modules .git

> tsmis_core@2.1.0 npx
> daa . -b node_modules .git

```
└─ .
   ├─ dev
   │  ├─ current_code.txt
   │  ├─ docs
   │  │  ├─ dev_manual.md
   │  │  └─ dev_technical.md
   │  └─ tools
   │     └─ combined.js
   ├─ package-lock.json
   ├─ package.json
   └─ src
      └─ core
         ├─ common
         │  ├─ ErrorUtils.js
         │  ├─ SystemConstants.js
         │  ├─ index.js
         │  └─ utilities-and-definitions.md
         ├─ container
         │  ├─ ContainerSystem.js
         │  ├─ container-system.md
         │  └─ index.js
         ├─ core-architecture.md
         ├─ errors
         │  ├─ CoreError.js
         │  ├─ ErrorCodes.js
         │  ├─ ErrorSystem.js
         │  ├─ error-system.md
         │  ├─ index.js
         │  ├─ integrations
         │  │  ├─ IFrameworkIntegration.js
         │  │  ├─ fastify
         │  │  │  ├─ FastifyErrorHandler.js
         │  │  │  ├─ FastifyErrorSerializer.js
         │  │  │  └─ index.js
         │  │  └─ index.js
         │  └─ types
         │     ├─ AccessError.js
         │     ├─ AuthError.js
         │     ├─ ConfigError.js
         │     ├─ EventError.js
         │     ├─ ModuleError.js
         │     ├─ NetworkError.js
         │     ├─ RouterError.js
         │     ├─ ServiceError.js
         │     ├─ ValidationError.js
         │     └─ index.js
         ├─ event
         │  ├─ CoreEventBus.js
         │  ├─ EventBusSystem.js
         │  ├─ eventbus-system.md
         │  └─ index.js
         ├─ module
         │  ├─ CoreModule.js
         │  ├─ ModuleSystem.js
         │  ├─ index.js
         │  └─ module-system.md
         └─ router
            ├─ CoreRouter.js
            ├─ RoutableModule.js
            ├─ RouterSystem.js
            ├─ index.js
            ├─ integrations
            │  ├─ IRouterAdapter.js
            │  ├─ fastify
            │  │  ├─ FastifyAdapter.js
            │  │  └─ index.js
            │  └─ index.js
            └─ router-system.md

```
*/


// src/core/common/ErrorUtils.js

/**
 * @file ErrorUtils.js
 * @description Shared utility functions for error handling.
 */

/**
 * Safely handles an error by attempting to forward it to the ErrorSystem.
 * If ErrorSystem is unavailable or fails, it logs the error to the console.
 *
 * @param {object|null|undefined} errorSystem - The ErrorSystem instance.
 * @param {Error} error - The error object to handle.
 * @param {object} [context={}] - Additional context for the error.
 * @returns {Promise<void>}
 */
export async function safeHandleError(errorSystem, error, context = {}) {
  const source = context.source || 'UnknownSystem';

  if (!errorSystem || typeof errorSystem.handleError !== 'function') {
    console.error(
      `[${new Date().toISOString()}] Unhandled error in ${source} (ErrorSystem unavailable/invalid):`,
      {
        errorCode: error.code,
        errorMessage: error.message,
        errorDetails: error.details,
        errorCause: error.cause,
        context,
        stack: error.stack
      }
    );
    return;
  }

  try {
    await errorSystem.handleError(error, context);
  } catch (forwardingError) {
    console.error(
      `[${new Date().toISOString()}] Failed to forward error from ${source} to ErrorSystem:`,
      {
        originalErrorCode: error.code,
        originalErrorMessage: error.message,
        forwardingErrorCode: forwardingError.code,
        forwardingErrorMessage: forwardingError.message,
        context,
        originalErrorStack: error.stack,
        forwardingErrorStack: forwardingError.stack
      }
    );
  }
}

/**
 * Creates a standardized health check result object.
 *
 * @param {string} status - The health status (e.g., SYSTEM_STATUS.HEALTHY).
 * @param {object} [detail={}] - Specific details for this health check.
 * @param {Array<Error>} [errors=[]] - Any errors encountered during the health check.
 * @returns {{status: string, detail: object, errors: Array<Error>}}
 */
export function createStandardHealthCheckResult(status, detail = {}, errors = []) {
  return {
    status,
    detail,
    errors: errors.map(err => ({ // Store a serializable summary of the error
      name: err.name,
      message: err.message,
      code: err.code,
      details: err.details,
      cause: err.cause ? { name: err.cause.name, message: err.cause.message, code: err.cause.code } : undefined
    }))
  };
}


// src/core/common/SystemConstants.js

/**
 * @file SystemConstants.js
 * @description Defines shared constants for system status and lifecycle.
 */

export const SYSTEM_STATUS = Object.freeze({
  CREATED: 'created',
  INITIALIZING: 'initializing',
  RUNNING: 'running',
  SHUTTING_DOWN: 'shutting_down',
  SHUTDOWN: 'shutdown',
  ERROR: 'error',
  DEGRADED: 'degraded', // For health checks
  HEALTHY: 'healthy',   // For health checks
  UNHEALTHY: 'unhealthy' // For health checks
});

export const LIFECYCLE_EVENTS = Object.freeze({
  INITIALIZING: 'system:initializing',
  INITIALIZED: 'system:initialized', // Or 'system:running'
  RUNNING: 'system:running',
  SHUTTING_DOWN: 'system:shutting_down',
  SHUTDOWN: 'system:shutdown',
  ERROR: 'system:error'
});

// Default configuration for common system aspects
export const DEFAULT_CONFIG = Object.freeze({
  MAX_ERROR_HISTORY: 100,
  DEFAULT_HEALTH_CHECK_INTERVAL: 30000, // ms
  DEFAULT_METRIC_FLUSH_INTERVAL: 60000 // ms (if applicable)
});


// src/core/common/index.js

/**
 * @file src/core/common/index.js
 * @description Barrel file for exporting common shared utilities and constants.
 */

export {
  SYSTEM_STATUS,
  LIFECYCLE_EVENTS,
  DEFAULT_CONFIG
} from './SystemConstants.js';

export {
  safeHandleError,
  createStandardHealthCheckResult
} from './ErrorUtils.js';


// src/core/common/utilities-and-definitions.md

# TSMIS Core Utilities and Definitions Documentation
Version: 2.1.0 (Aligned with Core System Refactor v2.0.0)

## Table of Contents

1.  [Introduction](#1-introduction)
    * [1.1. Purpose of these Foundational Files](#11-purpose-of-these-foundational-files) [cite: 30]
    * [1.2. Location in Architecture](#12-location-in-architecture) [cite: 31]
2.  [Component: `SystemConstants.js` - Shared System Constants](#2-component-systemconstantsjs---shared-system-constants)
    * [2.1. Overview & Purpose](#21-overview--purpose) [cite: 32]
    * [2.2. Key Definitions](#22-key-definitions)
        * [2.2.1. `SYSTEM_STATUS`](#221-system_status) [cite: 33]
        * [2.2.2. `LIFECYCLE_EVENTS`](#222-lifecycle_events)
        * [2.2.3. `DEFAULT_CONFIG`](#223-default_config) [cite: 34]
    * [2.3. Usage Guidelines & Example](#23-usage-guidelines--example)
3.  [Component: `ErrorUtils.js` - Error Handling and Health Utilities](#3-component-errorutilsjs---error-handling-and-health-utilities)
    * [3.1. Overview & Purpose](#31-overview--purpose) [cite: 35]
    * [3.2. Key Functions](#32-key-functions)
        * [3.2.1. `async safeHandleError(errorSystem, error, context = {})`](#321-async-safehandleerrorerrorsystem-error-context---) [cite: 36]
        * [3.2.2. `createStandardHealthCheckResult(status, detail = {}, errors = [])`](#322-createstandardhealthcheckresultstatus-detail---errors---) [cite: 37]
    * [3.3. Usage Guidelines & Examples](#33-usage-guidelines--examples) [cite: 38]
4.  [Component: `ErrorCodes.js` - Standardized Error Identifiers](#4-component-errorcodesjs---standardized-error-identifiers)
    * [4.1. Overview & Purpose](#41-overview--purpose) [cite: 39]
    * [4.2. Structure and Naming Convention](#42-structure-and-naming-convention)
    * [4.3. Usage Guidelines](#43-usage-guidelines) [cite: 40]
    * [4.4. Integration with `CoreError` and `ErrorSystem`](#44-integration-with-coreerror-and-errorsystem)
    * [4.5. Example Snippet](#45-example-snippet) [cite: 41]
5.  [Overall Integration and Importance](#5-overall-integration-and-importance)
6.  [Testing Strategy Notes (for Utilities)](#6-testing-strategy-notes-for-utilities)
7.  [Future Considerations](#7-future-considerations)

---

## 1. Introduction

### 1.1. Purpose of these Foundational Files [cite: 30]
The TSMIS core architecture relies on a set of foundational utility files that provide shared constants, error handling helper functions, and a centralized registry of error codes. [cite: 42] These files are essential for ensuring consistency, reducing redundancy, and promoting robust behavior across all core systems and business modules. [cite: 43] This document details these key utilities: `SystemConstants.js`, `ErrorUtils.js`, and `ErrorCodes.js`. [cite: 44]

### 1.2. Location in Architecture [cite: 31]
* `SystemConstants.js` and `ErrorUtils.js` are typically located in `src/core/common/`. [cite: 45]
* `ErrorCodes.js` is located in `src/core/errors/`. [cite: 45]
These utilities are designed to have minimal dependencies and are used extensively by higher-level core systems and application modules. [cite: 46]

---
## 2. Component: `SystemConstants.js` - Shared System Constants

### 2.1. Overview & Purpose [cite: 32]
`SystemConstants.js` is the definitive source for shared, immutable constants that govern system-wide states (like component lifecycle statuses and health statuses), standard names for lifecycle events, and default fallback values for common configuration parameters. [cite: 47] Using these centralized constants prevents "magic strings" or "magic numbers," reduces the risk of typos, and makes global adjustments to these standard values straightforward. [cite: 48]

### 2.2. Key Definitions
All constant objects in this file are frozen using `Object.freeze()` to ensure their immutability. [cite: 49]

#### 2.2.1. `SYSTEM_STATUS` [cite: 33]
* **Definition**: An object containing standardized string values that represent the operational lifecycle status of core components (systems, modules) as well as the health status reported by health checks. [cite: 50]
* **Key Values Examples**: `CREATED`, `INITIALIZING`, `RUNNING`, `SHUTTING_DOWN`, `SHUTDOWN`, `ERROR`, `HEALTHY`, `DEGRADED`, `UNHEALTHY`. [cite: 51]
* **Primary Usage**:
    * Used within the `this.state.status` property of all core systems and `CoreModule` instances. [cite: 52]
    * The health-related statuses (`HEALTHY`, `DEGRADED`, `UNHEALTHY`) are used by health check functions and the `createStandardHealthCheckResult` utility. [cite: 53]

#### 2.2.2. `LIFECYCLE_EVENTS`
* **Definition**: An object that maps standard lifecycle phases of core components to consistent, globally unique event names. [cite: 54]
* **Key Values Examples**: `INITIALIZING: 'system:initializing'`, `INITIALIZED: 'system:initialized'`, `RUNNING: 'system:running'`, `SHUTTING_DOWN: 'system:shutting_down'`, `SHUTDOWN: 'system:shutdown'`, `ERROR: 'system:error'`. [cite: 55]
* **Primary Usage**:
    * Utilized by core systems and `CoreModule` instances when they emit events related to their own lifecycle transitions (e.g., `super.emit(LIFECYCLE_EVENTS.INITIALIZING, { system: this.constructor.name })`). [cite: 56]
    * Modules also use these to create component-name-scoped lifecycle events (e.g., by appending their name: `LIFECYCLE_EVENTS.INITIALIZED + ':' + this.constructor.name.toLowerCase()`). [cite: 57]

#### 2.2.3. `DEFAULT_CONFIG` [cite: 34]
* **Definition**: An object providing default fallback values for common configurable parameters that might be used within core systems or modules if specific configuration is not explicitly provided by the application's configuration. [cite: 58]
* **Key Values Examples**:
    * `MAX_ERROR_HISTORY: 100` (Default capacity for internal error logs within components' `this.state.errors` array). [cite: 59]
    * `DEFAULT_HEALTH_CHECK_INTERVAL: 30000` (Default interval in milliseconds for periodic health checks, e.g., in `CoreModule.startHealthChecks()`). [cite: 60]
* **Primary Usage**: Core systems and modules can refer to these constants as default values when a specific configuration is missing from `this.deps.config` or a module's `this.config`. [cite: 61]

**`SystemConstants.js`: Definitions**
```javascript
// src/core/common/SystemConstants.js (Illustrative Content)

export const SYSTEM_STATUS = Object.freeze({
  CREATED: 'created',
  INITIALIZING: 'initializing',
  RUNNING: 'running',
  SHUTTING_DOWN: 'shutting_down',
  SHUTDOWN: 'shutdown',
  ERROR: 'error',
  DEGRADED: 'degraded', // For health checks
  HEALTHY: 'healthy',   // For health checks
  UNHEALTHY: 'unhealthy' // For health checks
});

export const LIFECYCLE_EVENTS = Object.freeze({
  INITIALIZING: 'system:initializing',
  INITIALIZED: 'system:initialized',
  RUNNING: 'system:running',
  SHUTTING_DOWN: 'system:shutting_down',
  SHUTDOWN: 'system:shutdown',
  ERROR: 'system:error'
});

// Default configuration for common system aspects
export const DEFAULT_CONFIG = Object.freeze({
  MAX_ERROR_HISTORY: 100,
  DEFAULT_HEALTH_CHECK_INTERVAL: 30000, // ms
  DEFAULT_METRIC_FLUSH_INTERVAL: 60000 // ms (if applicable for a metrics system)
});
```


### 2.3. Usage Guidelines & Example
* **Import**: Always import the required constants or the entire constant objects from `SystemConstants.js` rather than redefining similar values elsewhere. [cite: 65]
* **Immutability**: Rely on the frozen nature of these objects; do not attempt to modify them at runtime. [cite: 66]
* **Extensibility**: If new system-wide standard statuses, lifecycle event types, or common default configurations are needed, they should be added to this central file. [cite: 67]

**Example**: Usage of SystemConstants.js
```javascript
// Example usage within a hypothetical core system component:
// import { SYSTEM_STATUS, LIFECYCLE_EVENTS, DEFAULT_CONFIG } from './src/core/common/SystemConstants.js'; // Adjust path

// class MySystem {
//   constructor(deps) {
//     this.deps = deps;
//     this.state = {
//       status: SYSTEM_STATUS.CREATED, // Using a constant for initial status
//       errors: [],
//       // ... other state properties
//     };
//     // Using a constant for a default configuration value
//     this.maxErrors = this.deps.config?.mySystem?.maxErrorHistory || DEFAULT_CONFIG.MAX_ERROR_HISTORY;
//   }

//   async initialize() {
//     if (this.state.status === SYSTEM_STATUS.RUNNING) return; // Comparing with a constant
//     this.state.status = SYSTEM_STATUS.INITIALIZING; // Setting status with a constant
//
//     // Emitting a standardized lifecycle event
//     // if (this.emit) { // Assuming 'this' is an EventEmitter
//     //   this.emit(LIFECYCLE_EVENTS.INITIALIZING, { system: this.constructor.name });
//     // }

//     // ... initialization logic ...

//     this.state.status = SYSTEM_STATUS.RUNNING;
//     // if (this.emit) {
//     //   this.emit(LIFECYCLE_EVENTS.INITIALIZED, { system: this.constructor.name });
//     //   this.emit(LIFECYCLE_EVENTS.RUNNING, { system: this.constructor.name });
//     // }
//   }

//   // ... other methods
// }
```

---
## 3. Component: `ErrorUtils.js` - Error Handling and Health Utilities

### 3.1. Overview & Purpose [cite: 35]
`ErrorUtils.js` centralizes critical utility functions that support the standardized error handling and health reporting mechanisms of the TSMIS architecture. [cite: 79] These utilities ensure consistency and robustness in these cross-cutting concerns. [cite: 80]

### 3.2. Key Functions

#### 3.2.1. `async safeHandleError(errorSystem, error, context = {})` [cite: 36]
* **Purpose**: To provide a resilient and safe way to report errors to the application's central `ErrorSystem`. [cite: 81] Its primary safety feature is a fallback mechanism: if the provided `errorSystem` instance is unavailable, invalid, or if the `errorSystem.handleError()` call itself fails, `safeHandleError` guarantees that the error is still captured by logging it directly to `console.error` with comprehensive details. [cite: 82] This prevents critical errors from being silently lost. [cite: 83]
* **Parameters**:
    * `errorSystem: object | null | undefined`: An instance of the `ErrorSystem`. [cite: 84]
    * `error: Error`: The error object to handle (ideally a `CoreError` instance). [cite: 84]
    * `context: object` (optional, default: `{}`): Contextual information about the error (e.g., `source` component, operation name). [cite: 85]
* **Returns**: `Promise<void>`. [cite: 85]

#### 3.2.2. `createStandardHealthCheckResult(status, detail = {}, errors = [])` [cite: 37]
* **Purpose**: A factory function used to construct standardized health check result objects. [cite: 86] This ensures that all individual health checks throughout the application (whether in core systems or business modules) return their status information in a uniform structure. [cite: 87] This uniformity is vital for consistent aggregation, monitoring, and automated processing of health data. [cite: 88]
* **Parameters**:
    * `status: string`: The health status (must be one of `SYSTEM_STATUS.HEALTHY`, `SYSTEM_STATUS.UNHEALTHY`, `SYSTEM_STATUS.DEGRADED`). [cite: 89]
    * `detail: object` (optional, default: `{}`): Specific, arbitrary details relevant to the health check performed. [cite: 90]
    * `errors: Array<Error>` (optional, default: `[]`): An array of `Error` objects (preferably `CoreError` instances) encountered during the check that contributed to its status. [cite: 91] The utility formats these into a serializable `ErrorSummary` structure. [cite: 92]
* **Returns**: `object` - A health check result object: `{ status: string, detail: object, errors: Array<ErrorSummary> }`. [cite: 92]

**`ErrorUtils.js`: Key Function Definitions**
```javascript
// src/core/common/ErrorUtils.js (Illustrative Content of the functions)

/**
 * Safely handles an error by attempting to forward it to the ErrorSystem.
 * If ErrorSystem is unavailable or fails, it logs the error to the console.
 */
export async function safeHandleError(errorSystem, error, context = {}) {
  const source = context.source || 'UnknownSystem';
  if (!errorSystem || typeof errorSystem.handleError !== 'function') {
    console.error(
      `[${new Date().toISOString()}] Unhandled error in ${source} (ErrorSystem unavailable/invalid):`,
      {
        errorCode: error.code,
        errorMessage: error.message,
        errorDetails: error.details,
        errorCause: error.cause,
        context,
        stack: error.stack
      }
    );
    return;
  }

  try {
    await errorSystem.handleError(error, context);
  } catch (forwardingError) {
    console.error(
      `[${new Date().toISOString()}] Failed to forward error from ${source} to ErrorSystem:`,
      {
        originalErrorCode: error.code,
        originalErrorMessage: error.message,
        forwardingErrorCode: forwardingError.code,
        forwardingErrorMessage: forwardingError.message,
        context,
        originalErrorStack: error.stack,
        forwardingErrorStack: forwardingError.stack
      }
    );
  }
}

/**
 * Creates a standardized health check result object.
 */
export function createStandardHealthCheckResult(status, detail = {}, errors = []) {
  return {
    status,
    detail,
    errors: errors.map(err => ({ // Store a serializable summary of the error
      name: err.name,
      message: err.message,
      code: err.code,
      details: err.details,
      cause: err.cause ? { name: err.cause.name, message: err.cause.message, code: err.cause.code } : undefined
    }))
  };
}
```

### 3.3. Usage Guidelines & Examples [cite: 38]
* **`safeHandleError` Usage**: This should be the standard method by which core systems and `CoreModule` derivatives (typically within their `_handleInternalError` or public `handleError` methods) report errors to the central `ErrorSystem`. [cite: 101] Always provide meaningful `context`. [cite: 102]
* **`createStandardHealthCheckResult` Usage**: All individual health check functions (the `checkFn` passed to `registerHealthCheck`) must use this utility to format their return value. [cite: 102]

**`ErrorUtils.js`: Functions Usage**
```javascript
// Example usage within a hypothetical core system or module:
// import { safeHandleError, createStandardHealthCheckResult } from '../common/ErrorUtils.js'; // Adjust path
// import { SYSTEM_STATUS } from '../common/SystemConstants.js'; // Adjust path
// import { CoreError } from '../errors/CoreError.js'; // Adjust path
// import { ErrorCodes } from '../errors/ErrorCodes.js'; // Adjust path
// import { ServiceError } from '../errors/types/ServiceError.js'; // Adjust path

// class MyComponent {
//   constructor(deps) {
//     this.deps = deps; // Should include errorSystem, logger, etc.
//     this.state = { errors: [] }; // Simplified state for example
//   }

//   async _handleInternalError(error, context = {}) { // Example internal error handler
//       const internalError = !(error instanceof CoreError)
//         ? new CoreError(ErrorCodes.CORE.INTERNAL_ERROR, error.message, context, { cause: error }) // Using a CORE prefixed code
//         : error;
//       // this.state.errors.push({ error: internalError, timestamp: new Date().toISOString(), context });
//       // ... (error array capping logic) ...
//       // this.recordMetric('mycomponent.errors.internal', 1, { errorName: internalError.name });
//       await safeHandleError(this.deps.errorSystem, internalError, { source: this.constructor.name, ...context });
//   }

//   async checkMySpecificFeature() { // Example health check function
//     let isFeatureHealthy = true;
//     let featureDetails = { status: 'online', version: '1.2.3' };
//     let encounteredErrors = [];

//     try {
//       // if (await this.someDependency.isUnresponsive()) {
//       //   isFeatureHealthy = false;
//       //   featureDetails.status = 'dependency_issue';
//       //   encounteredErrors.push(new ServiceError(
//       //       ErrorCodes.SERVICE.UNAVAILABLE, // This is now an unprefixed code, e.g., 'UNAVAILABLE'
//       //       'Dependency X is unresponsive.'
//       //   )); // ServiceError constructor will prepend 'SERVICE_'
//       // }
//     } catch (error) {
//       isFeatureHealthy = false;
//       featureDetails.error = error.message;
//       encounteredErrors.push(error);
//     }

//     return createStandardHealthCheckResult(
//       isFeatureHealthy ? SYSTEM_STATUS.HEALTHY : SYSTEM_STATUS.UNHEALTHY,
//       featureDetails,
//       encounteredErrors
//     );
//   }
// }
```

---
## 4. Component: `ErrorCodes.js` - Standardized Error Identifiers

### 4.1. Overview & Purpose [cite: 39]
`ErrorCodes.js` (located at `src/core/errors/ErrorCodes.js`) serves as the definitive, centralized registry for all standardized error code strings used within the TSMIS application. [cite: 121] Its purpose is to provide a controlled and consistent vocabulary for uniquely identifying specific error conditions, which is fundamental for effective programmatic error handling, debugging, and monitoring. [cite: 122]

### 4.2. Structure and Naming Convention
* **Main Export**: Exports a single, deeply frozen `ErrorCodes` object. [cite: 123]
* **Domains/Categories**: Error codes are hierarchically organized under top-level keys representing major application domains or core systems (e.g., `CORE`, `CONFIG`, `MODULE`, `VALIDATION`, `EVENT`, `ROUTER`, and potentially business-module specific domains like `INVENTORY`). [cite: 124] These domain keys are conventionally `PascalCase` or `UPPER_SNAKE_CASE`. [cite: 125]
* **Specific Codes**: Within each domain, individual error identifiers are `UPPER_SNAKE_CASE` keys. [cite: 125]
* **Value Format**:
    * For codes within the generic `CORE` domain (intended for direct use with `new CoreError(...)`), the string value assigned to each error code key includes the `CORE_` prefix (e.g., `ErrorCodes.CORE.UNKNOWN_ERROR` would have the string value `'CORE_UNKNOWN_ERROR'`).
    * For codes within specific domains (e.g., `VALIDATION`, `CONFIG`, `MODULE`), the string value assigned to each error code key is the **unprefixed specific part** of the code (e.g., `ErrorCodes.VALIDATION.INVALID_INPUT` would have the string value `'INVALID_INPUT'`). [cite: 126]
* **Note on Prefixes**:
    * `CoreError` subclasses (e.g., `ValidationError`, `ModuleError`) are responsible for prepending their respective domain prefix (e.g., `VALIDATION_`, `MODULE_`) to the specific, unprefixed code part (obtained from `ErrorCodes.js`) when an error instance is created. For example, `new ValidationError(ErrorCodes.VALIDATION.INVALID_INPUT, ...)` (where `ErrorCodes.VALIDATION.INVALID_INPUT` provides `'INVALID_INPUT'`) would result in an `error.code` of `'VALIDATION_INVALID_INPUT'`. [cite: 127]
    * If a base `CoreError` is thrown directly and needs to represent a domain-specific error, the appropriate prefix must be manually prepended to the specific code part from `ErrorCodes.js` to ensure global uniqueness and clarity (e.g., `new CoreError(\`CONFIG_${ErrorCodes.CONFIG.LOAD_FAILED}\`, ...)` if `ErrorCodes.CONFIG.LOAD_FAILED` is the unprefixed `'LOAD_FAILED'`), or `ErrorSystem.createError(typeName, code, ...)` should be used, as it handles appropriate prefixing based on the `typeName`. [cite: 129]

### 4.3. Usage Guidelines [cite: 40]
* **Import & Reference**: Always import the `ErrorCodes` object and use its constants when instantiating `CoreError` or its subclasses. [cite: 132] This prevents typos and ensures use of defined codes. [cite: 133]
* **Adding New Codes**: When a new distinct error condition is identified:
    1.  Determine the appropriate domain/category within `ErrorCodes.js`. [cite: 133] Create a new domain object if necessary. [cite: 134]
    2.  Add a new, descriptive `UPPER_SNAKE_CASE` key for the error within its domain. [cite: 134]
    3.  Assign it an unprefixed string value (typically matching the key) if it's for a specific domain whose errors are thrown via a `CoreError` subclass. For `CORE` domain errors, assign the fully prefixed string value. [cite: 135]
    4.  Ensure all nested objects within `ErrorCodes` remain frozen with `Object.freeze()`. [cite: 136]

### 4.4. Integration with `CoreError` and `ErrorSystem`
* **`CoreError` Subclasses**: Constructors of specialized error types (e.g., `ValidationError`) use a specific, unprefixed code from `ErrorCodes.DOMAIN.CODE_NAME` (e.g., `ErrorCodes.VALIDATION.INVALID_INPUT` which is `'INVALID_INPUT'`) and prepend their domain (e.g., `VALIDATION_`) to form the final `error.code`. [cite: 137]
* **`ErrorSystem`**:
    * The `createError(typeName, code, ...)` method expects the specific (unprefixed) `code` from `ErrorCodes.js` for domain-specific errors and uses the `typeName` to find the correct `CoreError` subclass (which then adds its domain prefix). If `typeName` is `'CoreError'`, the `code` argument should be the fully prefixed code (e.g., from `ErrorCodes.CORE`). [cite: 138]
    * Custom handlers registered with `ErrorSystem.registerHandler()` can switch on the full, prefixed `error.code` (e.g., `'VALIDATION_INVALID_INPUT'`) to implement specific logic. [cite: 139]
    * Framework integrations often map external error states to these internal `ErrorCodes` (passing the unprefixed specific code to `ErrorSystem.createError` or the appropriate subclass constructor) when creating `CoreError` instances. [cite: 140]

### 4.5. Example Snippet [cite: 41]
**Example**: Snippet from `ErrorCodes.js` Structure (Illustrative)
```javascript
// src/core/errors/ErrorCodes.js (Illustrative Snippet - showing new unprefixed style for domains)

// export const ErrorCodes = Object.freeze({
//   CORE: Object.freeze({ // Values are fully prefixed
//     UNKNOWN_ERROR: 'CORE_UNKNOWN_ERROR',
//     INTERNAL_ERROR: 'CORE_INTERNAL_ERROR',
//     NOT_IMPLEMENTED: 'CORE_NOT_IMPLEMENTED',
//     // ...
//   }),
//   CONFIG: Object.freeze({ // Values are unprefixed specific parts
//     LOAD_FAILED: 'LOAD_FAILED',
//     VALIDATION_FAILED: 'VALIDATION_FAILED',
//     MISSING_REQUIRED_FIELD: 'MISSING_REQUIRED_FIELD',
//     // ...
//   }),
//   VALIDATION: Object.freeze({ // Values are unprefixed specific parts for ValidationError instances
//     INVALID_INPUT: 'INVALID_INPUT',
//     SCHEMA_MISMATCH: 'SCHEMA_MISMATCH',
//     REQUIRED_FIELD: 'REQUIRED_FIELD',
//     // ...
//   }),
//   // ... other domains like MODULE, EVENT, ROUTER, SERVICE, NETWORK, AUTH, ACCESS ...
//   // e.g., SERVICE: Object.freeze({ OPERATION_FAILED: 'OPERATION_FAILED', UNAVAILABLE: 'UNAVAILABLE' })
// });
```

---
## 5. Overall Integration and Importance
These common utilities (`SystemConstants.js`, `ErrorUtils.js`) and definitions (`ErrorCodes.js`) are not standalone systems but rather foundational building blocks. [cite: 141]
* They are imported and used by all core systems (`ContainerSystem`, `ErrorSystem`, `EventBusSystem`, `ModuleSystem`, `RouterSystem`) and the base classes (`CoreModule`, `CoreError`). [cite: 142]
* Their consistent use enforces the standardization pillars of the architecture, particularly around lifecycle management, error handling, and health monitoring. [cite: 143]
* They contribute significantly to reducing boilerplate, improving code clarity, and enhancing the overall robustness and maintainability of TSMIS. [cite: 144]

---
## 6. Testing Strategy Notes (for Utilities)
* **`SystemConstants.js`**:
    * Verify that the exported objects (`SYSTEM_STATUS`, `LIFECYCLE_EVENTS`, `DEFAULT_CONFIG`) are deeply frozen to ensure immutability. [cite: 145]
    * Check that key constant values are correct and present. [cite: 146]
* **`ErrorUtils.js`**:
    * **`safeHandleError`**: Test thoroughly with:
        * A valid, working `ErrorSystem` instance (ensure `errorSystem.handleError` is called). [cite: 147]
        * A `null` or `undefined` `errorSystem` instance (ensure `console.error` is called with correct details). [cite: 148]
        * An `errorSystem` instance where `handleError` itself throws an error (ensure `console.error` is called with both original and forwarding error details). [cite: 149]
    * **`createStandardHealthCheckResult`**: Test that it produces objects with the correct structure (`{ status, detail, errors }`) and that the `errors` array contains correctly summarized error information. [cite: 150]
* **`ErrorCodes.js`**:
    * Verify that the main `ErrorCodes` object and its nested domain objects are deeply frozen. [cite: 151]
    * Check for uniqueness of error code string values (if feasible with tooling, otherwise by convention and review). [cite: 152]
    * Ensure the structure is as expected. [cite: 153]

---
## 7. Future Considerations
* **`ErrorCodes.js` Linting/Validation**: Implement automated checks to ensure uniqueness of error codes and adherence to naming conventions. [cite: 153]
* **`SystemConstants.js` Expansion**: As new common states or event types emerge across multiple systems, they should be added here. [cite: 154]
* **`ErrorUtils.js` Further Utilities**: Potentially add more error-related helper functions if common patterns emerge (e.g., more sophisticated error wrapping or formatting utilities, though much of this is handled by `CoreError` itself). [cite: 155]


// src/core/container/ContainerSystem.js

/**
 * @file ContainerSystem.js
 * @description Dependency Injection (DI) and Inversion of Control (IoC) container.
 * Manages component lifecycles, dependencies, and system initialization.
 */

import { EventEmitter } from 'events';
import { CoreError } from '../errors/CoreError.js'; // Added for direct CoreError usage
import { ConfigError, ServiceError } from '../errors/index.js'; // Assuming errors/index.js exports these
import { ErrorCodes } from '../errors/ErrorCodes.js';
import { SYSTEM_STATUS, LIFECYCLE_EVENTS, DEFAULT_CONFIG } from '../common/SystemConstants.js';
import { safeHandleError, createStandardHealthCheckResult } from '../common/ErrorUtils.js';

// Node.js built-in modules for discovery
import { readdir } from 'fs/promises'; // Removed 'stat' as it's not used in scanDirectory
import { join, dirname, basename } from 'path'; // For scanDirectory and loadConfig
import { existsSync } from 'fs'; // For loadConfig

export class ContainerSystem extends EventEmitter {
  static dependencies = ['config', 'errorSystem']; // For its own config and error handling
  static version = '2.0.0'; // Example version bump

  /**
   * Creates a new ContainerSystem instance.
   * @param {object} [deps={}] - Dependencies for the ContainerSystem.
   * @param {object} [deps.config={}] - Configuration object for the container itself.
   * @param {object} [deps.errorSystem] - The ErrorSystem instance for centralized error reporting.
   */
  constructor(deps = {}) {
    super();
    this.deps = {
      config: deps.config || {},
      errorSystem: deps.errorSystem, // errorSystem might be a component it manages
                                     // so internal errors might need careful handling if errorSystem isn't resolved yet.
                                     // Using console for very early errors is an option.
    };

    this.components = new Map();
    this.instances = new Map();
    this.dependencies = new Map();
    this.manifests = new Map();
    // this.initialized is now driven by this.state.status

    this.state = {
      status: SYSTEM_STATUS.CREATED,
      startTime: null,
      errors: [], // For internal errors of ContainerSystem
      metrics: new Map(),
      healthChecks: new Map(),
    };
    this.registerHealthCheck('container.state', this.checkSystemState.bind(this));
    this.registerHealthCheck('container.components', this.checkComponentStatus.bind(this));
  }

  /**
   * Handles internal operational errors of the ContainerSystem.
   * Logs the error to internal state and forwards to ErrorSystem if available.
   * @private
   * @param {Error} error - The error object.
   * @param {object} [context={}] - Additional context.
   */
  async _handleInternalError(error, context = {}) {
    // If error is already a ConfigError or ServiceError, use it as is.
    // Otherwise, wrap it in a ServiceError, indicating a general operational failure within the container.
    const errorToLog = (error instanceof ConfigError || error instanceof ServiceError)
      ? error
      : new ServiceError(
          ErrorCodes.SERVICE.OPERATION_FAILED, // Using unprefixed service code
          `Container internal operation failed: ${error.message}`,
          context,
          { cause: error }
        );

    this.state.errors.push({ error: errorToLog, timestamp: new Date().toISOString(), context });
    if (this.state.errors.length > (this.deps.config?.container?.maxErrorHistory || DEFAULT_CONFIG.MAX_ERROR_HISTORY)) {
      this.state.errors.shift();
    }
    this.recordMetric('container.errors.internal', 1, { errorName: errorToLog.name, errorCode: errorToLog.code });
    // Use safeHandleError, which will use console if errorSystem is not ready/available
    await safeHandleError(this.deps.errorSystem, errorToLog, { source: 'ContainerSystem', ...context });
  }

  /**
   * Register a component manifest.
   * @param {string} type - Component type.
   * @param {object} manifest - Component manifest.
   */
  registerManifest(type, manifest) {
    if (this.state.status === SYSTEM_STATUS.SHUTDOWN || this.state.status === SYSTEM_STATUS.SHUTTING_DOWN) {
        const err = new ConfigError(
            ErrorCodes.CONFIG.VALIDATION_FAILED, // Using unprefixed config code
            `Cannot register manifest on a shutdown container: ${type}`
        );
        this._handleInternalError(err, { type }); // Log, but rethrow as it's a programming error
        throw err;
    }
    if (this.manifests.has(type)) {
      throw new ConfigError( // This is an immediate operational error, throw directly
        ErrorCodes.CONFIG.DUPLICATE_MANIFEST, // Using unprefixed config code
        `Manifest already registered for type: ${type}`
      );
    }
    this.manifests.set(type, manifest);
    this.recordMetric('container.manifests.registered', 1, { type });
    this.emit('manifest:registered', { type, manifest });
  }

  /**
   * Register a component with the container.
   * @param {string} name - Component name.
   * @param {Function|object} Component - Component constructor, factory function, or instance.
   * @param {object} [options={}] - Registration options (e.g., singleton: true).
   * @returns {ContainerSystem} This instance for chaining.
   */
  register(name, Component, options = {}) {
    if (this.state.status === SYSTEM_STATUS.SHUTDOWN || this.state.status === SYSTEM_STATUS.SHUTTING_DOWN) {
        const err = new ConfigError(
            ErrorCodes.CONFIG.VALIDATION_FAILED, // Using unprefixed config code
            `Cannot register component on a shutdown container: ${name}`
        );
        this._handleInternalError(err, { name });
        throw err;
    }
    if (this.components.has(name)) {
      throw new ConfigError(
        ErrorCodes.CONFIG.DUPLICATE_COMPONENT, // Using unprefixed config code
        `Component ${name} is already registered`
      );
    }

    this.components.set(name, {
      Component,
      options: {
        singleton: true, // Default to singleton
        ...options,
      },
    });
    // Store dependencies if provided directly on the Component (static property)
    this.dependencies.set(name, Component.dependencies || []);

    this.recordMetric('container.components.registered', 1, { name });
    this.emit('component:registered', { name, Component });
    return this;
  }

  /**
   * Discover components in a directory.
   * @param {string} type - Component type (must match a registered manifest).
   * @param {string} basePath - Base directory path to scan.
   * @returns {Promise<Map<string, object>>} A map of discovered components.
   */
  async discover(type, basePath) {
    if (!this.manifests.has(type)) {
      throw new ConfigError(
        ErrorCodes.CONFIG.MANIFEST_TYPE_NOT_FOUND, // Using unprefixed config code
        `No manifest registered for type: ${type}`
      );
    }

    this.recordMetric('container.discovery.started', 1, { type, basePath });
    try {
      const manifest = this.manifests.get(type);
      const componentPaths = await this.scanDirectory(basePath);
      const discoveredComponents = new Map();

      for (const path of componentPaths) {
        try {
          const component = await this.loadComponent(path, manifest);
          if (component) {
            discoveredComponents.set(component.name, component);
          }
        } catch (error) {
          // Log individual component load errors but continue discovery
          const discoveryError = new ServiceError(
            ErrorCodes.SERVICE.COMPONENT_LOAD_FAILED, // Using unprefixed service code
            `Error loading component during discovery from ${path}`,
            { path, type, originalMessage: error.message },
            { cause: error }
          );
          await this._handleInternalError(discoveryError, { phase: 'discovery-load', path });
          this.emit('discovery:error', { path, error: discoveryError });
        }
      }

      this.emit('discovery:completed', { type, components: discoveredComponents });
      this.recordMetric('container.discovery.completed', 1, { type, count: discoveredComponents.size });
      return discoveredComponents;
    } catch (error) {
      const discoveryFailedError = new ServiceError(
        ErrorCodes.SERVICE.DISCOVERY_FAILED, // Using unprefixed service code
        `Failed to discover ${type} components from ${basePath}`,
        { type, basePath, originalMessage: error.message },
        { cause: error }
      );
      await this._handleInternalError(discoveryFailedError, { phase: 'discovery', type });
      this.recordMetric('container.discovery.failed', 1, { type });
      throw discoveryFailedError;
    }
  }

  /**
   * Load a component from a file path based on a manifest.
   * @private
   * @param {string} path - Path to the component file.
   * @param {object} manifest - The manifest for this component type.
   * @returns {Promise<object|null>} The loaded component or null if disabled/invalid.
   */
  async loadComponent(path, manifest) {
    try {
      const config = await this.loadConfig(path);
      if (config.enabled === false) return null;

      if (manifest.configSchema) {
        await this.validateConfig(config, manifest.configSchema);
      }
      const implementation = await this.loadImplementation(path);
      return {
        name: config.name,
        config,
        implementation,
      };
    } catch (error) {
      // Let discover method handle logging this error via _handleInternalError
      // This throw should be a ConfigError if loading/validation of config part failed,
      // or ServiceError if implementation load failed.
      // Since loadConfig and validateConfig throw ConfigError, and loadImplementation throws ServiceError,
      // we can check the type of error.
      if (error instanceof ConfigError) {
          throw error; // Re-throw original ConfigError
      }
      // If it's not a ConfigError from loadConfig/validateConfig, then it might be ServiceError from loadImplementation,
      // or a generic error. Wrap in ConfigError if it's related to the overall component structure/config.
      throw new ConfigError(
        ErrorCodes.CONFIG.LOAD_FAILED, // Using unprefixed config code
        `Failed to load component from ${path}`,
        { path, originalMessage: error.message },
        { cause: error }
      );
    }
  }

  /**
   * Get an instance of a component.
   * @param {string} name - Component name.
   * @param {Array<string>} [parentDepsStack=[]] - Used internally to detect circular dependencies.
   * @returns {Promise<any>} The resolved component instance.
   */
  async resolve(name, parentDepsStack = []) {
    if (!this.components.has(name)) {
      throw new ServiceError(
        ErrorCodes.SERVICE.UNKNOWN_COMPONENT, // Using unprefixed service code
        `Component ${name} is not registered.`
      );
    }

    if (parentDepsStack.includes(name)) {
        throw new ConfigError(
            ErrorCodes.CONFIG.CIRCULAR_DEPENDENCY, // Using unprefixed config code
            `Circular dependency detected: ${parentDepsStack.join(' -> ')} -> ${name}`
        );
    }

    const { Component, options } = this.components.get(name);

    if (options.singleton && this.instances.has(name)) {
      return this.instances.get(name);
    }

    const currentDepsStack = [...parentDepsStack, name];
    const componentDepsList = this.dependencies.get(name) || [];
    const resolvedDeps = {};

    for (const dep of componentDepsList) {
      if (!this.components.has(dep)) {
        throw new ConfigError(
            ErrorCodes.CONFIG.MISSING_DEPENDENCY, // Using unprefixed config code
            `Dependency '${dep}' required by '${name}' is not registered.`
        );
      }
      resolvedDeps[dep] = await this.resolve(dep, currentDepsStack);
    }

    let instance;
    if (typeof Component === 'function') {
      if (Component.prototype && typeof Component.prototype.constructor === 'function') {
        instance = new Component(resolvedDeps);
      } else { // Factory function
        instance = await Promise.resolve(Component(resolvedDeps));
      }
    } else { // Pre-resolved instance
      instance = Component;
    }

    if (this.state.status === SYSTEM_STATUS.RUNNING && typeof instance.initialize === 'function') {
      await instance.initialize();
    }

    if (options.singleton) {
      this.instances.set(name, instance);
    }

    this.recordMetric('container.components.resolved', 1, { name, singleton: !!options.singleton });
    this.emit('component:resolved', { name, instance });
    return instance;
  }

  /**
   * Initialize all registered components in dependency order.
   * @returns {Promise<void>}
   */
  async initialize() {
    if (this.state.status === SYSTEM_STATUS.RUNNING || this.state.status === SYSTEM_STATUS.INITIALIZING) {
      const err = new CoreError(ErrorCodes.CORE.ALREADY_INITIALIZED, 'ContainerSystem is already initialized or initializing.');
      await this._handleInternalError(err);
      return;
    }

    this.emit(LIFECYCLE_EVENTS.INITIALIZING, { system: 'ContainerSystem' });
    this.state.status = SYSTEM_STATUS.INITIALIZING;
    const initStartTime = Date.now();
    this.state.startTime = initStartTime;

    try {
      const order = this.resolveDependencyOrder();
      for (const name of order) {
        const instance = await this.resolve(name);
        // Initialize call during resolve handles already-initialized container state.
        // For main init loop, ensure it's called if not already (resolve might not call it if container not RUNNING yet).
        if (typeof instance.initialize === 'function') {
          // Add a check to prevent double initialization if instance tracks its own state
          // or if resolve now handles init more broadly. For now, assume initialize is safe to call if status isn't RUNNING.
          if (!instance.state || instance.state.status !== SYSTEM_STATUS.RUNNING) { // Basic check
             await instance.initialize();
          }
        }
      }

      this.state.status = SYSTEM_STATUS.RUNNING;
      const initTime = Date.now() - initStartTime;
      this.recordMetric('container.initialization.time', initTime);
      this.recordMetric('container.initialization.success', 1);
      this.emit(LIFECYCLE_EVENTS.INITIALIZED, { system: 'ContainerSystem', durationMs: initTime, timestamp: new Date().toISOString() });
      this.emit(LIFECYCLE_EVENTS.RUNNING, { system: 'ContainerSystem', timestamp: new Date().toISOString() });
    } catch (error) {
      this.state.status = SYSTEM_STATUS.ERROR;
      this.recordMetric('container.initialization.failure', 1, { error: error.code });
      await this._handleInternalError(error, { phase: 'initialization' });
      throw error instanceof ServiceError || error instanceof ConfigError ?
      error : new ServiceError( // Default wrapper
        ErrorCodes.SERVICE.OPERATION_FAILED, // Using unprefixed service code
        'ContainerSystem failed to initialize.',
        { originalMessage: error.message },
        { cause: error }
      );
    }
  }

  /**
   * Resolve dependency order for initialization using topological sort.
   * @private
   * @returns {Array<string>} Ordered list of component names.
   */
  resolveDependencyOrder() {
    const visited = new Set();
    const visiting = new Set();
    const order = [];

    const visit = (name) => {
      if (visited.has(name)) return;
      if (visiting.has(name)) {
        throw new ConfigError(
          ErrorCodes.CONFIG.CIRCULAR_DEPENDENCY, // Using unprefixed config code
          `Circular dependency detected involving: ${name}. Path: ${Array.from(visiting).join(' -> ')} -> ${name}`
        );
      }

      visiting.add(name);
      const componentDefinition = this.components.get(name);
      if (!componentDefinition) {
          visiting.delete(name);
          // This indicates a required dependency was not registered, which should be caught by 'resolve' or prior checks.
          // If it happens here, it means a component in this.dependencies was not in this.components.
          throw new ConfigError(
              ErrorCodes.CONFIG.MISSING_DEPENDENCY, // Using unprefixed config code
              `Component ${name} definition not found while resolving dependency order (is it registered?).`
          );
      }

      const deps = this.dependencies.get(name) || [];
      for (const dep of deps) {
        if (!this.components.has(dep)) {
          throw new ConfigError(
            ErrorCodes.CONFIG.MISSING_DEPENDENCY, // Using unprefixed config code
            `Dependency ${dep} required by ${name} is not registered.`
          );
        }
        visit(dep);
      }

      visiting.delete(name);
      visited.add(name);
      order.push(name);
    };

    const prioritizedOrder = this.deps.config?.container?.initOrder || [
      'errorSystem',
      'config',
      'eventBusSystem',
      'moduleSystem',
      'routerSystem'
    ];
    for (const name of prioritizedOrder) {
      if (this.components.has(name) && !visited.has(name)) {
        visit(name);
      }
    }

    for (const name of this.components.keys()) {
      if (!visited.has(name)) {
        visit(name);
      }
    }
    return order;
  }

  /**
   * Shut down all initialized components in reverse dependency order.
   * @returns {Promise<void>}
   */
  async shutdown() {
    if (this.state.status === SYSTEM_STATUS.SHUTDOWN || this.state.status === SYSTEM_STATUS.SHUTTING_DOWN) {
      return;
    }
    this.emit(LIFECYCLE_EVENTS.SHUTTING_DOWN, { system: 'ContainerSystem' });
    this.state.status = SYSTEM_STATUS.SHUTTING_DOWN;
    const shutdownStartTime = Date.now();
    try {
      const order = this.resolveDependencyOrder().reverse();

      for (const name of order) {
        const instance = this.instances.get(name);
        if (instance && typeof instance.shutdown === 'function') {
          try {
            await instance.shutdown();
          } catch (error) {
            const shutdownError = new ServiceError(
                ErrorCodes.SERVICE.OPERATION_FAILED, // Using unprefixed service code
                `Error shutting down component ${name}`,
                { component: name, originalMessage: error.message },
                { cause: error }
            );
            await this._handleInternalError(shutdownError, { phase: 'shutdown-component', component: name });
            this.emit('shutdown:error', { component: name, error: shutdownError });
            // Continue shutting down other components
          }
        }
      }

      this.instances.clear();
      this.state.status = SYSTEM_STATUS.SHUTDOWN;
      this.state.startTime = null;
      const shutdownTime = Date.now() - shutdownStartTime;
      this.recordMetric('container.shutdown.time', shutdownTime);
      this.recordMetric('container.shutdown.success', 1);
      this.emit(LIFECYCLE_EVENTS.SHUTDOWN, { system: 'ContainerSystem', durationMs: shutdownTime, timestamp: new Date().toISOString() });

    } catch (error) {
      this.state.status = SYSTEM_STATUS.ERROR;
      this.recordMetric('container.shutdown.failure', 1, { error: error.code });
      await this._handleInternalError(error, { phase: 'shutdown' });
      throw error instanceof ServiceError || error instanceof ConfigError ?
      error : new ServiceError( // Default wrapper
        ErrorCodes.SERVICE.OPERATION_FAILED, // Using unprefixed service code
        'ContainerSystem failed to shutdown.',
        { originalMessage: error.message },
        { cause: error }
      );
    }
  }

  // --- Discovery and Loading Methods ---

  /**
   * Scan a directory for component files.
   * @private
   */
  async scanDirectory(basePath) {
    try {
      const entries = await readdir(basePath, { withFileTypes: true });
      const files = [];

      for (const entry of entries) {
        const fullPath = join(basePath, entry.name);
        if (entry.isDirectory()) {
          files.push(...await this.scanDirectory(fullPath));
        } else if (entry.isFile() && (entry.name.endsWith('.js') || entry.name.endsWith('.mjs') || entry.name.endsWith('.cjs'))) {
          files.push(fullPath);
        }
      }
      return files;
    } catch (error) {
      throw new ServiceError(
        ErrorCodes.SERVICE.DIRECTORY_SCAN_FAILED, // Using unprefixed service code
        `Failed to scan directory: ${basePath}`,
        { basePath, originalMessage: error.message },
        { cause: error }
      );
    }
  }

  /**
   * Load component configuration from a file path or embedded in component.
   * @private
   */
  async loadConfig(path) {
    try {
      const dir = dirname(path);
      const filename = basename(path, '.js');
      const configPathJs = join(dir, `${filename}.config.js`);

      let actualConfigPath;
      if (existsSync(configPathJs)) actualConfigPath = configPathJs;

      if (actualConfigPath) {
        const configModule = await import(actualConfigPath);
        return configModule.default || configModule;
      }

      const componentModule = await import(path);
      if (componentModule.config) {
        return typeof componentModule.config === 'function'
          ? await Promise.resolve(componentModule.config())
          : componentModule.config;
      }

      return { name: filename, enabled: true }; // Default config
    } catch (error) {
      throw new ConfigError(
        ErrorCodes.CONFIG.LOAD_FAILED, // Using unprefixed config code
        `Failed to load configuration from/for ${path}`,
        { path, originalMessage: error.message },
        { cause: error }
      );
    }
  }

  /**
   * Validate component configuration against a schema.
   * @private
   */
  async validateConfig(config, schema) {
    if (!schema) return true;

    try {
      if (!config || typeof config !== 'object') {
        throw new ConfigError(ErrorCodes.CONFIG.INVALID_CONFIG_OBJECT, 'Configuration must be an object.'); // Using unprefixed
      }

      for (const [key, fieldSchema] of Object.entries(schema)) {
        if (fieldSchema.required && (config[key] === undefined || config[key] === null)) {
          throw new ConfigError(ErrorCodes.CONFIG.MISSING_REQUIRED_FIELD, `Required field '${key}' is missing.`, { field: key }); // Using unprefixed
        }
        if (config[key] === undefined) continue;

        if (fieldSchema.type && typeof config[key] !== fieldSchema.type) {
          throw new ConfigError(ErrorCodes.CONFIG.INVALID_FIELD_TYPE, `Field '${key}' expects type '${fieldSchema.type}', got '${typeof config[key]}'.`, { field: key, expected: fieldSchema.type, actual: typeof config[key] }); // Using unprefixed
        }
        if (fieldSchema.enum && !fieldSchema.enum.includes(config[key])) {
          throw new ConfigError(ErrorCodes.CONFIG.INVALID_ENUM_VALUE, `Field '${key}' value '${config[key]}' not in enum [${fieldSchema.enum.join(', ')}].`, { field: key, expected: fieldSchema.enum, actual: config[key] }); // Using unprefixed
        }
        if (fieldSchema.pattern && !new RegExp(fieldSchema.pattern).test(config[key])) {
          throw new ConfigError(ErrorCodes.CONFIG.PATTERN_MISMATCH, `Field '${key}' does not match pattern '${fieldSchema.pattern}'.`, { field: key, pattern: fieldSchema.pattern, value: config[key] }); // Using unprefixed
        }
      }

      if (typeof schema._validate === 'function') {
        await schema._validate(config);
      }
      return true;
    } catch (error) {
      if (error instanceof ConfigError) throw error;
      throw new ConfigError(
        ErrorCodes.CONFIG.VALIDATION_FAILED, // Using unprefixed config code
        'Configuration validation failed.',
        { config, schemaExcerpt: Object.keys(schema), originalMessage: error.message },
        { cause: error }
      );
    }
  }

  /**
   * Load component implementation from a file path.
   * @private
   */
  async loadImplementation(path) {
    try {
      const module = await import(path);
      const filename = basename(path, '.js');

      if (module.default) return module.default;
      if (module[filename]) return module[filename];

      for (const exportValue of Object.values(module)) {
        if (typeof exportValue === 'function') {
          if (exportValue.prototype || exportValue.name?.startsWith('create')) {
            return exportValue;
          }
        }
      }
      const exports = Object.values(module);
      if (exports.length === 1) return exports[0];

      return module; // Fallback to the whole module object
    } catch (error) {
      throw new ServiceError(
        ErrorCodes.SERVICE.IMPLEMENTATION_LOAD_FAILED, // Using unprefixed service code
        `Failed to load implementation from ${path}`,
        { path, originalMessage: error.message },
        { cause: error }
      );
    }
  }

  // --- State, Health, Metrics Methods ---
  recordMetric(name, value, tags = {}) {
    this.state.metrics.set(name, { value, timestamp: Date.now(), tags });
  }

  getMetrics() {
    const metrics = {};
    for (const [name, data] of this.state.metrics) {
      metrics[name] = data;
    }
    return metrics;
  }

  registerHealthCheck(name, checkFn) {
    if (typeof checkFn !== 'function') {
        const err = new ConfigError(
            ErrorCodes.CONFIG.VALIDATION_FAILED, // Using unprefixed config code
            `Health check '${name}' must be a function.`
        );
        this._handleInternalError(err); // Log, but rethrow as it's a programming error
        throw err;
    }
    this.state.healthChecks.set(name, checkFn);
  }

  async checkHealth() {
    const results = {};
    let overallStatus = SYSTEM_STATUS.HEALTHY;

    for (const [name, checkFn] of this.state.healthChecks) {
      try {
        const checkResult = await checkFn();
        results[name] = checkResult;
        if (checkResult.status !== SYSTEM_STATUS.HEALTHY) {
          overallStatus = (overallStatus === SYSTEM_STATUS.HEALTHY) ?
          SYSTEM_STATUS.DEGRADED : SYSTEM_STATUS.UNHEALTHY;
          if (checkResult.status === SYSTEM_STATUS.UNHEALTHY) overallStatus = SYSTEM_STATUS.UNHEALTHY;
        }
      } catch (error) {
        results[name] = createStandardHealthCheckResult(SYSTEM_STATUS.UNHEALTHY, { error: 'Health check threw an exception' }, [error]);
        overallStatus = SYSTEM_STATUS.UNHEALTHY;
      }
    }
    return {
      name: this.constructor.name,
      version: ContainerSystem.version,
      status: overallStatus,
      timestamp: new Date().toISOString(),
      uptime: this.state.startTime ? Date.now() - this.state.startTime : 0,
      errorCount: this.state.errors.length,
      checks: results,
    };
  }

  async checkSystemState() {
    return createStandardHealthCheckResult(
      this.state.status === SYSTEM_STATUS.RUNNING ? SYSTEM_STATUS.HEALTHY : (this.state.status === SYSTEM_STATUS.CREATED || this.state.status === SYSTEM_STATUS.INITIALIZING ? SYSTEM_STATUS.DEGRADED : SYSTEM_STATUS.UNHEALTHY ),
      {
        currentStatus: this.state.status,
        uptime: this.state.startTime ? Date.now() - this.state.startTime : 0,
        internalErrorCount: this.state.errors.length
      }
    );
  }

  async checkComponentStatus() {
    return createStandardHealthCheckResult(SYSTEM_STATUS.HEALTHY, {
      registeredComponentCount: this.components.size,
      resolvedInstanceCount: this.instances.size,
      manifestCount: this.manifests.size,
    });
  }

  getSystemStatus() {
    return {
        name: this.constructor.name,
        version: ContainerSystem.version,
        status: this.state.status,
        uptime: this.state.startTime ? Date.now() - this.state.startTime : 0,
        initialized: this.state.status === SYSTEM_STATUS.RUNNING,
        errorCount: this.state.errors.length,
        timestamp: new Date().toISOString()
    };
  }
}

/**
 * Factory function for creating a ContainerSystem instance.
 * @param {object} [deps={}] - Dependencies for the ContainerSystem.
 * @returns {ContainerSystem}
 */
export function createContainerSystem(deps = {}) {
  return new ContainerSystem(deps);
}


// src/core/container/container-system.md

# TSMIS ContainerSystem Documentation
Version: 2.1.0 (Refactored Core)

## Table of Contents

1.  [Introduction to the ContainerSystem](#1-introduction-to-the-containersystem)
    * [1.1. Purpose & Core Responsibilities](#11-purpose--core-responsibilities)
    * [1.2. Key Features](#12-key-features)
2.  [Core Concepts](#2-core-concepts)
    * [2.1. Dependency Injection (DI) & Inversion of Control (IoC)](#21-dependency-injection-di--inversion-of-control-ioc)
    * [2.2. Components (Definition and Types)](#22-components-definition-and-types)
    * [2.3. Manifests & Component Discovery](#23-manifests--component-discovery)
    * [2.4. Dependency Resolution & Order](#24-dependency-resolution--order)
    * [2.5. Singleton Scope](#25-singleton-scope)
3.  [API Reference (`ContainerSystem`)](#3-api-reference-containersystem)
    * [3.1. Constructor](#31-constructor)
    * [3.2. Component Registration Methods](#32-component-registration-methods)
        * [3.2.1. `register(name, Component, options)`](#321-registername-component-options)
        * [3.2.2. `registerManifest(type, manifest)`](#322-registermanifesttype-manifest)
    * [3.3. Component Discovery Methods](#33-component-discovery-methods)
        * [3.3.1. `async discover(type, basePath)`](#331-async-discovertype-basepath)
    * [3.4. Component Resolution Methods](#34-component-resolution-methods)
        * [3.4.1. `async resolve(name)`](#341-async-resolvename)
    * [3.5. Lifecycle Methods](#35-lifecycle-methods)
        * [3.5.1. `async initialize()`](#351-async-initialize)
        * [3.5.2. `async shutdown()`](#352-async-shutdown)
    * [3.6. Internal Utility Methods (Conceptual Overview)](#36-internal-utility-methods-conceptual-overview)
        * [`resolveDependencyOrder()`](#resolvedependencyorder)
        * [`loadComponent(path, manifest)`](#loadcomponentpath-manifest)
        * [`scanDirectory(basePath)`](#scandirectorybasepath)
        * [`loadConfig(path)`](#loadconfigpath)
        * [`validateConfig(config, schema)`](#validateconfigconfig-schema)
        * [`loadImplementation(path)`](#loadimplementationpath)
    * [3.7. Static Factory (`createContainerSystem`)](#37-static-factory-createcontainersystem)
4.  [State Management (`ContainerSystem` Specifics)](#4-state-management-containersystem-specifics)
5.  [Lifecycle Management (`ContainerSystem` Specifics)](#5-lifecycle-management-containersystem-specifics)
    * [5.1. `initialize()` Process Flow](#51-initialize-process-flow)
    * [5.2. `shutdown()` Process Flow](#52-shutdown-process-flow)
6.  [Error Handling within `ContainerSystem`](#6-error-handling-within-containersystem)
7.  [Event Integration (`ContainerSystem` Specifics)](#7-event-integration-containersystem-specifics)
8.  [Health Monitoring (`ContainerSystem` Specifics)](#8-health-monitoring-containersystem-specifics)
9.  [Metrics Tracking (`ContainerSystem` Specifics)](#9-metrics-tracking-containersystem-specifics)
10. [Integrations (ContainerSystem Level)](#10-integrations-containersystem-level)
11. [Usage Examples & Best Practices](#11-usage-examples--best-practices)
    * [11.1. Basic Registration and Resolution](#111-basic-registration-and-resolution)
    * [11.2. Registering Different Component Types (Class, Factory, Instance)](#112-registering-different-component-types-class-factory-instance)
    * [11.3. Defining Component Dependencies](#113-defining-component-dependencies)
    * [11.4. Using Manifests and Discovery](#114-using-manifests-and-discovery)
    * [11.5. Application Bootstrap Sequence](#115-application-bootstrap-sequence)
    * [11.6. Handling Circular Dependencies (Detection)](#116-handling-circular-dependencies-detection)
12. [Testing Strategy Notes (`ContainerSystem`)](#12-testing-strategy-notes-containersystem)
13. [Future Considerations & Potential Enhancements](#13-future-considerations--potential-enhancements)

---

## 1. Introduction to the ContainerSystem

### 1.1. Purpose & Core Responsibilities
The `ContainerSystem` is the heart of the TSMIS application's startup and runtime component management. It is a sophisticated Dependency Injection (DI) and Inversion of Control (IoC) container. Its primary responsibilities are:

* **Managing Component Lifecycles**: Orchestrating the creation, initialization, and eventual shutdown of registered application components (including other core systems, services, and business modules)[cite: 372].
* **Dependency Injection**: Automatically resolving and injecting declared dependencies into components when they are created or resolved[cite: 373].
* **Centralized Registry**: Acting as a central place where all major shared components of the application are registered and can be retrieved[cite: 374].
* **Facilitating Loose Coupling**: By managing dependencies, it allows components to be developed and tested more independently[cite: 375].
* **Component Discovery**: Optionally discovering and loading components from the filesystem based on predefined manifests[cite: 376].
It ensures that the application is assembled correctly, dependencies are met, and components are started and stopped in a predictable and orderly fashion[cite: 377].

### 1.2. Key Features
* **Flexible Component Registration**: Supports registration of components as classes, factory functions, or pre-resolved instances[cite: 378].
* **Automatic Dependency Resolution**: Analyzes `static dependencies` arrays on components to build a dependency graph and inject required instances[cite: 379].
* **Ordered Initialization & Shutdown**: Initializes components in a topologically sorted order respecting their dependencies, and shuts them down in reverse order[cite: 380].
* **Singleton Scope Management**: Primarily manages components as singletons, caching and reusing instances by default[cite: 381].
* **Manifest-Based Discovery**: Can scan directories for components, loading and validating them based on registered manifests[cite: 382].
* **Circular Dependency Detection**: Identifies and reports circular dependencies during the resolution or initialization phase, preventing an unstable application state[cite: 383].
* **Event Emission**: Emits various events related to its operations (e.g., `component:registered`, `initialized`) allowing other parts of the system to react[cite: 384].
* **Standardized Core Features**: Adheres to the TSMIS core standardization pillars for state management, error handling, lifecycle, health monitoring, and metrics[cite: 385].

---
## 2. Core Concepts

### 2.1. Dependency Injection (DI) & Inversion of Control (IoC)
* **IoC**: The `ContainerSystem` inverts the control of object creation and management. Instead of components creating their own dependencies, the container creates and provides them[cite: 387].
* **DI**: Components declare their dependencies (typically via a `static dependencies` array listing the names of other registered components). The container then "injects" instances of these dependencies into the component when it's created.

### 2.2. Components (Definition and Types)
A "component" in the context of `ContainerSystem` is any piece of functionality that the container manages. This can be:
* **Classes**: JavaScript classes whose instances will be managed[cite: 392].
* **Factory Functions**: Functions that return a component instance[cite: 393].
* **Instances**: Pre-existing objects registered directly.

### 2.3. Manifests & Component Discovery
* **Manifests**: A manifest (registered via `registerManifest`) defines a "type" of component and can include metadata like a configuration schema (`configSchema`) for validation.
* **Discovery**: The `discover(type, basePath)` method automatically finds and prepares components from a directory structure.

### 2.4. Dependency Resolution & Order
* The container builds a dependency graph and uses a topological sort (`resolveDependencyOrder`) based on `static dependencies` to determine initialization order.
* Shutdown occurs in reverse order[cite: 402].
* Circular dependencies are detected, leading to a `ConfigError`[cite: 403].

### 2.5. Singleton Scope
By default, components are treated as **singletons**. The container creates one instance, caches it, and reuses it for subsequent resolutions. Transient behavior (non-singleton) is a potential enhancement.

---
## 3. API Reference (`ContainerSystem`)

### 3.1. Constructor
**`new ContainerSystem(deps = {})`**
* **`deps`**: `object` (optional)
    * `deps.config`: `object` (optional) - Configuration for `ContainerSystem` operations[cite: 410].
    * `deps.errorSystem`: `ErrorSystem` (optional) - For reporting internal errors[cite: 411].

### 3.2. Component Registration Methods

#### 3.2.1. `register(name: string, Component: Function | object, options = {}): ContainerSystem`
Registers a component (class, factory, or instance).
* **`options.singleton`**: `boolean` (default: `true`)[cite: 415].
* **Returns**: `ContainerSystem` instance[cite: 416].
* **Throws**: `ConfigError` for duplicates or if called on a shutdown container[cite: 416].
* **Emits**: `component:registered` event[cite: 417].

#### 3.2.2. `registerManifest(type: string, manifest: object): void`
Registers a component manifest for discovery[cite: 417].
* **`type`**: `string` - Unique name for the component type[cite: 418].
* **`manifest`**: `object` - Manifest data (e.g., `configSchema`)[cite: 418].
* **Throws**: `ConfigError` for duplicates or if called on a shutdown container[cite: 419].
* **Emits**: `manifest:registered` event[cite: 419].

### 3.3. Component Discovery Methods

#### 3.3.1. `async discover(type: string, basePath: string): Promise<Map<string, object>>`
Discovers components based on a manifest type[cite: 420].
* **Returns**: `Promise` resolving to a `Map` of discovered components[cite: 421].
* **Throws**: `ConfigError` if manifest type not found; `ServiceError` for general discovery failure[cite: 422].
* **Emits**: `discovery:error`, `discovery:completed`[cite: 423].

### 3.4. Component Resolution Methods

#### 3.4.1. `async resolve(name: string): Promise<any>`
Resolves and returns a component instance by name[cite: 424].
* **Returns**: `Promise<any>` - The resolved component instance[cite: 425].
* **Throws**: `ServiceError` if not registered; `ConfigError` for dependency issues.
* **Emits**: `component:resolved` event[cite: 426].

### 3.5. Lifecycle Methods

#### 3.5.1. `async initialize(): Promise<void>`
Initializes all registered singleton components in dependency order[cite: 427].
* **Throws**: `ServiceError` or `ConfigError` on failure[cite: 428].
* **Emits**: `system:initializing`, `system:initialized`, `system:running`[cite: 428].

#### 3.5.2. `async shutdown(): Promise<void>`
Shuts down all initialized singleton components in reverse dependency order[cite: 429].
* **Throws**: `ServiceError` on failure[cite: 430].
* **Emits**: `system:shutting_down`, `system:shutdown`, `shutdown:error`[cite: 430].

### 3.6. Internal Utility Methods (Conceptual Overview)
These private methods support the public API[cite: 431]:
* **`resolveDependencyOrder(): string[]`**: Determines component initialization order[cite: 431].
* **`async loadComponent(path, manifest): Promise<object|null>`**: Loads a single component's config and implementation[cite: 432].
* **`async scanDirectory(basePath): Promise<string[]>`**: Finds potential component files[cite: 433].
* **`async loadConfig(path): Promise<object>`**: Loads configuration for a component.
* **`async validateConfig(config, schema): Promise<boolean>`**: Validates loaded config against a schema.
* **`async loadImplementation(path): Promise<Function|Class|Object>`**: Imports the JavaScript module.

### 3.7. Static Factory (`createContainerSystem`)
**`createContainerSystem(deps = {}): ContainerSystem`**
A factory function for creating `ContainerSystem` instances[cite: 442].

---
## 4. State Management (`ContainerSystem` Specifics)

The `ContainerSystem` adheres to the standard `this.state` object pattern[cite: 443]:

**`ContainerSystem`: Standard 'this.state' Object Structure**
```javascript
// this.state = {
//   status: SYSTEM_STATUS.CREATED,
//   startTime: null,
//   errors: [], // Stores { error: CoreError, timestamp: string, context: object } for ContainerSystem's internal errors
//   metrics: new Map(),
//   healthChecks: new Map()
// };
```
* `status`: Current lifecycle status (from `SystemConstants.SYSTEM_STATUS`)[cite: 444].
* `startTime`: Timestamp of initialization start/completion[cite: 445].
* `errors`: Array storing internal operational errors of `ContainerSystem`[cite: 445].
* `metrics`: Map for storing operational metrics[cite: 445].
* `healthChecks`: Map for storing health check functions[cite: 446].

Key internal data structures (not part of `this.state`):
* **`this.components: Map<string, { Component: Function | object, options: object }>`**: Stores registered component definitions[cite: 447].
* **`this.instances: Map<string, any>`**: Cache for resolved singleton instances[cite: 448].
* **`this.dependencies: Map<string, Array<string>>`**: Stores declared dependency names for each component[cite: 449].
* **`this.manifests: Map<string, object>`**: Stores registered component manifests[cite: 450].

---
## 5. Lifecycle Management (`ContainerSystem` Specifics)

The `ContainerSystem` orchestrates its own lifecycle and that of managed components, adhering to standard methods and event emissions.

### 5.1. `initialize()` Process Flow
1.  Checks if already initialized; logs error and may return or throw `ServiceError` if so[cite: 453].
2.  Sets `state.status` to `INITIALIZING`, records `startTime`, emits `LIFECYCLE_EVENTS.INITIALIZING`[cite: 454].
3.  Calls `resolveDependencyOrder()` to determine initialization sequence and detect circular dependencies.
4.  Iterates through ordered components:
    * Calls `await this.resolve(componentName)` for instance and dependencies[cite: 457].
    * If instance has `initialize()` and container not yet `RUNNING`, calls `instance.initialize()`[cite: 458].
5.  On success:
    * Sets `state.status` to `RUNNING`[cite: 459].
    * Records success metrics[cite: 460].
    * Emits `LIFECYCLE_EVENTS.INITIALIZED` and `LIFECYCLE_EVENTS.RUNNING`[cite: 460].
6.  On error:
    * Sets `state.status` to `ERROR`[cite: 461].
    * Records failure metric[cite: 462].
    * Error processed by `_handleInternalError`[cite: 462].
    * `ServiceError` or `ConfigError` thrown[cite: 463].

### 5.2. `shutdown()` Process Flow
1.  Checks if already shutdown; returns if so[cite: 464].
2.  Sets `state.status` to `SHUTTING_DOWN`, emits `LIFECYCLE_EVENTS.SHUTTING_DOWN`[cite: 464].
3.  Calculates reverse dependency order[cite: 465].
4.  Iterates through reverse-ordered components:
    * Retrieves cached instance[cite: 466].
    * If instance exists and has `shutdown()`, calls it[cite: 466].
    * Errors from component `shutdown()` are caught, `shutdown:error` emitted, logged via `_handleInternalError`, but do not stop other shutdowns[cite: 467].
5.  Clears `this.instances`[cite: 468].
6.  On completion:
    * Sets `state.status` to `SHUTDOWN`, clears `startTime`[cite: 469].
    * Records success metrics[cite: 470].
    * Emits `LIFECYCLE_EVENTS.SHUTDOWN`[cite: 470].
7.  If `resolveDependencyOrder` fails during shutdown:
    * Sets `state.status` to `ERROR`[cite: 471].
    * Records failure metric, error processed by `_handleInternalError`, `ServiceError` thrown[cite: 472].

---
## 6. Error Handling within `ContainerSystem`

* **Internal Errors**: `ContainerSystem` uses a private `async _handleInternalError(error, context)` method for its own operational errors (e.g., individual component load failures during discovery, individual component shutdown failures). This method:
    1.  Ensures the error is a `ConfigError` or `ServiceError` (wrapping if necessary). For example, a generic internal failure might be wrapped as `new ServiceError(ErrorCodes.SERVICE.OPERATION_FAILED, 'Container internal operation failed: ' + error.message, context, { cause: error })` using an unprefixed specific code from `ErrorCodes.SERVICE`.
    2.  Logs the error to `this.state.errors`[cite: 476].
    3.  Records an `container.errors.internal` metric[cite: 476].
    4.  Uses `safeHandleError(this.deps.errorSystem, error, { source: 'ContainerSystem', ...context })` to report to `ErrorSystem`[cite: 477].
* **Directly Thrown Errors**: For issues immediately invalidating an operation (e.g., duplicate component, unknown component, circular dependencies), `ContainerSystem` throws `ConfigError` or `ServiceError` instances directly[cite: 478]. These errors use specific, unprefixed codes from `ErrorCodes.CONFIG` or `ErrorCodes.SERVICE` (e.g., `new ConfigError(ErrorCodes.CONFIG.DUPLICATE_COMPONENT, ...)` or `new ServiceError(ErrorCodes.SERVICE.UNKNOWN_COMPONENT, ...)`), and their constructors handle prefixing to form the final `error.code`. Examples:
    * `ConfigError` codes: `DUPLICATE_COMPONENT`, `DUPLICATE_MANIFEST`, `MISSING_DEPENDENCY`, `CIRCULAR_DEPENDENCY`, `MANIFEST_TYPE_NOT_FOUND`, `LOAD_FAILED`, `VALIDATION_FAILED`.
    * `ServiceError` codes: `UNKNOWN_COMPONENT`, `OPERATION_FAILED` (used for `ALREADY_INITIALIZED`, `INITIALIZATION_FAILED`, `SHUTDOWN_FAILED` wrappers), `DISCOVERY_FAILED`, `IMPLEMENTATION_LOAD_FAILED`, `COMPONENT_LOAD_FAILED`.

---
## 7. Event Integration (`ContainerSystem` Specifics)
`ContainerSystem` is an `EventEmitter` and emits several operational events[cite: 481]:
* **`manifest:registered`**: Payload: `{ type: string, manifest: object }`[cite: 482].
* **`component:registered`**: Payload: `{ name: string, Component: Function | object }`[cite: 483].
* **`discovery:error`**: Payload: `{ path: string, error: ServiceError }`[cite: 484].
* **`discovery:completed`**: Payload: `{ type: string, components: Map<string, object> }`[cite: 485].
* **`component:resolved`**: Payload: `{ name: string, instance: any }`[cite: 486].
* **`shutdown:error`**: Payload: `{ component: string, error: ServiceError }`[cite: 487].
It also emits standard system lifecycle events for itself (e.g., `system:initializing`)[cite: 487].

---
## 8. Health Monitoring (`ContainerSystem` Specifics)
Implements `checkHealth()` aggregating results from its registered health checks[cite: 488].
* **Default Health Checks Registered**[cite: 489]:
    * **`container.state`**: Reports `status`, `uptime`, internal `errorCount`[cite: 489].
    * **`container.components`**: Reports `registeredComponentCount`, `resolvedInstanceCount`, `manifestCount`[cite: 490].
* **Output Format**: Uses `createStandardHealthCheckResult` for sub-checks[cite: 490].

**`ContainerSystem`: Example checkHealth() Output**
```json
// {
//   "name": "ContainerSystem",
//   "version": "2.0.0",
//   "status": "healthy", // Could be "degraded" or "unhealthy" based on checks
//   "timestamp": "2025-05-19T05:18:00.123Z", // Example ISO timestamp
//   "uptime": 3600000, // Example uptime in milliseconds (e.g., 1 hour)
//   "errorCount": 0,    // Number of errors in this.state.errors
//   "checks": {
//     "container.state": {
//       "status": "healthy",
//       "detail": {
//         "currentStatus": "running",
//         "uptime": 3600000,
//         "internalErrorCount": 0
//       },
//       "errors": []
//     },
//     "container.components": {
//       "status": "healthy",
//       "detail": {
//         "registeredComponentCount": 15,
//         "resolvedInstanceCount": 12,
//         "manifestCount": 3
//       },
//       "errors": []
//     }
//     // ... any other custom health checks registered with ContainerSystem ...
//   }
// }
```

---
## 9. Metrics Tracking (`ContainerSystem` Specifics)
Implements `recordMetric()` and `getMetrics()`[cite: 493]. Key metrics automatically recorded:
* **Lifecycle**: `container.initialization.success/failure`, `container.initialization.time`, `container.shutdown.success/failure`, `container.shutdown.time`.
* **Internal Errors**: `container.errors.internal` (Tags: `errorName`, `errorCode`).
* **Operational Counts**: `container.manifests.registered`, `container.components.registered`, `container.components.resolved`, `container.discovery.started`, `container.discovery.completed`, `container.discovery.failed`.

---
## 10. Integrations (ContainerSystem Level)
* **`ErrorSystem`**: Reports internal errors to `deps.errorSystem` via `safeHandleError`[cite: 498].
* **Configuration (`deps.config`)**: Uses for its own settings (e.g., `initOrder`, `maxErrorHistory`).
* **Application Components**: Registers, resolves dependencies, injects them, and manages their lifecycle.
* **Node.js Filesystem (`fs/promises`, `path`, `fs`)**: Used internally for discovery.
* **`EventBusSystem` (Indirectly)**: Emits events consumable by other systems.

---
## 11. Usage Examples & Best Practices
(Sections 11.1 to 11.6's code examples should be reviewed to ensure any error instantiations within them follow the new error code prefixing strategy: specialized error types take unprefixed specific codes from `ErrorCodes.js`, and `CoreError` used directly takes fully prefixed codes. For example, if a `ConfigError` is thrown, it should be `new ConfigError(ErrorCodes.CONFIG.SOME_CODE, ...)` where `ErrorCodes.CONFIG.SOME_CODE` is the unprefixed specific string.)

### 11.1. Basic Registration and Resolution
**ContainerSystem**: Basic Component Registration and Resolution
```javascript
// Assuming ContainerSystem and createContainerSystem are imported
// import { createContainerSystem } from './core/container/ContainerSystem.js'; // Adjust path
// import { ErrorCodes } from './core/errors/ErrorCodes.js'; // For example errors
// import { ServiceError } from './core/errors/index.js'; // For example errors

// // 1. Create a ContainerSystem instance
// const container = createContainerSystem({
//   // Optional dependencies for the container itself
//   // config: { container: { maxErrorHistory: 50 } },
//   // errorSystem: myErrorSystemInstance // if ErrorSystem is already created
// });

// // 2. Define a simple component (class)
// class SimpleLogger {
//   constructor(deps) { // deps will be an empty object if no dependencies declared
//     this.prefix = '[Logger]';
//     console.log('SimpleLogger instance created.');
//   }

//   log(message) {
//     console.log(`${this.prefix} ${message}`);
//   }

//   async initialize() {
//     console.log('SimpleLogger initialized.');
//   }

//   async shutdown() {
//     console.log('SimpleLogger shutdown.');
//   }
// }

// // 3. Register the component with the container
// container.register('logger', SimpleLogger);
// // 'logger' is the name used to resolve this component.
// // By default, it's registered as a singleton.

// // 4. Initialize the container (and all registered components)
// async function startApp() {
//   try {
//     await container.initialize(); // Calls SimpleLogger.initialize()
//     console.log('ContainerSystem initialized.');

//     // 5. Resolve the component instance
//     const loggerInstance = await container.resolve('logger');
//     loggerInstance.log('Hello from the resolved logger!');

//     // Subsequent resolves for a singleton return the same instance
//     const anotherLoggerInstance = await container.resolve('logger');
//     console.log('Are logger instances the same?', loggerInstance === anotherLoggerInstance); // true

//     // 6. Shutdown the container
//     await container.shutdown(); // Calls SimpleLogger.shutdown()
//     console.log('ContainerSystem shutdown complete.');
//   } catch (error) {
//     console.error('Application error:', error);
//     // In a real app, ensure errorSystem handles this if container init/shutdown fails
//     // For example, if initialization failed:
//     // if (error.code === `SERVICE_${ErrorCodes.SERVICE.OPERATION_FAILED}`) { /* ... */ }
//   }
// }

// // startApp();
```

### 11.2. Registering Different Component Types (Class, Factory, Instance)
(Conceptual, focusing on factory functions)
**ContainerSystem**: Registering Components with Factory Functions
```javascript
// Assuming ContainerSystem, createContainerSystem are imported
// import { createContainerSystem } from './core/container/ContainerSystem.js';
// Assume LoggerService is defined and registered as 'logger' (as in previous example)

// // --- Example 1: Synchronous Factory Function ---
// function createSimpleConfigService(dependencies) {
//   // dependencies.logger would be injected if 'logger' was in SimpleConfigService.dependencies
//   const logger = dependencies.logger || console; // Fallback if logger not a formal dependency
//   logger.log('[SimpleConfigService Factory] Creating SimpleConfigService instance.');
//   return {
//     appName: 'TSMIS App (via Sync Factory)',
//     getAppName: function() { return this.appName; },
//     async initialize() { logger.log('[SimpleConfigService] Initialized (Sync Factory).'); },
//     async shutdown() { logger.log('[SimpleConfigService] Shutdown (Sync Factory).'); }
//   };
// }
// // If the factory needs dependencies from the container:
// // createSimpleConfigService.dependencies = ['logger'];

// // --- Example 2: Asynchronous Factory Function ---
// async function createAsyncDatabaseService(dependencies) {
//   const logger = dependencies.logger; // Assuming 'logger' is a declared dependency
//   logger.log('[AsyncDatabaseService Factory] Starting to create AsyncDatabaseService instance...');
//   // Simulate async operation, e.g., connecting to a database
//   await new Promise(resolve => setTimeout(resolve, 50)); // Simulate delay

//   const dbInstance = {
//     connectionString: 'mydb://localhost/prod_db_async',
//     query: async function(sql) {
//       logger.log(`[AsyncDatabaseService] Executing query: ${sql}`);
//       return [{ id: 1, data: 'async_result' }];
//     },
//     async initialize() { logger.log('[AsyncDatabaseService] Initialized.'); },
//     async shutdown() { logger.log('[AsyncDatabaseService] Shutdown.'); }
//   };
//   logger.log('[AsyncDatabaseService Factory] AsyncDatabaseService instance created.');
//   return dbInstance;
// }
// // Declare dependencies for the factory function itself
// createAsyncDatabaseService.dependencies = ['logger'];


// // --- Registration and Usage ---
// async function appWithFactories() {
//   const container = createContainerSystem();

//   // Register LoggerService (as a class or another factory)
//   class LoggerService { 
//     log(m){console.log(m);} 
//     async initialize(){console.log('LoggerService Init');} 
//     async shutdown(){console.log('LoggerService Shutdown');}
//   }
//   container.register('logger', LoggerService);

//   // Register components using their factory functions
//   container.register('configService', createSimpleConfigService);
//   container.register('dbService', createAsyncDatabaseService);

//   try {
//     await container.initialize(); // Initializes logger, then configService, dbService
//     console.log('ContainerSystem with factories initialized.');

//     const config = await container.resolve('configService');
//     console.log('App Name from ConfigService:', config.getAppName());

//     const db = await container.resolve('dbService');
//     const results = await db.query('SELECT * FROM users');
//     console.log('DB Query Results:', results);

//     await container.shutdown();
//     console.log('ContainerSystem with factories shutdown complete.');
//   } catch (error) {
//     console.error('Application error with factories:', error);
//   }
// }

// // appWithFactories();
```

### 11.3. Defining Component Dependencies
**ContainerSystem**: Defining and Resolving Component Dependencies
```javascript
// Assuming ContainerSystem and createContainerSystem are imported
// import { createContainerSystem } from './core/container/ContainerSystem.js';

// // 1. Define a LoggerService component
// class LoggerService {
//   log(message) { console.log(`[LoggerService] ${message}`); }
//   async initialize() { console.log('LoggerService initialized.'); }
//   async shutdown() { console.log('LoggerService shutdown.'); }
// }

// // 2. Define a UserService that depends on LoggerService
// class UserService {
//   static dependencies = ['logger']; // Declare 'logger' as a dependency

//   constructor(dependencies) {
//     // The container injects an object where 'logger' is the resolved LoggerService instance
//     this.logger = dependencies.logger;
//     if (!this.logger) {
//       throw new Error("Logger dependency was not injected into UserService!");
//     }
//     console.log('UserService instance created, logger injected.');
//   }

//   async initialize() {
//     this.logger.log('UserService initializing...');
//     console.log('UserService initialized.');
//   }

//   createUser(name) {
//     this.logger.log(`Creating user: ${name}`);
//     return { id: Date.now(), name };
//   }

//   async shutdown() {
//     this.logger.log('UserService shutting down...');
//     console.log('UserService shutdown.');
//   }
// }

// // 3. Create the container and register components
// const container = createContainerSystem();
// container.register('logger', LoggerService);
// container.register('userService', UserService); // ContainerSystem reads UserService.dependencies

// // 4. Initialize and use
// async function appWithDependencies() {
//   try {
//     await container.initialize(); // Initializes logger, then userService
//     console.log('ContainerSystem with dependencies initialized.');

//     const userServiceInstance = await container.resolve('userService');
//     const user = userServiceInstance.createUser('Alice');
//     console.log('User created:', user);

//     await container.shutdown(); // Shuts down userService, then logger
//     console.log('ContainerSystem with dependencies shutdown complete.');
//   } catch (error) {
//     console.error('Application error:', error);
//   }
// }

// // appWithDependencies();
```

### 11.4. Using Manifests and Discovery
**ContainerSystem**: Using Manifests and Component Discovery
```javascript
// Assuming ContainerSystem, createContainerSystem, ErrorCodes, ConfigError are imported
// import { createContainerSystem } from './core/container/ContainerSystem.js';
// import { ErrorCodes } from './core/errors/ErrorCodes.js';
// import { ConfigError, ServiceError } // from './core/errors/index.js';

// // Assume the following directory structure and files for discovery:
// // src_example/
// // └── modules/
// //     └── reporting/
// //         ├── ReportGeneratorService.js
// //         ├── ReportGeneratorService.config.js
// //         └── DataAggregatorService.js (with embedded config)

// // --- File: src_example/modules/reporting/ReportGeneratorService.config.js ---
// // export default {
// //   name: 'reportGenerator',
// //   enabled: true,
// //   outputFormat: 'pdf',
// //   schedule: 'daily'
// // };

// // --- File: src_example/modules/reporting/ReportGeneratorService.js ---
// // export default class ReportGeneratorService {
// //   constructor(deps) { this.config = deps.config.moduleConfig; this.logger = deps.logger; }
// //   static dependencies = ['logger']; // Assuming logger is registered
// //   async initialize() { this.logger.log(`ReportGeneratorService (${this.config.name}) initialized. Format: ${this.config.outputFormat}`); }
// //   generate() { this.logger.log(`Generating ${this.config.outputFormat} report on schedule: ${this.config.schedule}`); }
// // }

// // --- File: src_example/modules/reporting/DataAggregatorService.js ---
// // export const config = { name: 'dataAggregator', enabled: true, source: 'realtimeDB' };
// // export default class DataAggregatorService {
// //   constructor(deps) { this.config = deps.config.moduleConfig; this.logger = deps.logger; }
// //   static dependencies = ['logger'];
// //   async initialize() { this.logger.log(`DataAggregatorService (${this.config.name}) initialized. Source: ${this.config.source}`); }
// //   aggregate() { this.logger.log('Aggregating data...'); }
// // }


// --- Application Setup ---
// async function appWithDiscovery() {
//   const container = createContainerSystem();
//   class Logger { log(m){console.log(m);} async initialize(){console.log('Logger for Discovery Init');} }
//   container.register('logger', Logger);

//   // 1. Register a manifest for 'service' components
//   container.registerManifest('service', {
//     configSchema: {
//       name: { type: 'string', required: true },
//       enabled: { type: 'boolean', default: true },
//       outputFormat: { type: 'string', enum: ['pdf', 'csv', 'html'] },
//       schedule: { type: 'string' },
//       source: { type: 'string' }
//     }
//   });
//   console.log("Manifest 'service' registered.");

//   let discoveredServices;
//   try {
//     // IMPORTANT: This path is illustrative. Node.js dynamic import() needs valid paths.
//     // For a real test, create these files and adjust the path.
//     const discoveryPath = './src_example/modules/reporting'; 
//     console.log(`Attempting to discover services in: ${discoveryPath}`);
//     // Mock 'fs/promises' and 'path' for environments where real fs isn't available or for unit tests.
//     // This example assumes a Node.js environment where these files exist.
//     discoveredServices = await container.discover('service', discoveryPath);
//     console.log(`Discovered ${discoveredServices.size} services.`);
//   } catch (error) {
//     console.error('Discovery process failed:', error);
//     // Example of how the error might be thrown by 'discover'
//     // if (error.code === `SERVICE_${ErrorCodes.SERVICE.DISCOVERY_FAILED}`) { /* ... */ }
//     // if (error.code === `CONFIG_${ErrorCodes.CONFIG.MANIFEST_TYPE_NOT_FOUND}`) { /* ... */ }
//     await container.shutdown();
//     return;
//   }

//   // 3. Register discovered components
//   if (discoveredServices && discoveredServices.size > 0) {
//     for (const [name, componentDef] of discoveredServices.entries()) {
//       if (componentDef.config.enabled !== false) {
//         console.log(`Registering discovered component: ${name} from path ${componentDef.path}`); // Assuming path is part of componentDef
//         container.register(
//           name, // Name from componentDef.name (from config or filename)
//           componentDef.implementation, // The loaded class/factory
//           // Pass loaded config to the component instance via options,
//           // so constructor(deps) receives it as deps.config.moduleConfig
//           // This requires the component to expect `deps.config.moduleConfig`.
//           // A more common pattern is for ModuleSystem to handle this for CoreModules.
//           // For generic components in ContainerSystem, this is one way.
//           { moduleConfig: componentDef.config } 
//         );
//       } else {
//         console.log(`Skipping registration of disabled component: ${name}`);
//       }
//     }
//   } else {
//     console.log('No services discovered or all were disabled.');
//   }

//   try {
//     await container.initialize();
//     console.log('Container initialized with discovered services.');

//     if (container.components.has('reportGenerator')) {
//       const reportService = await container.resolve('reportGenerator');
//       reportService.generate();
//     }
//     if (container.components.has('dataAggregator')) {
//       const dataService = await container.resolve('dataAggregator');
//       dataService.aggregate();
//     }
//   } catch (error) {
//     console.error('Error during initialization or usage of discovered services:', error);
//   } finally {
//     await container.shutdown();
//     console.log('Container shutdown after discovery example.');
//   }
// }

// // appWithDiscovery();
// // Note: To run this, create the example file structure and content, e.g., in 'src_example/modules/reporting'
```

### 11.5. Application Bootstrap Sequence
**ContainerSystem***: Example Application Bootstrap Sequence
```javascript
// src/app.js (Conceptual Bootstrap File)
// import { createContainerSystem } from './core/container/ContainerSystem.js';
// import { createErrorSystem, ErrorCodes, CoreError } from './core/errors/index.js';
// import { createEventBusSystem } from './core/event/EventBusSystem.js';
// import { createModuleSystem, InventoryModule } from './core/module/index.js'; // Assuming InventoryModule is a CoreModule derivative
// import { createRouterSystem, FastifyAdapter } from './core/router/index.js';
// import { createInventoryService } from './modules/inventory/InventoryService.js'; // Example service
// import Fastify from 'fastify';

// async function bootstrapApplication() {
//   let container;
//   try {
//     console.log('[Bootstrap] Starting application bootstrap...');
//     container = createContainerSystem({
//       config: {
//         container: {
//           initOrder: ['appConfig', 'logger', 'errorSystem', 'eventBusSystem', 'moduleSystem', 'routerSystem'],
//           maxErrorHistory: 20,
//         }
//       }
//     });
//     console.log('[Bootstrap] ContainerSystem created.');

//     // Register Foundational App Config & Logger
//     container.register('appConfig', () => ({ 
//       appName: 'TSMIS Core App', port: 3000, environment: 'development',
//       inventory: { lowStockThreshold: 10 }, // Config for InventoryModule
//       inventoryService: { allowNegativeStock: false } // Config for InventoryService
//     }));
//     container.register('logger', () => console);

//     // Register Core Systems
//     container.register('errorSystem', createErrorSystem);
//     container.register('eventBusSystem', createEventBusSystem);
//     container.register('moduleSystem', createModuleSystem);
//     container.register('routerSystem', createRouterSystem);
//     console.log('[Bootstrap] Core systems registered.');

//     // Register Application-Specific Services
//     container.register('inventoryService', createInventoryService);
//     console.log('[Bootstrap] Application services registered.');

//     // Pre-initialize core systems that ModuleSystem or others might need ready
//     // This step depends on how inter-system dependencies are handled vs. container.initialize()
//     // For this example, let's assume container.initialize() handles their init in order.

//     // Register Business Modules with ModuleSystem
//     const moduleSystem = await container.resolve('moduleSystem'); // Resolve early to register modules
//     const appConfigForModules = await container.resolve('appConfig');
//     // Assuming InventoryModule is defined somewhere
//     // class InventoryModule extends CoreModule { /* ... */ } 
//     // await moduleSystem.register('inventory', InventoryModule, appConfigForModules.inventory);
//     console.log('[Bootstrap] Business modules registered with ModuleSystem.');

//     await container.initialize(); // Initialize all components in dependency order
//     console.log('[Bootstrap] ContainerSystem and all components initialized successfully.');

//     // Setup HTTP Server (example with Fastify)
//     const routerSystem = await container.resolve('routerSystem');
//     const appConfig = await container.resolve('appConfig');
//     const errorSystem = await container.resolve('errorSystem'); // For Fastify error handler

//     const fastifyApp = Fastify({ logger: { level: 'info' } });
//     // Example: Setup Fastify error handling integration (assuming ErrorSystem has a method or one is set up)
//     // errorSystem.setupFrameworkIntegration(fastifyApp, 'fastify'); // Conceptual

//     routerSystem.registerAdapter('fastify', new FastifyAdapter({ logger: fastifyApp.log }));
//     await routerSystem.applyRoutes(fastifyApp, 'fastify');
//     console.log('[Bootstrap] Routes applied to Fastify.');

//     await fastifyApp.listen({ port: appConfig.port });
//     console.log(`[Bootstrap] Server listening on port ${appConfig.port}.`);
//     return { container, fastifyApp };

//   } catch (error) {
//     console.error('[Bootstrap] CRITICAL BOOTSTRAP FAILURE:', 
//                   error.message, 
//                   error.code, // This will be the prefixed code
//                   error.details, 
//                   error.stack);
//     // Example: Check for specific error code (prefixed)
//     // if (error.code === `SERVICE_${ErrorCodes.SERVICE.OPERATION_FAILED}` && error.cause?.code === ErrorCodes.CORE.INITIALIZATION_FAILED) {
//     //    console.error("This was a core initialization failure wrapped in a service error by the container.");
//     // }
//     const logger = container?.instances?.get('logger') || console;
//     const errorSystem = container?.instances?.get('errorSystem');
//     if (errorSystem?.handleError) {
//       await errorSystem.handleError(error, { phase: 'bootstrap', criticality: 'high' }).catch(e => console.error("Error handling the bootstrap error:", e));
//     } else if (logger) {
//       logger.error("CRITICAL BOOTSTRAP FAILURE (ErrorSystem unavailable):", error);
//     }
//     if (container && container.state.status !== SYSTEM_STATUS.SHUTDOWN) {
//       try { await container.shutdown(); } catch (shutdownError) { /* ... */ }
//     }
//     process.exit(1);
//   }
// }
// // bootstrapApplication();
```

### 11.6. Handling Circular Dependencies (Detection)
`ContainerSystem` detects circular dependencies during `resolveDependencyOrder()` and `resolve()`, throwing a `ConfigError` with code `ErrorCodes.CONFIG.CIRCULAR_DEPENDENCY`.

* **Best Practices**:
    * Single `ContainerSystem` instance.
    * Register core systems first.
    * Declare dependencies explicitly via `static dependencies`.
    * Use factory functions for complex instantiation.
    * Implement `async initialize()` and `async shutdown()` in components.
    * Prefer dependency injection over manual resolution.
    * Pass configuration appropriately.
    * Leverage manifests for pluggable components.

---
## 12. Testing Strategy Notes (`ContainerSystem`)
* **Registration**: Test `register()` with various component types, options, `registerManifest()`. Test `ConfigError` for duplicates[cite: 681].
* **Resolution**: Test instance creation, dependency injection, singleton behavior, nested dependencies. Test `ServiceError` and `ConfigError` for resolution issues.
* **Dependency Order & Circularity**: Test `resolveDependencyOrder()`. Test `ConfigError` for circular dependencies.
* **Lifecycle Management**: Mock components with `initialize()`/`shutdown()`. Verify correct order and error handling during component init/shutdown.
* **Discovery**: Mock filesystem. Test various file structures, valid/invalid configs, `enabled: false`. Test `validateConfig`, `loadImplementation`. Verify event emissions.
* **State, Health, Metrics**: Ensure `this.state` updates correctly. Test `checkHealth()` and metric recording.
* **Event Emission**: Verify operational and lifecycle events are emitted correctly[cite: 697].

---
## 13. Future Considerations & Potential Enhancements
(Adapted from original documentation)
* **Scoped/Child Containers**: For more granular dependency management.
* **Advanced Component Discovery**: Dynamic reloading, sophisticated file watching, component versioning.
* **Lazy Initialization**: Option for components to initialize on first resolution.
* **Dependency Graph Visualization**: Tooling to visualize component dependencies.
* **Asynchronous Registration**: Allowing `register()` to accept a Promise[cite: 706].
* **Enhanced Configuration Injection**: More direct/typed configuration injection[cite: 707].
* **Full Transient Component Support**: Not caching instances if `options.singleton` is `false`.


// src/core/container/index.js

/**
 * @file src/core/container/index.js
 * @description Barrel file for exporting the ContainerSystem and its factory.
 */

import { ContainerSystem, createContainerSystem } from './ContainerSystem.js';

export {
  ContainerSystem,
  createContainerSystem,
};

// Optional default export if preferred for commonJS-style imports or specific bundling strategies
// export default {
//   ContainerSystem,
//   createContainerSystem,
// };


// src/core/core-architecture.md

# TSMIS Core Architecture Guide
Version: 2.1.0 (Refactored Core)

## Table of Contents

1.  [Introduction to the TSMIS Core Architecture](#1-introduction-to-the-tsmis-core-architecture)
    * [1.1. Purpose of this Guide](#11-purpose-of-this-guide)
    * [1.2. What is TSMIS? (System Overview)](#12-what-is-tsmis-system-overview)
    * [1.3. Goals of the Core Architecture](#13-goals-of-the-core-architecture)
    * [1.4. Key Architectural Principles Driving TSMIS](#14-key-architectural-principles-driving-tsmis)
2.  [Naming Conventions](#2-naming-conventions)
    * [2.1. File Naming](#21-file-naming)
    * [2.2. Class & Constructor Naming](#22-class--constructor-naming)
    * [2.3. Method & Function Naming](#23-method--function-naming)
    * [2.4. Variable Naming](#24-variable-naming)
    * [2.5. Constant Naming](#25-constant-naming)
    * [2.6. Event Naming](#26-event-naming)
    * [2.7. Error Code Naming](#27-error-code-naming)
    * [2.8. Metric Naming](#28-metric-naming)
    * [2.9. Configuration Key Naming](#29-configuration-key-naming)
3.  [Core Foundational Pillars](#3-core-foundational-pillars)
    * [3.1. Standard `this.state` Object](#31-standard-thisstate-object)
    * [3.2. Standardized Error Handling Framework](#32-standardized-error-handling-framework)
    * [3.3. Standardized Lifecycle Management](#33-standardized-lifecycle-management)
    * [3.4. Standardized Health Monitoring](#34-standardized-health-monitoring)
    * [3.5. Standardized Metrics Tracking](#35-standardized-metrics-tracking)
    * [3.6. Standardized Factory Functions](#36-standardized-factory-functions)
    * [3.7. Shared Utilities Overview](#37-shared-utilities-overview)
4.  [Overview of Core Systems](#4-overview-of-core-systems)
    * [4.1. The Core Systems Landscape](#41-the-core-systems-landscape)
    * [4.2. Holistic System Interaction Diagram](#42-holistic-system-interaction-diagram)
5.  [Deep Dive into Core Systems (Summaries)](#5-deep-dive-into-core-systems-summaries)
    * [5.1. `ContainerSystem`](#51-containersystem)
        * [5.1.1. Primary Responsibility](#511-primary-responsibility)
        * [5.1.2. Key Functionalities & API Summary](#512-key-functionalities--api-summary)
        * [5.1.3. Adherence to Standardization Pillars](#513-adherence-to-standardization-pillars)
        * [5.1.4. Key Integrations](#514-key-integrations)
    * [5.2. `ErrorSystem` & `CoreError`](#52-errorsystem--coreerror)
        * [5.2.1. Primary Responsibility](#521-primary-responsibility)
        * [5.2.2. Key Functionalities & API Summary](#522-key-functionalities--api-summary)
        * [5.2.3. Adherence to Standardization Pillars](#523-adherence-to-standardization-pillars)
        * [5.2.4. Key Integrations](#524-key-integrations)
    * [5.3. `EventBusSystem` & `CoreEventBus`](#53-eventbussystem--coreeventbus)
        * [5.3.1. Primary Responsibility](#531-primary-responsibility)
        * [5.3.2. Key Functionalities & API Summary](#532-key-functionalities--api-summary)
        * [5.3.3. Adherence to Standardization Pillars](#533-adherence-to-standardization-pillars)
        * [5.3.4. Key Integrations](#534-key-integrations)
    * [5.4. `ModuleSystem` & `CoreModule`](#54-modulesystem--coremodule)
        * [5.4.1. Primary Responsibility](#541-primary-responsibility)
        * [5.4.2. Key Functionalities & API Summary](#542-key-functionalities--api-summary)
        * [5.4.3. Adherence to Standardization Pillars](#543-adherence-to-standardization-pillars)
        * [5.4.4. Key Integrations](#544-key-integrations)
    * [5.5. `RouterSystem` & `CoreRouter` & `RoutableModule`](#55-routersystem--corerouter--routablemodule)
        * [5.5.1. Primary Responsibility](#551-primary-responsibility)
        * [5.5.2. Key Functionalities & API Summary](#552-key-functionalities--api-summary)
        * [5.5.3. Adherence to Standardization Pillars](#553-adherence-to-standardization-pillars)
        * [5.5.4. Key Integrations](#554-key-integrations)
6.  [Key System Workflows (with Visuals)](#6-key-system-workflows-with-visuals)
    * [6.1. Application Startup & Initialization Sequence](#61-application-startup--initialization-sequence)
    * [6.2. Typical HTTP API Request Flow](#62-typical-http-api-request-flow)
    * [6.3. Event Propagation within the System](#63-event-propagation-within-the-system)
    * [6.4. Centralized Error Reporting in Action](#64-centralized-error-reporting-in-action)
    * [6.5. Conceptual Health & Metrics Aggregation Flow](#65-conceptual-health--metrics-aggregation-flow)
7.  [Developing Business Modules: A Practical Guide](#7-developing-business-modules-a-practical-guide)
    * [7.1. Guiding Principles for Module Design](#71-guiding-principles-for-module-design)
    * [7.2. Extending `CoreModule` or `RoutableModule`](#72-extending-coremodule-or-routablemodule)
    * [7.3. Example Module: `InventoryModule`](#73-example-module-inventorymodule)
        * [7.3.1. Recommended Directory Structure](#731-recommended-directory-structure)
        * [7.3.2. Defining Routes and Handlers (within the RoutableModule)](#732-defining-routes-and-handlers-within-the-routablemodule)
        * [7.3.3. Defining Module-Specific Errors (`inventory.errors.js`)](#733-defining-module-specific-errors-inventoryerrorsjs)
        * [7.3.4. Defining Module-Specific Events (`inventory.events.js`)](#734-defining-module-specific-events-inventoryeventsjs)
        * [7.3.5. Implementing the Business Logic Service (`InventoryService.js`)](#735-implementing-the-business-logic-service-inventoryservicejs)
        * [7.3.6. Defining API Schemas (`schemas/addItem.schema.js`)](#736-defining-api-schemas-schemasadditemschemajs)
        * [7.3.7. Implementing the Main Module Class (`InventoryModule.js`)](#737-implementing-the-main-module-class-inventorymodulejs)
    * [7.4. Registering the Module & Its Services with the Core](#74-registering-the-module--its-services-with-the-core)
    * [7.5. Module-specific Configuration Details](#75-module-specific-configuration-details)
    * [7.6. Unit Testing Modules (Using Jest)](#76-unit-testing-modules-using-jest)
8.  [Shared Utilities Reference](#8-shared-utilities-reference)
    * [8.1. `SystemConstants.js`](#81-systemconstantsjs)
        * [8.1.1. Purpose & Key Definitions](#811-purpose--key-definitions)
        * [8.1.2. Usage Example](#812-usage-example)
    * [8.2. `ErrorUtils.js`](#82-errorutilsjs)
        * [8.2.1. Purpose & Key Functions](#821-purpose--key-functions)
        * [8.2.2. Usage Examples](#822-usage-examples)
9.  [Conclusion & Future Directions](#9-conclusion--future-directions)
    * [9.1. Summary of Achievements](#91-summary-of-achievements)
    * [9.2. Reinforcing the Standardization Pillars](#92-reinforcing-the-standardization-pillars)
    * [9.3. Future Directions & Potential Enhancements](#93-future-directions--potential-enhancements)

---

## 1. Introduction to the TSMIS Core Architecture

### 1.1. Purpose of this Guide
This document serves as the definitive technical guide and "source of truth" for the refactored core architecture of the Toro_SM Information System (TSMIS). It outlines the design, functionalities, naming conventions, and interaction patterns of the core foundational systems. Its goal is to ensure consistency in development, improve maintainability, and provide a clear understanding of how the system is built and operates, especially for junior to mid-level programmers. This guide synthesizes the principles applied during the core refactoring process and should be used by all developers working on or integrating with the TSMIS core systems and business modules. While more exhaustive, standalone documentation files may exist for each individual core system class, this document focuses on providing clear summaries, the overarching architecture, cross-component standards, and their interplay.

### 1.2. What is TSMIS? (System Overview)
The Toro_SM Information System (TSMIS) is an enterprise-level application built on Node.js, designed to be modular, scalable, and maintainable. It supports a variety of business functionalities through a collection of:
* **Core Infrastructure Systems**: These provide fundamental services like dependency management, error handling, event communication, module orchestration, and request routing.
* **Specialized Business Modules**: These encapsulate specific business domain logic and functionalities, building upon the services provided by the core systems.
The architecture is built with a strong emphasis on clear separation of concerns. This allows different parts of the system to be developed, tested, and potentially deployed with a degree of independence, fostering agility and reducing the complexity of managing a large application.

### 1.3. Goals of the Core Architecture
The refactored core architecture of TSMIS was undertaken with several key goals in mind:
* **Uniformity & Consistency**: Establish consistent patterns across core components and for module development.
* **Enhanced Observability**: Build in comprehensive monitoring for health, metrics, and status.
* **Improved Maintainability**: Make the codebase clearer, better organized, and easier to understand, debug, and extend.
* **Increased Testability**: Design components for effective unit and integration testing.
* **Greater Robustness**: Implement comprehensive and consistent error handling.
* **Effective Decoupling**: Promote loose coupling via Dependency Injection (DI) and an Event-Driven Architecture (EDA).
* **Better Developer Experience**: Provide clear guidelines, reusable base classes, and a predictable framework.
* **Dynamic Development**: Support capabilities like dynamic route updates to improve the development workflow by minimizing restarts.

### 1.4. Key Architectural Principles Driving TSMIS
The TSMIS core architecture is guided by several fundamental software engineering principles:
* **Modularity & Separation of Concerns (SoC)**.
* **Dependency Injection (DI)**.
* **Event-Driven Architecture (EDA)**.
* **Standardization Pillars** (state, errors, lifecycle, health, metrics).
* **Centralized Configuration**.
* **Layered Design**.
* **Clear Naming Conventions**.
* **Observability by Design**.

---
## 2. Naming Conventions
To ensure consistency, readability, and maintainability across the TSMIS codebase, the following naming conventions should be adhered to.

### 2.1. File Naming
* **JavaScript Class Files**: `PascalCase.js` (e.g., `ContainerSystem.js`).
* **JavaScript Utility/Helper Files**: `camelCase.js` or `PascalCase.js` (if primarily exporting a class).
* **JavaScript Configuration Files**: `camelCase.config.js` or `kebab-case.config.js`.
* **Interface Definitions (JS Classes used as Interfaces)**: `IPascalCase.js` (e.g., `IRouterAdapter.js`).
* **Test Files**: `PascalCase.test.js` or `camelCase.test.js`.
* **Markdown Documentation Files**: `kebab-case.md` or `snake_case.md` (e.g., `container-system.md`). *Note: `utilities_and_definitions.md` should be renamed to `utilities-and-definitions.md` for consistency.*
* **Directory Names**: `camelCase` or `kebab-case`.

### 2.2. Class & Constructor Naming
* **Classes**: `PascalCase` (e.g., `CoreModule`).
* **Interfaces (JS Classes used as Interfaces)**: `IPascalCase` (e.g., `IRouterAdapter`).
* **Abstract Classes (Conceptual)**: `PascalCase` (e.g., `CoreModule`).

### 2.3. Method & Function Naming
* **Public Methods/Functions**: `camelCase` (e.g., `initialize`).
* **Private/Internal Methods/Functions (by convention)**: `_camelCase` (e.g., `_handleInternalError`).
* **Factory Functions**: `createPascalCaseEntity` or `createCamelCaseUtility` (e.g., `createContainerSystem`).

### 2.4. Variable Naming
* **Local Variables & Parameters**: `camelCase`.
* **Instance Properties**: `camelCase`.
* **Private/Internal Instance Properties (by convention)**: `_camelCase`.
* **Boolean Variables/Properties**: Often prefixed with `is`, `has`, `should`, `can`.

### 2.5. Constant Naming
* **General Constants**: `UPPER_SNAKE_CASE` (e.g., `MAX_RETRIES`).
* **Exported Constant Objects/Namespaces**: `PascalCase` for the main object, `UPPER_SNAKE_CASE` for keys.
    * Example: `SystemConstants.SYSTEM_STATUS.RUNNING`.
    * Example: `ErrorCodes.CORE.UNKNOWN_ERROR` or `ErrorCodes.VALIDATION.INVALID_INPUT`.

### 2.6. Event Naming
* **Format**: `domain.entity.action` (business events), `system:scope:action` (core system events).
* **Tense**: Past tense for facts (e.g., `user.created`).

### 2.7. Error Code Naming
* **Format in `ErrorCodes.js`**: Keys are `UPPER_SNAKE_CASE`.
    * For the generic `CORE` domain, string values are typically fully prefixed (e.g., `ErrorCodes.CORE.INTERNAL_ERROR` has value `'CORE_INTERNAL_ERROR'`).
    * For other specific domains (e.g., `VALIDATION`, `MODULE`), string values are the **unprefixed specific part** of the code (e.g., `ErrorCodes.VALIDATION.INVALID_INPUT` now has value `'INVALID_INPUT'`).
* **Structure in `ErrorCodes.js`**: Grouped by domain (e.g., `ErrorCodes.CORE`, `ErrorCodes.VALIDATION`).
* **`error.code` Property**: On an instantiated `CoreError` subclass (e.g., `ValidationError`), the `code` property will be a fully prefixed string (e.g., `VALIDATION_INVALID_INPUT`). The subclass constructor is responsible for prepending its domain prefix to the unprefixed specific code it receives from `ErrorCodes.js`.

### 2.8. Metric Naming
* **Format**: `domain_or_component.object_or_feature.specific_action_or_state` (lowercase, dot-separated).
* **Tags**: `camelCase` for tag keys.

### 2.9. Configuration Key Naming
* **Format**: `camelCase` for keys in JavaScript config objects. External sources should be normalized to `camelCase`.

Adherence to these conventions is crucial for code consistency and maintainability.

---
## 3. Core Foundational Pillars
The TSMIS core architecture is built upon several standardization pillars.

### 3.1. Standard `this.state` Object
Core systems (`ContainerSystem`, `ErrorSystem`, etc.) and base classes (`CoreModule`) maintain a standardized internal `state` object.
{{CODE_BLOCK_CORE_SYSTEM_STANDARD_STATE_STRUCTURE_UPDATED}}
```javascript

```
* **Key Properties**: `status` (from `SystemConstants.SYSTEM_STATUS`), `startTime`, `errors` (array of internal operational errors), `metrics` (Map), `healthChecks` (Map).

### 3.2. Standardized Error Handling Framework
A unified approach to error handling:
* **`CoreError` Hierarchy**: All application errors extend `CoreError` or its subclasses.
* **`ErrorCodes.js`**: Central registry of error codes. Domain-specific codes are stored as unprefixed specific parts (e.g., `ErrorCodes.VALIDATION.INVALID_INPUT` is `'INVALID_INPUT'`); `CoreError` subclasses (e.g., `ValidationError`) prepend their domain prefix. `CORE` domain codes are typically stored fully prefixed.
* **`ErrorSystem`**: Central service for processing reported errors.
* **`safeHandleError` Utility**: Shared utility for reliable error reporting to `ErrorSystem`.
* **Error Handling Methods**: Core components use methods like `_handleInternalError` or `handleError`.

### 3.3. Standardized Lifecycle Management
Core systems and modules share a consistent lifecycle:
* **Core Methods**: `async initialize(deps)`, `async shutdown()`.
* **State Transitions**: `this.state.status` uses `SystemConstants.SYSTEM_STATUS`.
* **Lifecycle Events**: Standardized events from `SystemConstants.LIFECYCLE_EVENTS` (e.g., `system:initializing`) are emitted.
* **Idempotency**: `initialize()` and `shutdown()` are generally idempotent.

### 3.4. Standardized Health Monitoring
Components are designed for health observability:
* **`registerHealthCheck(name, checkFn)`**: Method to add health check functions.
* **`async checkHealth()`**: Executes checks, returns aggregated standard health report.
* **`createStandardHealthCheckResult(status, detail, errors)`**: Shared utility for formatting individual check outputs.
* **Default Health Checks**: Each component provides a default check for its own `state.status`.

### 3.5. Standardized Metrics Tracking
For performance and operational insights:
* **`recordMetric(name, value, tags)`**: Method to record metrics to `this.state.metrics`.
* **`getMetrics()`**: Retrieves all metrics.
* **Standard Metrics**: Core components record key metrics automatically.

### 3.6. Standardized Factory Functions
Each primary core system and base module class has an exported factory: `create[ComponentName](deps = {})`.

### 3.7. Shared Utilities Overview
Key utilities in `src/core/common/`:
* **`SystemConstants.js`**: `SYSTEM_STATUS`, `LIFECYCLE_EVENTS`, `DEFAULT_CONFIG`.
* **`ErrorUtils.js`**: `safeHandleError()`, `createStandardHealthCheckResult()`.

These pillars ensure consistent, robust, and observable core systems.

---
## 4. Overview of Core Systems
TSMIS architecture has specialized core systems for foundational services.

### 4.1. The Core Systems Landscape
* **`ContainerSystem`**: DI/IoC container for component registration, dependency resolution, lifecycle orchestration.
* **`ErrorSystem`**: Centralizes error handling, processing, custom handlers, framework integration. Uses `CoreError` and `ErrorCodes.js`.
* **`EventBusSystem`**: Manages `CoreEventBus` for asynchronous, event-driven communication.
* **`ModuleSystem`**: Orchestrates business logic modules (`CoreModule` extensions), managing their lifecycle, dependencies, and aggregated health.
* **`RouterSystem`**: Manages `CoreRouter` for HTTP route definition, web framework integration via adapters, middleware, and dynamic route updates.
These systems work together, often managed by `ContainerSystem`.

### 4.2. Holistic System Interaction Diagram
This diagram illustrates primary relationships and dependencies between core systems and their interaction with business modules and the external environment.
**Holistic Core System Interactions**
```mermaid
graph TD
    A[Web Framework (e.g., Fastify)] <--> RS[RouterSystem]
    RS -- Manages --> CR[CoreRouter]
    CR -- Listens for route events via --> EBS[EventBusSystem]
    
    subgraph ApplicationCore [Core Infrastructure & Orchestration]
        CS[ContainerSystem - DI & Lifecycle]
        ES[ErrorSystem - Error Handling]
        EBS[EventBusSystem - Eventing Engine]
        MS[ModuleSystem - Module Orchestration]
        RS[RouterSystem - Request Routing]
    end

    subgraph BusinessLogic [Business Logic & Services]
        BMs["Business Modules (CoreModule/RoutableModule)"]
        AppServices[Application Services (Non-Module)]
    end

    CS -- "Initializes & Injects Dependencies into" --> ES
    CS -- "Initializes & Injects Dependencies into" --> EBS
    CS -- "Initializes & Injects Dependencies into" --> MS
    CS -- "Initializes & Injects Dependencies into" --> RS
    CS -- "Initializes & Injects Dependencies into" --> AppServices

    MS -- "Registers & Manages Lifecycle of" --> BMs
    MS -- "Injects (ErrorSys, EventBusSys, Config, ContainerSys, Resolved Services/Modules) into" --> BMs

    BMs -- "Define routes, emit to" --> EBS
    BMs -- "Emit/Subscribe to business events via" --> EBS
    BMs -- "Report errors to" --> ES
    BMs -- "Use (injected)" --> AppServices
    BMs -- "Can use (injected) ContainerSystem for dynamic service resolution" --> CS

    AppServices -- "Report errors to" --> ES
    AppServices -- "May use" --> EBS

    ES -- "Used by All" --> ApplicationCore
    ES -- "Used by All" --> BusinessLogic
    
    RS -- "Applies routes (from CoreRouter) to" --> A
    CR -- "Stores routes defined by Events from" --> BMs

    EBS -- Manages --> CEB[CoreEventBus]

    classDef core fill:#D6EAF8,stroke:#5DADE2,stroke-width:2px;
    classDef app fill:#E8F8F5,stroke:#76D7C4,stroke-width:2px;
    class CS, ES, EBS, MS, RS, CR, CEB core;
    class BMs, AppServices app;
```

**Key Interaction Paths**:
* **Bootstrap**: `ContainerSystem` inits core systems; `ModuleSystem` inits modules. `RouterSystem` applies routes.
* **HTTP Request**: Web Framework -> `RouterSystem` -> `RoutableModule` Handler -> Services -> Response. Errors through `ErrorSystem`.
* **Event Communication**: Module A -> `EventBusSystem` -> Module B.
* **Error Reporting**: Any Component -> `ErrorSystem`.
* **Dependency Provision**: `ContainerSystem` -> All other Systems/Modules/Services.

---
## 5. Deep Dive into Core Systems (Summaries)
Summary overviews of each core system. For full details, refer to individual system documentation.

### 5.1. `ContainerSystem`

#### 5.1.1. Primary Responsibility
Application's DI/IoC container. Manages component registration, dependency resolution, and lifecycle orchestration.

#### 5.1.2. Key Functionalities & API Summary
* **Registration**: `register(name, Component, options)`, `registerManifest(type, manifest)`.
* **Resolution**: `async resolve(name)` – provides dependency-injected instances (singletons by default).
* **Discovery**: `async discover(type, basePath)` – loads components from filesystem.
* **Lifecycle**: `async initialize()`, `async shutdown()`.
* **Dependency Logic**: Uses `static dependencies`; `resolveDependencyOrder()` for sequencing and circular dependency detection.

#### 5.1.3. Adherence to Standardization Pillars
* **State**: Standard `this.state`; manages maps for `components`, `instances`, `dependencies`, `manifests`.
* **Errors**: `_handleInternalError` reports to `ErrorSystem`. Throws `ConfigError` or `ServiceError` (using unprefixed specific codes from `ErrorCodes.js`) for operational/setup issues.
* **Lifecycle**: Standard `initialize`/`shutdown`; emits lifecycle and operational events.
* **Health**: Default checks `container.state`, `container.components`.
* **Metrics**: For registrations, resolutions, discovery, lifecycle, errors.
* **Factory**: `createContainerSystem(deps = {})`.

#### 5.1.4. Key Integrations
* **`ErrorSystem`**: Reports its internal errors.
* **Configuration (`deps.config`)**: For its own settings.
* **Application Components**: Instantiates, configures, injects dependencies, manages lifecycle of all other registered core systems, services, and (via `ModuleSystem`) business modules. It is the source for `ModuleSystem` to get instances of non-module services that modules depend on.
* **`EventBusSystem` (Indirectly)**: Emits operational events.

**`ContainerSystem`:** Key Operational Flows Summary
```mermaid
graph TD
    subgraph ContainerSystem_Operations
        direction LR
        Register["register(name, Comp)"]
        Resolve["resolve(name)"]
        Initialize["initialize()"]
        Discover["discover(type, path)"]
    end

    subgraph ContainerSystem_Internal_State
        ComponentsMap["Components Registry"]
        InstancesCache["Singleton Instances Cache"]
        DependencyGraph["Dependency Graph"]
        ManifestsStore["Manifests Store"]
    end

    Register --> ComponentsMap;
    Register --> DependencyGraph;
    
    Resolve -- Reads --> ComponentsMap;
    Resolve -- Reads/Writes --> InstancesCache;
    Resolve -- Uses --> DependencyGraph;
    Resolve --> InstantiatedComponent["Instantiated Component"];
    
    Initialize -- Uses --> DependencyGraph;
    Initialize -- Calls --> Resolve;
    Initialize -- Calls --> ComponentInit["component.initialize()"];
    
    Discover -- Uses --> ManifestsStore;
    Discover -- Scans --> FileSystem["File System"];
    Discover -- Loads & Validates --> DiscoveredComponents["Discovered Component Definitions"];
    
    classDef op fill:#c9daf8,stroke:#333,stroke-width:1px;
    classDef state fill:#e6f2ff,stroke:#333,stroke-width:1px;
    class Register,Resolve,Initialize,Discover op;
    class ComponentsMap,InstancesCache,DependencyGraph,ManifestsStore state;
```

### 5.2. `ErrorSystem` & `CoreError`

#### 5.2.1. Primary Responsibility
Centralizes error handling. Processes reported errors, manages custom handlers, integrates with frameworks for HTTP error responses. Relies on `CoreError` and `ErrorCodes.js`.

#### 5.2.2. Key Functionalities & API Summary
* **`CoreError`**: Base class with `code` (prefixed on instance), `message`, `details`, `timestamp`, `cause`, `toJSON()`, `static fromJSON()`.
* **`ErrorCodes.js`**: Centralized codes. Domain-specific codes are unprefixed values (e.g., `'INVALID_INPUT'` from `ErrorCodes.VALIDATION.INVALID_INPUT`); `CoreError` subclasses add prefixes. `CORE` domain codes are fully prefixed.
* **`ErrorSystem`**:
    * `async handleError(error, context)`: Main entry point.
    * `registerHandler(errorTypeName, handler)`: For custom logic.
    * `async registerIntegration(name, IntegrationClass, frameworkInstance, options)`: For framework error handling.
    * `createError(typeName, code, ...)`: Factory for `CoreError` instances. Expects an *unprefixed specific code* for `code` when `typeName` is a specialized subclass.

#### 5.2.3. Adherence to Standardization Pillars
* **State**: Standard `this.state`; manages `errorTypes`, `customHandlers`, `integrations` maps.
* **Errors**: `_handleInternalError` for its own issues. Its job is processing errors reported *to* it. Throws `CoreError` with codes from `ErrorCodes.CORE`.
* **Lifecycle**: Standard `initialize`/`shutdown`; emits lifecycle and error processing events.
* **Health**: Default checks `errorsystem.state`, `errorsystem.handlers`, `errorsystem.integrations`.
* **Metrics**: For lifecycle, errors received/processed, handlers/integrations registered.
* **Factory**: `createErrorSystem(deps = {})`.

#### 5.2.4. Key Integrations
* **All Components**: Report errors to `ErrorSystem` via `safeHandleError`.
* **Logger & Config**: Injected dependencies.
* **Framework Integrations (e.g., `FastifyErrorHandler`)**: Managed by `ErrorSystem`.

**`ErrorSystem`**: Error Processing Flow Summary
```mermaid
graph TD
    A[Error Reported (CoreError instance with prefixed code + context)] --> ES_HandleError["ErrorSystem.handleError()"];
    
    subgraph ErrorSystem_Processing
        direction TB
        ES_HandleError --> ValidateError["Ensure/Wrap to CoreError"];
        ValidateError --> LookupHandler["Lookup Specific/Default Handler (by error.constructor.name)"];
        LookupHandler --> InvokeHandler["Invoke Handler (Custom or Default)"];
        InvokeHandler --> LogNotify["Handler Actions (Logging, Notifications, etc.)"];
        InvokeHandler --> EmitEvent["Emit 'error:handled' or 'error:handler_failed'"];
    end

    subgraph Framework_Integration (Optional)
        direction TB
        FwError["Framework Catches Error"] --> MapError["Integration.mapError(rawError) -> CoreError (prefixed code)"];
        MapError -- "Calls" --> ES_HandleError; %% Integration calls ErrorSystem.handleError()
        ES_HandleError -- "Potentially modifies error/context, then returns to Integration flow" --> SerializeError["Integration.serializeError(CoreError)"];
        SerializeError --> HttpResponse["Send HTTP Error Response"];
    end

    FwError --> MapError;
    %% If error was processed and needs HTTP response. The exact flow might vary.
    %% The primary path is errors reported to ES_HandleError, which then processes.
    %% Integrations use ES_HandleError for consistent processing before serializing.

    classDef entry fill:#f9e79f,stroke:#333,stroke-width:1px;
    classDef process fill:#d6eaf8,stroke:#333,stroke-width:1px;
    classDef framework fill:#e8f8f5,stroke:#333,stroke-width:1px;
    class A entry;
    class ES_HandleError,ValidateError,LookupHandler,InvokeHandler,LogNotify,EmitEvent process;
    class FwError,MapError,SerializeError,HttpResponse framework;
```

### 5.3. `EventBusSystem` & `CoreEventBus`

#### 5.3.1. Primary Responsibility
`EventBusSystem` manages `CoreEventBus` for asynchronous, event-driven communication, promoting decoupling.

#### 5.3.2. Key Functionalities & API Summary
* **`EventBusSystem`**: `initialize()`, `shutdown()`, `getEventBus()`.
* **`CoreEventBus`**: `async emit(eventName, data, options)` (supports queuing), `subscribe(pattern, handler, options)` (exact, pattern `*`, global `*`), `unsubscribe(subscriptionId)`, queuing methods, history methods, `async handleError(error, context)` (for listeners). Errors thrown use unprefixed codes from `ErrorCodes.EVENT`.

#### 5.3.3. Adherence to Standardization Pillars
Standard state, errors (`EventError` with unprefixed codes), lifecycle, health, metrics, factory (`createEventBusSystem`, `createEventBus`).

#### 5.3.4. Key Integrations
* **`ErrorSystem` & Config**: Dependencies for both.
* **Application Modules & Services**: Primary users via `eventBusSystem.getEventBus()`.
* **Other Core Systems**: Can use for async notifications (e.g., `RouterSystem`).

**`EventBusSystem`**: Event Flow Summary
```mermaid
graph TD
    Publisher["Component/Module (Publisher)"] -- "1. getEventBus().emit('eventName', data, opts)" --> CEBus["CoreEventBus"];
    
    subgraph CoreEventBus_Processing
        direction TB
        CEBus --> CreateEvent["Create Standard Event Obj"];
        CreateEvent --> TrackHistory["Track in History"];
        TrackHistory --> CheckQueue{"options.queue?"};
        CheckQueue -- Yes --> QueueEvent["Queue Event"];
        CheckQueue -- No --> FindSubscribers["Find Subscribers (Exact, Pattern, Wildcard)"];
        QueueEvent -- Later via processQueue() --> FindSubscribers;
        FindSubscribers --> InvokeHandler["Invoke Handler(s)"];
    end
    
    InvokeHandler --> Subscriber["Component/Module (Subscriber)"];
    Subscriber -- "Processes event" --> SubscriberLogic["Subscriber Logic"];
    SubscriberLogic -- Optional: Error --> CEBus_HandleError["CoreEventBus.handleError()"];
    CEBus_HandleError -- Reports to --> ErrorSystemGlobal["ErrorSystem"];

    EventBusSystem["EventBusSystem"] -- Manages/Provides --> CEBus;
    
    classDef component fill:#D6EAF8,stroke:#5DADE2,stroke-width:2px;
    classDef appComp fill:#E8F8F5,stroke:#76D7C4,stroke-width:1px;
    classDef process fill:#FEF9E7,stroke:#F7DC6F,stroke-width:1px;

    class EventBusSystem, CEBus component;
    class Publisher, Subscriber, SubscriberLogic, ErrorSystemGlobal appComp;
    class CreateEvent, TrackHistory, CheckQueue, QueueEvent, FindSubscribers, InvokeHandler, CEBus_HandleError process;
```

### 5.4. `ModuleSystem` & `CoreModule`

#### 5.4.1. Primary Responsibility
`ModuleSystem` orchestrates business logic modules (`CoreModule` extensions). `CoreModule` is a standardized base for modules (lifecycle, DI, config, errors, events, health, metrics).

#### 5.4.2. Key Functionalities & API Summary
* **`ModuleSystem`**:
    * `register(name, ModuleClass, config)`: Instantiates module, injects core dependencies (`errorSystem`, `eventBusSystem`, `containerSystem`, module-specific `config`), and other dependencies (other modules, non-module services from `ContainerSystem`) listed in `ModuleClass.static dependencies`. Handles optional dependencies. Throws `ModuleError` or `ValidationError` using unprefixed codes.
    * `resolve(name)`, `initialize()` (orders module init), `shutdown()` (orders module shutdown), `getSystemModulesHealth()`, `handleModuleError()`.
* **`CoreModule`**:
    * `constructor(deps)` receives injected dependencies.
    * Lifecycle Hooks: `onInitialize`, `onShutdown`, etc.
    * Utilities: `handleError()` (uses `ModuleError` with unprefixed codes), `emit()`, `recordMetric()`, `checkHealth()`, `registerHealthCheck()`.
    * `static dependencies`: Array of strings or objects like `{ name: 'depName', optional: true }` to declare dependencies on other modules or non-module services.
    * `this.config` for module-specific configuration.
    * `this.eventBus` for event communication.

#### 5.4.3. Adherence to Standardization Pillars
Standard state, errors (`ModuleError`, `ValidationError` with unprefixed codes), lifecycle, health, metrics, factory (`createModuleSystem`, `createModule`).

#### 5.4.4. Key Integrations
* **`ContainerSystem`**: `ModuleSystem` is managed by it and *uses it* to resolve non-module service dependencies for `CoreModule`s. `containerSystem` is also passed as a dependency to `CoreModule`s.
* **`EventBusSystem`**: Provides `CoreEventBus` to modules. `ModuleSystem` emits module lifecycle events.
* **`ErrorSystem`**: Both `ModuleSystem` and `CoreModule`s report errors.
* **Business Modules**: Managed by `ModuleSystem`.

**`ModuleSystem`** - Architecture & Module Management Summary 
```mermaid
graph TD
    Container["ContainerSystem"] -- "Injects self & core deps (ErrorSys, EventBusSys, Config)" --> MS["ModuleSystem"];
    
    subgraph ModuleSystem_Operations
        direction TB
        Register["register(name, ModuleClass, config)"]
        Initialize["initialize()"]
        Shutdown["shutdown()"]
        GetHealth["getSystemModulesHealth()"]
    end

    Register -- "Uses ContainerSystem to resolve non-module services" --> Container;
    Register -- "Instantiates CoreModule subclass with ALL resolved dependencies" --> CreateInstance["Instantiate ModuleInstance"];
    CreateInstance --> ModulesMap["Registered Modules Map<name, ModuleInstance>"];
    
    Initialize -- "Resolves Inter-Module Dependency Order" --> ResolveOrder["Resolve Order (Handles Optional Modules)"];
    ResolveOrder --> InitLoop["For each module in order: module.initialize()"];
    InitLoop --> Monitor["Start Periodic Health Monitoring for Module"];
    Monitor -- Periodically Calls --> ModCheckHealth["module.checkHealth()"];
    ModCheckHealth -- Reports Status --> ModuleHealthState["ModuleSystem.state.moduleHealth"];
    
    GetHealth -- Aggregates from --> ModuleHealthState;
    ModulesMap -- "Errors Reported ('module:error' event)" --> HandleModError["ModuleSystem.handleModuleError()"];
    HandleModError -- Uses safeHandleError --> ErrorSystemGlobal["ErrorSystem"];

    classDef system fill:#D6EAF8,stroke:#5DADE2,stroke-width:2px;
    classDef module fill:#E8F8F5,stroke:#76D7C4,stroke-width:1px;
    classDef state fill:#f9f,stroke:#333,stroke-width:1px;
    classDef process fill:#FEF9E7,stroke:#F7DC6F,stroke-width:1px;

    class MS, Container, ErrorSystemGlobal system;
    class ModulesMap, ModuleHealthState state;
    class Register, Initialize, Shutdown, GetHealth, ResolveOrder, InitLoop, Monitor, HandleModError, CreateInstance, ModCheckHealth process;
```

**`CoreModule`**: Internal Initialization Sequence Summary 
```mermaid
sequenceDiagram
    participant ModSys as ModuleSystem
    participant MyMod as MyModule (extends CoreModule)
    participant EvBus as CoreEventBus (via MyMod.eventBus)
    participant Container as ContainerSystem (via MyMod.deps.containerSystem)

    ModSys->>MyMod: initialize()
    MyMod->>MyMod: _validateDependencies()<br>(Checks core deps like errorSystem, eventBusSystem, containerSystem, <br/>and other directly injected modules/services. Optional deps are checked if present.)
    MyMod->>MyMod: (Re-fetch this.eventBus from this.deps.eventBusSystem.getEventBus())
    MyMod->>MyMod: validateConfig() --> calls onValidateConfig()<br>(May throw ValidationError using unprefixed ErrorCodes.VALIDATION.CODE)
    MyMod->>MyMod: onConfigure()
    MyMod->>MyMod: setupEventHandlers()<br>(Subscribes to events on EvBus)
    MyMod->>MyMod: setupHealthChecks() --> calls onSetupHealthChecks()<br>(Registers health checks)
    MyMod->>MyMod: onInitialize()<br>(Module-specific init logic. Can use this.deps.containerSystem for *dynamic* service resolution if needed.)
    MyMod->>MyMod: startHealthChecks()<br>(Starts periodic self-health check)
    Note over MyMod: Emits `module:initialized` (to global bus) and <br/>`system:initialized:mymodule` (local to module)
    MyMod-->>ModSys: Initialization Complete / Error (e.g., ModuleError using unprefixed ErrorCodes.MODULE.CODE)
```

### 5.5. `RouterSystem` & `CoreRouter` & `RoutableModule`

#### 5.5.1. Primary Responsibility
Framework-agnostic system for defining, managing, serving HTTP routes, now with dynamic update capabilities.
* **`RouterSystem`**: Manages `CoreRouter`, provides high-level API, orchestrates dynamic refreshes.
* **`CoreRouter`**: Engine for route registry, adapter/middleware management, processing route events, signaling route changes.
* **`RoutableModule`**: `CoreModule` extension for modules to define routes via events.

#### 5.5.2. Key Functionalities & API Summary
* **`RouterSystem`**: `initialize()` (creates/inits `CoreRouter`), `shutdown()`, `getRouter()`. Delegates most operations (e.g., `registerAdapter`, `applyRoutes`) to `CoreRouter`. Listens for `router:routes:changed` from `CoreRouter` to trigger `adapter.refreshRoutes()`. Throws `RouterError` using unprefixed codes.
* **`CoreRouter`**: `initialize()` (subscribes to route events). Internal `registerRoute` (handles conflicts). `registerAdapter` (adapter must implement `refreshRoutes`). `registerMiddleware`. `applyRoutes` (uses adapter). `generateOpenApiDoc`. Emits `router:routes:changed` when its route table is modified post-initial application. Throws `RouterError` using unprefixed codes.
* **`RoutableModule`**: `registerRoute()`, `registerVersionedRoute()`. Emits route definition/unregistration events. Throws `RouterError` using unprefixed codes.

#### 5.5.3. Adherence to Standardization Pillars
Standard state, errors (`RouterError` with unprefixed codes), lifecycle, health, metrics, factory (`createRouterSystem`, `createRoutableModule`).

#### 5.5.4. Key Integrations
* **`EventBusSystem/CoreEventBus`**: `CoreRouter` subscribes to route events from `RoutableModule`s.
* **HTTP Web Frameworks**: `CoreRouter` uses `IRouterAdapter` (e.g., `FastifyAdapter` with `refreshRoutes`).
* **`ErrorSystem`**: All routing components report errors.
* **`ModuleSystem/CoreModule`**: `RoutableModule` is a `CoreModule`.
* **`ContainerSystem`**: Manages `RouterSystem`.

**`RouterSystem`**: Overall Routing Flow Summary 
```mermaid
graph TD
    subgraph ApplicationBootstrap [Application Bootstrap/Setup]
        direction TB
        AppSetup["App Setup Code"]
        HttpFrameworkInst["HTTP Framework Instance (e.g., Fastify)"]
    end

    subgraph RoutableModuleInstance [MyRoutableModule]
        direction TB
        RM_Define["Define Routes (this.registerRoute(...))"]
        RM_OnInit["onInitialize() calls this.registerAllRoutes()"]
        RM_Emit["_emitRouteRegistration()"]
    end

    subgraph EventSystem [EventBusSystem & CoreEventBus]
        direction TB
        EBSys["EventBusSystem"]
        CEBus["CoreEventBus"]
        EBSys -- Provides --> CEBus
    end

    subgraph RouterSystemFacade [RouterSystem Facade]
        direction TB
        RS["RouterSystem"]
        RS_ActiveAdapter[("Active Adapter Ref")]
    end
    
    subgraph CoreRouterEngine [CoreRouter Engine]
        direction TB
        CR["CoreRouter"]
        CR_Routes[("Route Registry")]
        CR_Adapters[("Adapter Registry")]
        CR_AppliedFlag[("_routesAppliedOnce")]
    end

    %% Initialization
    AppSetup -- Creates & Initializes --> RS;
    RS -- Creates & Initializes --> CR;
    CR -- Subscribes to 'router.route.register', etc. --> CEBus;
    RS -- Listens for 'router:routes:changed' from --> CR; %% RouterSystem listens for changes
    
    %% Module Route Definition
    RM_OnInit --> RM_Emit;
    RM_Emit -- "Emits 'router.route.register' event" --> CEBus;
    
    %% CoreRouter Processes Event & Signals Change
    CEBus -- Delivers Event --> CR;
    CR -- "handleRouteRegistration(event)" --> CR_Routes;
    CR -- "If running & applied, emits 'router:routes:changed' " --> CR; %% Internal emit
    
    %% RouterSystem Handles Change (Dynamic Update Path)
    CR -- "Notifies (via event)" --> RS; %% CoreRouter's event reaches RouterSystem
    RS -- "_handleCoreRoutesChanged()" --> RS_ActiveAdapter;
    RS_ActiveAdapter -- "Calls adapter.refreshRoutes(allRoutes)" --> AdapterInst["Specific Adapter (e.g., FastifyAdapter)"];
    AdapterInst -- "Updates its internal router (e.g., find-my-way)" --> AdapterInternalRouter["Adapter's Internal Router"];

    %% Application Applies Routes (Initial Setup)
    AppSetup -- "1. routerSystem.registerAdapter('fwKey', AdapterClass)" --> RS;
    RS -- Delegates --> CR;
    CR -- "Stores adapter" --> CR_Adapters;
    
    AppSetup -- "2. routerSystem.applyRoutes(HttpFrameworkInst, 'fwKey')" --> RS;
    RS -- "Stores active adapter/fw" --> RS_ActiveAdapter;
    RS -- Delegates to --> CR;
    CR -- "applyRoutes(HttpFrameworkInst, 'fwKey')" --> AdapterInst;
    AdapterInst -- "Populates internal router & configures HttpFrameworkInst gateway" --> HttpFrameworkInst;
    CR -- "Sets _routesAppliedOnce = true" --> CR_AppliedFlag;

    classDef system fill:#D6EAF8,stroke:#5DADE2,stroke-width:2px;
    classDef module fill:#E8F8F5,stroke:#76D7C4,stroke-width:2px;
    classDef bus fill:#FEF9E7,stroke:#F7DC6F,stroke-width:2px;
    classDef process fill:#E9D8FD,stroke:#8E44AD,stroke-width:1px;

    class RS, CR, AdapterInst system;
    class RM_OnInit, RM_Define, RM_Emit module;
    class EBSys, CEBus bus;
    class AppSetup, HttpFrameworkInst, AdapterInternalRouter process;
```

---
## 6. Key System Workflows (with Visuals)
How core TSMIS systems interact during key processes.

### 6.1. Application Startup & Initialization Sequence
Describes the typical startup process.
**Application Startup & Initialization Sequence**
*(Ensure diagram notes reflect correct error code instantiation if shown)*
```mermaid
sequenceDiagram
    participant AppEntry as Application Entry Point
    participant CS as ContainerSystem
    participant Config as ConfigurationComponent
    participant Logger as LoggerComponent
    participant ES as ErrorSystem
    participant EBSys as EventBusSystem
    participant MS as ModuleSystem
    participant RSSys as RouterSystem
    participant InvSvc as InventoryService (Non-Module)
    participant InvMod as InventoryModule (CoreModule)
    participant Fw as HTTP Framework

    AppEntry->>CS: createContainerSystem({globalContainerConfig})
    AppEntry->>CS: register('appConfig', ConfigFactory)
    AppEntry->>CS: register('logger', LoggerFactory)
    AppEntry->>CS: register('errorSystem', createErrorSystem)
    AppEntry->>CS: register('eventBusSystem', createEventBusSystem)
    AppEntry->>CS: register('moduleSystem', createModuleSystem)
    AppEntry->>CS: register('routerSystem', createRouterSystem)
    AppEntry->>CS: register('inventoryService', createInventoryService)

    Note over CS: Container reads initOrder: [appConfig, logger, errorSystem, ...]

    AppEntry->>CS: initialize()
    CS->>Config: resolve() & initialize()
    Config-->>CS: Done
    CS->>Logger: resolve() & initialize()
    Logger-->>CS: Done
    CS->>ES: resolve() & initialize()
    ES-->>CS: Done
    CS->>EBSys: resolve() & initialize()
    EBSys-->>CS: Done
    CS->>InvSvc: resolve() & initialize() (if it has init)
    InvSvc-->>CS: Done
    
    CS->>MS: resolve() & initialize()
    MS->>MS: moduleSystem.register('inventory', InventoryModule, appConfig.inventory)<br> (ModuleSystem now resolves 'inventoryService' for InventoryModule from ContainerSystem)
    MS->>InvMod: (via initOrder) new InventoryModule({..., inventoryService: resolvedInvSvc, ...})
    MS->>InvMod: initialize()
    InvMod->>InvMod: onInitialize() (defines routes, emits 'router.route.register' via EventBus)
    InvMod-->>MS: Done
    MS-->>CS: ModuleSystem Init Done

    CS->>RSSys: resolve() & initialize()
    RSSys->>RSSys: (CoreRouter subscribes to 'router.route.register' on EventBus)
    RSSys-->>CS: Done
    
    CS-->>AppEntry: Container Init Complete

    AppEntry->>Fw: new Fastify()
    AppEntry->>RSSys: routerSystem.registerAdapter('fastify', FastifyAdapter)
    AppEntry->>RSSys: routerSystem.applyRoutes(FastifyInst, 'fastify')
    RSSys->>Fw: (Adapter applies routes to Fastify)
    AppEntry->>Fw: fastify.listen()
```

### 6.2. Typical HTTP API Request Flow
Journey of an HTTP request.
**Typical HTTP API Request Flow**
*(Ensure error examples reflect correct error code patterns)*
```mermaid
sequenceDiagram
    participant Client as HTTP Client
    participant Fw as HTTP Web Framework (e.g., Fastify)
    participant Adapter as Router Adapter (e.g., FastifyAdapter's Internal Router)
    participant RM as RoutableModule Instance
    participant Service as Business Service (Optional)
    participant ESysInt as ErrorSystem Framework Integration
    participant ESys as ErrorSystem

    Client->>+Fw: HTTP Request (e.g., GET /api/products/123)
    Fw->>+Adapter: (Gateway Route) Passes request to Adapter's Internal Router
    Adapter->>Adapter: Finds matching TSMIS route
    Adapter->>+RM: Call routeHandler(request, reply)
    RM->>RM: (Optional) Validate request
    alt Request Validation Fails
        RM->>RM: throw new ValidationError(ErrorCodes.VALIDATION.CODE, ...)
        RM-->>-Adapter: Returns/Throws ValidationError
    else Request Validation Succeeds
        RM->>+Service: (Optional) Call service.getProductById(...)
        Service->>Service: Business logic
        Service-->>-RM: Return result or throws ServiceError(ErrorCodes.SERVICE.CODE, ...)
        
        alt Service Operation Fails (Error caught by RM)
            RM->>RM: this.handleError(serviceError, context)
            RM-->>-Adapter: Returns/Throws ServiceError
        else Service Operation Succeeds
            RM->>RM: Prepare success response data
            RM-->>-Adapter: Return response data
        end
    end
    Adapter-->>-Fw: Forwards response/error
    Fw-->>-Client: HTTP Response (Success Data or Error Payload from ESysInt)

    %% Global Error Path for unhandled errors in RM/Adapter or Fw specific errors
    Note over Fw, ESysInt: If any unhandled error bubbles to Fastify
    Fw->>+ESysInt: Framework's Global Error Handler (uses FastifyErrorHandler)
    ESysInt->>ESysInt: mapErrorToCoreError(rawError)
    ESysInt->>ESys: handleError(mappedCoreError, requestContext)
    ESys->>ESys: (Processes error)
    ESysInt->>ESysInt: serializeErrorForHttpResponse(mappedCoreError)
    ESysInt-->>-Fw: Serialized error payload & status code
```

### 6.3. Event Propagation within the System
How events are emitted, processed by `CoreEventBus`, and delivered.

**Event Propagation within the System**
```mermaid
sequenceDiagram
    participant CompA as Component A (Emitter)
    participant EBSys as EventBusSystem
    participant CEBus as CoreEventBus
    participant CompB as Component B (Subscriber)
    participant CompC as Component C (Pattern/Wildcard Subscriber)
    participant ESys as ErrorSystem (via safeHandleError)

    CompA->>EBSys: getEventBus()
    EBSys-->>CompA: Returns CoreEventBus instance

    CompA->>+CEBus: emit("user:created", userData, { metadata: {...} })
    CEBus->>CEBus: Create Standard Event Object (id, name, data, timestamp, metadata)
    CEBus->>CEBus: trackEvent(eventObject)
    CEBus->>CEBus: Record 'eventbus.events.emitted' metric

    alt options.queue is true
        CEBus->>CEBus: queueEvent(eventObject, options)
        Note over CEBus: Event added to queue.
    else options.queue is false (Direct Emission)
        Note over CEBus: Identify matching subscribers for "user:created"
        CEBus->>CompB: (Invoke CompB.handler(eventObject))
    
        CompB->>CompB: Process event "user.created"
        alt Error in CompB handler
            CompB->>CEBus: handleError(handlerError, context)
            CEBus->>ESys: (via safeHandleError) report error
        end

        Note over CEBus: Check for pattern/wildcard subscribers
        opt Wildcard Forwarding Active
            CEBus->>CompC: (Invoke CompC.handler(eventObject) if pattern matches or is '*')
            CompC->>CompC: Process event
             alt Error in CompC handler
                CompC->>CEBus: handleError(handlerError, context)
                CEBus->>ESys: (via safeHandleError) report error
            end
        end
    end
    CEBus-->>-CompA: Returns boolean (emit result)
```

### 6.4. Centralized Error Reporting in Action
How errors are processed through to `ErrorSystem`.
Description updated to emphasize that `CoreError` subclasses are instantiated with unprefixed specific codes from `ErrorCodes.js`, and the subclass constructor prepends the domain prefix.

**Centralized Error Reporting in Action**
```mermaid
sequenceDiagram
    participant AppComp as Application Component
    participant CoreErrUtil as ErrorCodes.js / SpecificError Class
    participant ModHndlErr as Module.handleError() (if applicable)
    participant SafeHndlErr as ErrorUtils.safeHandleError()
    participant ErrSys as ErrorSystem
    participant CustomHndlr as CustomErrorHandler (in ErrorSystem)
    participant DefaultHndlr as DefaultCoreErrorHandler (in ErrorSystem)
    participant FwInt as FrameworkIntegration (e.g., FastifyErrorHandler)
    participant Logger as Logger
    participant HttpClient as HTTP Client

    AppComp->>AppComp: 1. Error Occurs
    AppComp->>CoreErrUtil: 2. new SpecificError(ErrorCodes.DOMAIN.UNPREFIXED_CODE, msg, details, {cause}) <br> OR new CoreError(ErrorCodes.CORE.PREFIXED_CODE, ...)
    CoreErrUtil-->>AppComp: Returns CoreError instance (code is now fully prefixed)

    alt Error within a CoreModule derivative
        AppComp->>ModHndlErr: 3a. this.handleError(error, context)
        ModHndlErr->>ModHndlErr: Logs to module.state.errors, records metric
        ModHndlErr->>SafeHndlErr: safeHandleError(this.deps.errorSystem, error, context)
    else Direct reporting
        AppComp->>SafeHndlErr: 3b. safeHandleError(errorSystemInstance, error, context)
    end

    SafeHndlErr->>ErrSys: 4. errorSystem.handleError(errorWithPrefixedCode, context)
    Note over ErrSys: Records metric, ensures CoreError type
    ErrSys->>ErrSys: 5. Lookup Handler (based on error.constructor.name)

    alt Specific Handler Found
        ErrSys->>CustomHndlr: 6a. specificHandler(errorWithPrefixedCode, context)
        CustomHndlr->>CustomHndlr: (Performs custom actions)
        CustomHndlr-->>ErrSys: (Handler completes)
    else Default CoreError Handler
        ErrSys->>DefaultHndlr: 6b. defaultCoreErrorHandler(errorWithPrefixedCode, context)
        DefaultHndlr->>Logger: Logs error via this.deps.logger
        DefaultHndlr-->>ErrSys: (Handler completes)
    end
    
    ErrSys->>ErrSys: 7. Emits 'error:handled' or 'error:handler_failed'

    opt HTTP Context Error (Error propagates to Framework)
        AppComp-->>FwInt: (Error reaches Framework's global handler, which uses Integration)
        FwInt->>FwInt: mapError(rawError) -> mappedCoreError (with prefixed code)
        FwInt->>ErrSys: (Potentially) errorSystem.handleError(mappedCoreError, reqContext)
        FwInt->>FwInt: serializeError(mappedCoreError) -> httpPayload
        FwInt-->>HttpClient: HTTP Error Response
    end
```

### 6.5. Conceptual Health & Metrics Aggregation Flow
How a Monitoring Layer could collect health and metrics.

** Conceptual Health & Metrics Aggregation Flow**
```mermaid
graph TD
    A[Monitoring Layer / Admin Interface] -- Periodically or On-Demand --> Polls;
    
    subgraph Polls
        direction LR
        A --> CS[ContainerSystem.checkHealth() / .getMetrics()];
        A --> ES[ErrorSystem.checkHealth() / .getMetrics()];
        A --> EBSys[EventBusSystem.checkHealth() / .getMetrics()];
        A --> MS[ModuleSystem.checkHealth() / .getMetrics()];
        A --> RS[RouterSystem.checkHealth() / .getMetrics()];
    end

    EBSys -- Internally Calls --> CEB[CoreEventBus.checkHealth() / .getMetrics()];
    MS -- Internally Calls --> Mods["For each Module:<br>module.checkHealth() / .getMetrics()"];
    RS -- Internally Calls --> CR[CoreRouter.checkHealth() / .getMetrics()];
    
    CS --> B[Standardized Health/Metrics Response];
    ES --> B;
    EBSys --> B;
    MS --> B;
    RS --> B;
    
    B --> A;
    A --> Display[Unified Dashboard / Alerting System];

    classDef monitor fill:#E6E6FA,stroke:#9370DB,stroke-width:2px;
    classDef system fill:#D6EAF8,stroke:#5DADE2,stroke-width:2px;
    classDef internal fill:#E8F8F5,stroke:#76D7C4,stroke-width:1px;
    class A,Display monitor;
    class CS,ES,EBSys,MS,RS system;
    class CEB,Mods,CR internal;
```

---
## 7. Developing Business Modules: A Practical Guide
Guide for creating business logic modules extending `CoreModule` or `RoutableModule`.

### 7.1. Guiding Principles for Module Design
Single Responsibility, Loose Coupling, Clear Interfaces, Configuration Driven, Leverage `CoreModule` Features, Service Layer Separation, Testability.

### 7.2. Extending `CoreModule` or `RoutableModule`
Choose based on HTTP endpoint needs.

### 7.3. Example Module: `InventoryModule`
Illustrates creating a `RoutableModule`.

#### 7.3.1. Recommended Directory Structure

**Example Module**: `InventoryModule` - Recommended Directory Structure
```text
src/
└── modules/
    └── inventory/
        ├── InventoryModule.js        # The main module class, extends RoutableModule
        ├── InventoryService.js       # Contains the core business logic/rules for inventory
        ├── inventory.errors.js       # (Optional) Custom ErrorTypes or specific ErrorCodes for ErrorCodes.js INVENTORY domain
        ├── inventory.events.js       # (Optional) Constants for event names specific to inventory
        ├── schemas/                  # (Optional) Validation schemas for API requests/responses
        │   ├── addItem.schema.js
        │   └── updateStock.schema.js
        └── tests/
            ├── InventoryModule.test.js   # Unit tests for the module class
            └── InventoryService.test.js  # Unit tests for the service logic
```

#### 7.3.2. Defining Routes and Handlers (within the RoutableModule)
Routes defined in `onInitialize()` via `this.registerRoute()`. Handlers are module methods.

**`InventoryModule`: Example Route Definitions in `onInitialize`
```javascript
// Inside InventoryModule.js, within onInitialize() method:
// async onInitialize() {
//   await super.onInitialize(); // Important! Calls RoutableModule's onInitialize, which triggers registerAllRoutes

//   // Define API routes
//   // const addItemSchema = require('./schemas/addItem.schema.js'); // Example import
//   this.registerVersionedRoute(1, 'POST', '/items', this.handleAddItem, {
//     schema: addItemSchema, // Reference to an imported schema object
//     summary: "Add a new item to inventory",
//     tags: ['Inventory', 'Items']
//   });
//   this.registerVersionedRoute(1, 'GET', '/items/:sku', this.handleGetItem, {
//     summary: "Get an item by SKU",
//     tags: ['Inventory', 'Items']
//   });
//   // ... other route definitions
// }

// // Handler methods also within InventoryModule.js
// // async handleAddItem(request, reply) { /* ... handler logic ... */ }
// // async handleGetItem(request, reply) { /* ... handler logic ... */ }
```

#### 7.3.3. Defining Module-Specific Errors (`inventory.errors.js`)
Define custom `InventoryError` (e.g., extending `CoreError` or `ModuleError`) and add unprefixed specific codes to an `INVENTORY` domain within `ErrorCodes.js`. The `InventoryError` constructor will prepend `INVENTORY_` (or `MODULE_INVENTORY_` if extending `ModuleError` and `ModuleError` handles the `MODULE_` part based on an inventory-specific code).
*Preferably, `InventoryError` extends `CoreError` and prepends `INVENTORY_` for clarity.*

**`InventoryModule`: Defining Module-Specific Errors
```javascript
// src/modules/inventory/inventory.errors.js
import { CoreError } from '../../core/errors/CoreError.js'; // Prefer extending CoreError directly for domain errors
// import { ModuleError } from '../../core/errors/index.js'; // Or ModuleError if it truly represents a generic module fault within inventory

// If InventoryError represents specific business rule violations for inventory,
// extending CoreError directly gives cleaner, domain-specific error codes like INVENTORY_ITEM_NOT_FOUND.
// If it represents a failure of the inventory *module* itself as a system component, ModuleError might be used.
// For business errors, CoreError is often a better base.

/**
 * Custom error class for inventory-specific operational errors.
 */
export class InventoryError extends CoreError { // Changed base to CoreError for direct prefixing
  /**
   * Creates a new InventoryError instance.
   * The constructor will prepend "INVENTORY_" to the provided specific code.
   * @param {string} specificCode - The specific, **unprefixed** inventory error code from `ErrorCodes.INVENTORY`.
   * @param {string} message - Human-readable error message.
   * @param {object} [details={}] - Additional error details.
   * @param {object} [options={}] - Options, including 'cause'.
   */
  constructor(specificCode, message, details = {}, options = {}) {
    super(\`INVENTORY_${specificCode}\`, message, details, options);
    this.name = 'InventoryError';
    // Assign a default statusCode or make it dependent on the specificCode
    this.statusCode = details.statusCode || 400; // Example: default to 400 or 500 based on error type
    if (details.statusCode) delete details.statusCode; // Consume it from details
  }
}

// It's recommended to define these specific codes within the main
// src/core/errors/ErrorCodes.js file under an 'INVENTORY' domain.
// Example structure for ErrorCodes.js:
//
// export const ErrorCodes = Object.freeze({
//   // ... other domains ...
//   INVENTORY: Object.freeze({
//     ITEM_NOT_FOUND: 'ITEM_NOT_FOUND', // Unprefixed specific code
//     INSUFFICIENT_STOCK: 'INSUFFICIENT_STOCK',
//     INVALID_SKU_FORMAT: 'INVALID_SKU_FORMAT',
//     NEGATIVE_STOCK_UNSUPPORTED: 'NEGATIVE_STOCK_UNSUPPORTED',
//     ITEM_ALREADY_EXISTS: 'ITEM_ALREADY_EXISTS',
//     // Add other inventory-specific error codes here
//   }),
// });

// Usage within InventoryModule or InventoryService:
// import { ErrorCodes } from '../../core/errors/ErrorCodes.js'; // Path to global ErrorCodes
// import { InventoryError } from './inventory.errors.js';
//
// function findItem(sku) {
//   const item = null; // Simulating item not found
//   if (!item) {
//     throw new InventoryError(
//       ErrorCodes.INVENTORY.ITEM_NOT_FOUND, // Uses the unprefixed code 'ITEM_NOT_FOUND'
//       \`Item with SKU ${sku} not found.\`,
//       { sku, attemptedOperation: 'findItem' },
//       { statusCode: 404 } // Optionally pass statusCode in details for constructor
//     );
//     // The resulting error.code will be 'INVENTORY_ITEM_NOT_FOUND'
//     // The resulting error.statusCode will be 404
//   }
//   return item;
// }
```

#### 7.3.4. Defining Module-Specific Events (`inventory.events.js`)
Constants for event names (e.g., `INVENTORY_EVENTS.ITEM_ADDED`).

**`InventoryModule`**: Defining Module-Specific Events
```javascript
// src/modules/inventory/inventory.events.js

/**
 * Defines standardized event names related to the Inventory module.
 */
export const INVENTORY_EVENTS = Object.freeze({
  ITEM_ADDED: 'inventory.item.added',
  ITEM_REMOVED: 'inventory.item.removed',
  ITEM_UPDATED: 'inventory.item.updated',
  STOCK_UPDATED: 'inventory.item.stock_updated',
  STOCK_LOW: 'inventory.item.stock_low',
  STOCK_OUT_OF_STOCK: 'inventory.item.out_of_stock',
  BULK_STOCK_ADJUSTED: 'inventory.bulk_stock_adjusted',

  // Example of events InventoryModule might listen to:
  ORDER_ITEM_ALLOCATED: 'order.item.allocated',
  ORDER_ITEM_RETURNED: 'order.item.returned',
});
```

#### 7.3.5. Implementing the Business Logic Service (`InventoryService.js`)
Encapsulates business rules. Declares `static dependencies` for services it needs (e.g., `['config', 'logger', 'databaseService']`). These will be injected by `ContainerSystem` if `InventoryService` is registered with it.

**`InventoryService.js`**
```javascript
// src/modules/inventory/InventoryService.js
// Assuming InventoryError and global ErrorCodes (with INVENTORY domain) are set up as previously discussed.
// import { InventoryError } from './inventory.errors.js';
// import { ErrorCodes } from '../../core/errors/ErrorCodes.js';

export class InventoryService {
  static dependencies = ['config', 'logger' /*, 'databaseService' */];

  constructor(deps) {
    this.config = deps.config?.inventoryService || deps.config?.inventory?.service || {};
    this.logger = deps.logger || console;
    this._stock = new Map(); // Using an in-memory store for example
    this.logger.info(`[InventoryService] Initialized. Allow Negative Stock: ${!!this.config.allowNegativeStock}`);
  }

  async addItem(itemData) {
    if (!itemData || !itemData.sku || !itemData.name || typeof itemData.quantity !== 'number' || typeof itemData.price !== 'number') {
      throw new InventoryError( // Uses InventoryError, which will prefix with INVENTORY_
        ErrorCodes.INVENTORY.INVALID_SKU_FORMAT, // Pass unprefixed specific code
        'Item data is invalid. SKU, name, quantity, and price are required.',
        { providedSku: itemData?.sku }
      );
    }
    if (this._stock.has(itemData.sku)) {
      throw new InventoryError(
        ErrorCodes.INVENTORY.ITEM_ALREADY_EXISTS, // Pass unprefixed specific code
        `Item with SKU '${itemData.sku}' already exists.`,
        { sku: itemData.sku }
      );
    }
    // ... implementation ...
    const newItem = { ...itemData };
    this._stock.set(itemData.sku, newItem);
    return { ...newItem };
  }

  async updateStock(sku, quantityChange) {
    const item = this._stock.get(sku);
    if (!item) {
      throw new InventoryError(ErrorCodes.INVENTORY.ITEM_NOT_FOUND, `Item with SKU '${sku}' not found.`, { sku }, { statusCode: 404 });
    }
    const newQuantity = item.quantity + quantityChange;
    if (newQuantity < 0 && !(this.config.allowNegativeStock === true)) {
      throw new InventoryError(
        ErrorCodes.INVENTORY.INSUFFICIENT_STOCK, // Pass unprefixed specific code
        `Insufficient stock for SKU '${sku}'. Attempted to change by ${quantityChange}.`,
        { sku, currentQuantity: item.quantity, requestedChange: quantityChange }
      );
    }
    item.quantity = newQuantity;
    this._stock.set(sku, item);
    return { ...item };
  }
  // ... other methods like getItemBySku, listItems, checkHealth ...
}

// export function createInventoryService(deps) {
//   return new InventoryService(deps);
// }
```

#### 7.3.6. Defining API Schemas (`schemas/addItem.schema.js`)
JSON Schema for request/response validation.

**API Schema**: `addItem.schema.js`
```javascript
// src/modules/inventory/schemas/addItem.schema.js
export const addItemSchema = {
  body: {
    type: 'object',
    required: ['sku', 'name', 'quantity', 'price'],
    properties: {
      sku: { type: 'string', minLength: 1 },
      name: { type: 'string', minLength: 1, maxLength: 255 },
      description: { type: 'string', nullable: true },
      quantity: { type: 'integer', minimum: 0 },
      price: { type: 'number', minimum: 0 },
      supplierId: { type: 'string', nullable: true },
      attributes: { type: 'object', nullable: true, additionalProperties: true }
    },
  },
  response: {
    201: {
      description: 'Item created successfully.',
      type: 'object',
      properties: {
        // Define expected response properties, matching what addItem returns
        sku: { type: 'string' },
        name: { type: 'string' },
        // ... other properties from the item
        createdAt: { type: 'string', format: 'date-time' }, // Example server-generated
      },
    },
    // Other responses e.g., 400 for validation error (handled by FastifyErrorHandler)
  },
};
```

#### 7.3.7. Implementing the Main Module Class (`InventoryModule.js`)
Extends `RoutableModule`. Its `constructor(deps)` receives core systems, its config, and now also its declared module and non-module service dependencies directly from `ModuleSystem`. Implements lifecycle hooks, defines route handlers, uses `this.handleError` (which instantiates errors with unprefixed codes), `this.emit`, `this.recordMetric`.

**`InventoryModule.js` Main Class Example** 
```javascript
// src/modules/inventory/InventoryModule.js
import { RoutableModule } from '../../core/router/RoutableModule.js';
import { ErrorCodes } from '../../core/errors/ErrorCodes.js';
import { InventoryError } from './inventory.errors.js'; // Assuming this custom error is defined
import { INVENTORY_EVENTS } from './inventory.events.js';
// import { addItemSchema } from './schemas/addItem.schema.js';
// import { CoreError, ValidationError } from '../../core/errors/index.js';


export class InventoryModule extends RoutableModule {
  // Declare all dependencies: core, other modules, and non-module services
  static dependencies = [
    ...RoutableModule.dependencies, // Inherits errorSystem, eventBusSystem, config, containerSystem
    'inventoryService', // This is a non-module service
    // { name: 'optionalReportingModule', optional: true } // Example optional module
  ];
  static version = '1.0.0';

  constructor(deps) {
    super(deps);
    // Dependencies are now directly available on this.deps if resolved by ModuleSystem
    this.inventoryService = deps.inventoryService;
    // this.optionalReportingModule = deps.optionalReportingModule; 
    
    if (!this.inventoryService) {
        // This check might be redundant if ModuleSystem's registration ensures critical deps are present
        // or throws during its own dependency resolution for the module.
        // However, it's good practice for the module to confirm critical dependencies.
        throw new ModuleError( // Using ModuleError for a module setup/dependency issue
            ErrorCodes.MODULE.MISSING_DEPENDENCIES, // Unprefixed specific code
            `${this.constructor.name}: Critical dependency 'inventoryService' was not injected.`,
            { dependency: 'inventoryService' }
        );
    }
    this.lowStockThreshold = this.config.lowStockThreshold || 10;
    this.subscriptions = [];
    this.deps.logger.info(`[${this.constructor.name}] Constructed. InventoryService available: ${!!this.inventoryService}`);
  }

  async onValidateConfig() {
    await super.onValidateConfig();
    if (this.config.lowStockThreshold !== undefined) {
      if (typeof this.config.lowStockThreshold !== 'number' || this.config.lowStockThreshold < 0) {
        // ErrorCodes.INVENTORY.INVALID_CONFIG_VALUE should be 'INVALID_CONFIG_VALUE'
        throw new InventoryError( 
          ErrorCodes.INVENTORY.INVALID_CONFIG_VALUE,
          "Config 'lowStockThreshold' must be a non-negative number.",
          { field: 'lowStockThreshold', value: this.config.lowStockThreshold }
        );
      }
    }
    return true;
  }

  async onConfigure() {
    await super.onConfigure();
    if (this.config.lowStockThreshold !== undefined) {
      this.lowStockThreshold = this.config.lowStockThreshold;
    }
    this.deps.logger.info(`[${this.constructor.name}] Configured. Low stock threshold: ${this.lowStockThreshold}`);
  }
  
  async setupEventHandlers() {
    await super.setupEventHandlers();
    if (!this.eventBus) {
        this.deps.logger.warn(`[${this.constructor.name}] EventBus not available during setupEventHandlers.`);
        return;
    }
    // Example subscription
    // const subId = this.eventBus.subscribe(
    //   INVENTORY_EVENTS.ORDER_ITEM_ALLOCATED, 
    //   this.handleOrderItemAllocated.bind(this)
    // );
    // this.subscriptions.push(subId);
  }

  async onSetupHealthChecks() {
    await super.onSetupHealthChecks();
    if (this.inventoryService && typeof this.inventoryService.checkHealth === 'function') {
        this.registerHealthCheck('inventorymodule.service.dependency', this.inventoryService.checkHealth.bind(this.inventoryService));
    }
  }

  async onInitialize() {
    this.deps.logger.info(`[${this.constructor.name}] Defining routes...`);
    // const addItemSchema = {}; // Placeholder for actual schema import
    this.registerVersionedRoute(1, 'POST', '/items', this.handleAddItem, { /* schema: addItemSchema */ });
    this.registerVersionedRoute(1, 'GET', '/items/:sku', this.handleGetItem);
    // ... other routes ...
    await super.onInitialize(); // This calls registerAllRoutes from RoutableModule
    this.deps.logger.info(`[${this.constructor.name}] Initialized and routes defined.`);
  }

  async onShutdown() {
    // ... unsubscriptions ...
    await super.onShutdown();
  }

  // --- Route Handlers ---
  async handleAddItem(request, reply) {
    try {
      const newItem = await this.inventoryService.addItem(request.body);
      await this.emit(INVENTORY_EVENTS.ITEM_ADDED, { item: newItem });
      reply.code(201);
      return newItem;
    } catch (error) {
      // Errors from inventoryService (e.g., InventoryError) will already have prefixed codes.
      // If a generic error happens here, handleError will wrap it.
      await this.handleError(error, { operation: 'handleAddItem', endpoint: request.url });
      throw error; // Re-throw for framework error handler to catch and respond
    }
  }

  async handleGetItem(request, reply) {
    const { sku } = request.params;
    try {
      const item = await this.inventoryService.getItemBySku(sku);
      if (!item) {
        // ErrorCodes.INVENTORY.ITEM_NOT_FOUND should be 'ITEM_NOT_FOUND'
        throw new InventoryError(
            ErrorCodes.INVENTORY.ITEM_NOT_FOUND, 
            `Item with SKU ${sku} not found.`, 
            { sku }, 
            { statusCode: 404 }
        );
      }
      return item;
    } catch (error) {
      await this.handleError(error, { operation: 'handleGetItem', sku });
      throw error;
    }
  }
  // ... other handlers like handleUpdateStock, handleListItems ...
  // ... event handlers like handleOrderItemAllocated ...
}

// export function createInventoryModule(deps) {
//   return new InventoryModule(deps);
// }
```

### 7.4. Registering the Module & Its Services with the Core
1.  Register non-module services (like `InventoryService`) with `ContainerSystem`.
2.  Register module class (e.g., `InventoryModule`) with `ModuleSystem`, passing module-specific config. `ModuleSystem` will use the `ContainerSystem` (which must be one of `ModuleSystem`'s dependencies) to resolve and inject services like `InventoryService` into the `InventoryModule` instance, based on `InventoryModule.static dependencies`.

**Module and Service Registration**
```javascript
// In your application bootstrap file (e.g., src/app.js)
// Assume 'container' is your main ContainerSystem instance.
// import { createInventoryService } from './modules/inventory/InventoryService.js';
// import { InventoryModule } from './modules/inventory/InventoryModule.js'; // The class
// import { createModuleSystem } from './core/module/ModuleSystem.js';
// import { ErrorCodes } from './core/errors/ErrorCodes.js';


// async function setupApplication(container) {
//   // --- 1. Register Non-Module Services (like InventoryService) with ContainerSystem ---
//   container.register('inventoryService', createInventoryService);
//   // ... register other application-specific services ...

//   // --- 2. Register ModuleSystem itself with ContainerSystem ---
//   // ModuleSystem needs 'containerSystem' injected to resolve non-module services for modules.
//   // Its 'dependencies' static array should list 'containerSystem'.
//   container.register('moduleSystem', createModuleSystem);


//   // --- 3. Get ModuleSystem instance & Register Business Modules ---
//   let moduleSystem;
//   try {
//     moduleSystem = await container.resolve('moduleSystem');
//   } catch (error) {
//     console.error('Failed to resolve ModuleSystem from container:', error);
//     throw error;
//   }

//   try {
//     // ModuleSystem.register will now use its injected ContainerSystem
//     // to resolve 'inventoryService' (and any other non-module services)
//     // listed in InventoryModule.static_dependencies and inject them directly.
//     const appConfig = await container.resolve('appConfig'); // Assuming appConfig is registered
//     await moduleSystem.register(
//       'inventory',                // Module instance name
//       InventoryModule,            // The module class
//       appConfig.inventory         // Module-specific config for this instance
//     );
//     console.log('InventoryModule registered with ModuleSystem.');
//   } catch (error) {
//     console.error('Failed to register InventoryModule:', error);
//     // Example: error.code might be 'MODULE_DEPENDENCY_RESOLUTION_FAILED' (prefixed)
//     // if (error.code === `MODULE_${ErrorCodes.MODULE.DEPENDENCY_RESOLUTION_FAILED}`) { /* ... */ }
//     throw error;
//   }

//   // ... register other business modules ...

//   // --- 4. Application Initialization ---
//   // await container.initialize(); 
//   // This will initialize ModuleSystem, which in turn initializes InventoryModule.
//   // InventoryModule constructor will receive `inventoryService` directly in its `deps`.
// }

// // Example bootstrap call:
// // async function main() {
// //   const container = createContainerSystem();
// //   container.register('appConfig', () => ({ /* ... app config ... */ inventory: {lowStockThreshold: 5} }));
// //   container.register('logger', () => console);
// //   container.register('errorSystem', createErrorSystem);
// //   container.register('eventBusSystem', createEventBusSystem);
//   // ContainerSystem is available as `container` itself to be passed as a dependency

// //   await setupApplication(container);
// //   await container.initialize();
// //   console.log('Application bootstrapped.');
// // }
// // main().catch(err => { console.error("App Bootstrap Failed:", err); process.exit(1); });
```

### 7.5. Module-specific Configuration Details
Module config passed to `ModuleSystem.register()` is available as `this.config` in the module. Services typically access their config via a global `config` object (if they are registered with `ContainerSystem` which injects it) or via the config passed to them if they are instantiated differently.

**Passing Configuration during `moduleSystem.register()`**
```javascript
// Example:
// Assuming 'moduleSystem' is an instance of ModuleSystem
// and 'InventoryModule' is the class definition.
// moduleSystem.register(
//   'inventory', // Module instance name
//   InventoryModule, // Module class
//   { // This is the module-specific config object for this 'inventory' instance
//     lowStockThreshold: 5,
//     defaultSupplier: 'SUP-001',
//     featureFlags: { enableAdvancedAnalytics: true }
//   }
// );
```

**Accessing `this.config` in `InventoryModule.js`**
```javascript
// Example within InventoryModule.js:
// class InventoryModule extends RoutableModule {
//   constructor(deps) {
//     super(deps);
//     // 'this.config' is automatically set by CoreModule's constructor
//     // to the config object passed during moduleSystem.register().
//     // So, this.config would be:
//     // { lowStockThreshold: 5, defaultSupplier: 'SUP-001', featureFlags: { enableAdvancedAnalytics: true } }

//     this.lowStockThreshold = this.config.lowStockThreshold || 10; // Use default if not provided
//     this.defaultSupplierId = this.config.defaultSupplier;
//     this.analyticsEnabled = this.config.featureFlags?.enableAdvancedAnalytics || false;
//   }

//   async onConfigure() {
//      await super.onConfigure();
//      this.deps.logger.info(`[${this.constructor.name}] Low stock threshold set to: ${this.lowStockThreshold}`);
//   }
// }
```

**`InventoryService` Accessing its Configuration Section from Global Config**
```javascript
// Example within InventoryService.js:
// class InventoryService {
//   static dependencies = ['config', 'logger']; // Expects global 'config' and 'logger'

//   constructor(deps) {
//     // deps.config here is the global application config object, injected by ContainerSystem.
//     // The service looks for its specific section within this global config.
//     this.serviceConfig = deps.config?.inventoryService || {}; // Accessing 'inventoryService' section
//     this.logger = deps.logger || console;
//     this.allowNegativeStock = this.serviceConfig.allowNegativeStock === true;
//     this.dbPoolSize = this.serviceConfig.databasePoolSize || 5;
//     this.logger.info(`[InventoryService] Configured. Allow Negative Stock: ${this.allowNegativeStock}, DB Pool: ${this.dbPoolSize}`);
//   }
// }
```

**Structure of a Global Application Configuration Object**
```javascript
// Example structure for a global application configuration object
// (e.g., loaded from a file, environment variables, and registered as 'config' in ContainerSystem)
// const globalAppConfig = {
//   appName: 'TSMIS App',
//   port: 3000,
//   environment: 'development',

//   logger: {
//     level: 'info',
//     prettyPrint: true,
//   },

//   eventBusSystem: { /* Configurations specific to EventBusSystem */ },
//   coreEventBus: { maxHistorySize: 500, queueBatchSize: 50 },

//   moduleSystem: { defaultHealthCheckIntervalMs: 60000 },

//   // Section specifically for the 'inventory' module instance (passed to ModuleSystem.register)
//   inventory: { 
//     lowStockThreshold: 5,
//     defaultSupplier: 'AcmeCorp',
//     featureFlags: { enableAdvancedAnalytics: true, enableAutoReorder: false, }
//   },

//   // Section specifically for the 'inventoryService' component/service (read by InventoryService itself)
//   inventoryService: { 
//     allowNegativeStock: false,
//     databasePoolSize: 10,
//   },

//   // Configuration for other modules and services...
// };
```

### 7.6. Unit Testing Modules (Using Jest)
Mock dependencies injected by `ModuleSystem` (core systems, other modules, non-module services). Test business logic, lifecycle hooks, event/route handlers, error reporting (ensure errors are created with correct unprefixed specific codes passed to constructors), and metric recording.

**Example**: Unit Testing InventoryModule
```javascript
// src/modules/inventory/tests/InventoryModule.test.js
// import { InventoryModule } from '../InventoryModule.js';
// import { ErrorCodes } from '../../../core/errors/ErrorCodes.js';
// import { InventoryError } from '../inventory.errors.js';
// import { SYSTEM_STATUS } from '../../../core/common/SystemConstants.js';

// describe('InventoryModule', () => {
//   let mockDeps;
//   let inventoryModule;
//   let mockInventoryService;
//   let mockEventBus;
//   let mockContainerSystem;

//   beforeEach(() => {
//     mockInventoryService = {
//       addItem: jest.fn(),
//       getItemBySku: jest.fn(),
//       checkHealth: jest.fn().mockResolvedValue({ status: SYSTEM_STATUS.HEALTHY, detail: {} }),
//     };
//     mockEventBus = { emit: jest.fn().mockResolvedValue(true), subscribe: jest.fn() };
//     mockContainerSystem = { resolve: jest.fn() }; // For dynamic resolution if module uses it

//     mockDeps = {
//       errorSystem: { handleError: jest.fn().mockResolvedValue() },
//       eventBusSystem: { getEventBus: jest.fn().mockReturnValue(mockEventBus) },
//       containerSystem: mockContainerSystem, // ModuleSystem would inject this
//       config: { lowStockThreshold: 5 },
//       logger: { info: jest.fn(), warn: jest.fn(), error: jest.fn(), debug: jest.fn() },
//       inventoryService: mockInventoryService, // This is now directly injected by ModuleSystem
//     };
//     inventoryModule = new InventoryModule(mockDeps);
//   });

//   test('constructor should store injected inventoryService', () => {
//     expect(inventoryModule.inventoryService).toBe(mockInventoryService);
//   });

//   describe('onInitialize', () => {
//     // Test that routes are registered, etc.
//     // Test that if a non-module service was NOT declared in static dependencies
//     // but is resolved in onInitialize, the containerSystem mock is called.
//   });

//   describe('handleAddItem', () => {
//     it('should call inventoryService.addItem and emit event', async () => {
//       const itemData = { sku: 'T1', name: 'Test Item', quantity: 10, price: 100 };
//       const createdItem = { ...itemData, id: 'item1' };
//       mockInventoryService.addItem.mockResolvedValue(createdItem);
//       inventoryModule.eventBus = mockEventBus; // Ensure eventBus is available after initialize

//       const mockRequest = { body: itemData, url: '/items' };
//       const mockReply = { code: jest.fn().mockReturnThis() };

//       const result = await inventoryModule.handleAddItem(mockRequest, mockReply);

//       expect(mockInventoryService.addItem).toHaveBeenCalledWith(itemData);
//       expect(mockEventBus.emit).toHaveBeenCalledWith('inventory.item.added', { item: createdItem });
//       expect(mockReply.code).toHaveBeenCalledWith(201);
//       expect(result).toEqual(createdItem);
//     });

//     it('should handle errors from inventoryService by calling this.handleError', async () => {
//       const itemData = { sku: 'T2' };
//       // ErrorCodes.INVENTORY.INVALID_SKU_FORMAT is 'INVALID_SKU_FORMAT'
//       const serviceError = new InventoryError(ErrorCodes.INVENTORY.INVALID_SKU_FORMAT, "Bad SKU");
//       mockInventoryService.addItem.mockRejectedValue(serviceError);
//       inventoryModule.handleError = jest.fn(); // Spy on the module's own handleError

//       const mockRequest = { body: itemData, url: '/items' };
//       const mockReply = { code: jest.fn() };

//       await expect(inventoryModule.handleAddItem(mockRequest, mockReply)).rejects.toThrow(serviceError);
//       expect(inventoryModule.handleError).toHaveBeenCalledWith(serviceError, expect.any(Object));
//     });
//   });
  
//   // More tests for other handlers, lifecycle methods, error conditions, etc.
// });
```

---
## 8. Shared Utilities Reference
Foundational utilities in `src/core/common/`.

### 8.1. `SystemConstants.js`
#### 8.1.1. Purpose & Key Definitions
Defines `SYSTEM_STATUS`, `LIFECYCLE_EVENTS`, `DEFAULT_CONFIG`.

**`SystemConstants.js`**: Usage Example 
```javascript
// Example usage within a hypothetical core system component:
// import { SYSTEM_STATUS, LIFECYCLE_EVENTS, DEFAULT_CONFIG } from '../common/SystemConstants.js'; // Adjust path as needed

// class MySystem {
//   constructor(deps) {
//     this.deps = deps;
//     this.state = {
//       status: SYSTEM_STATUS.CREATED, // Using a constant for initial status
//       errors: [],
//       // ... other state properties
//     };
//     // Using a constant for a default configuration value
//     this.maxErrors = this.deps.config?.mySystem?.maxErrorHistory || DEFAULT_CONFIG.MAX_ERROR_HISTORY;
//   }

//   async initialize() {
//     if (this.state.status === SYSTEM_STATUS.RUNNING) return; // Comparing with a constant
//     this.state.status = SYSTEM_STATUS.INITIALIZING; // Setting status with a constant
//
//     // Emitting a standardized lifecycle event
//     // if (this.emit) { // Assuming 'this' is an EventEmitter
//     //   this.emit(LIFECYCLE_EVENTS.INITIALIZING, { system: this.constructor.name });
//     // }

//     // ... initialization logic ...

//     this.state.status = SYSTEM_STATUS.RUNNING;
//     // if (this.emit) {
//     //   this.emit(LIFECYCLE_EVENTS.INITIALIZED, { system: this.constructor.name });
//     //   this.emit(LIFECYCLE_EVENTS.RUNNING, { system: this.constructor.name });
//     // }
//   }

//   // ... other methods
// }
```

### 8.2. `ErrorUtils.js`
#### 8.2.1. Purpose & Key Functions
Provides `async safeHandleError()` and `createStandardHealthCheckResult()`.
#### 8.2.2. Usage Examples

**`ErrorUtils.js`**: Usage Examples
```javascript
// Example usage within a hypothetical core system or module:
// import { safeHandleError, createStandardHealthCheckResult } from '../common/ErrorUtils.js'; // Adjust path
// import { SYSTEM_STATUS } from '../common/SystemConstants.js'; // Adjust path
// import { CoreError } from '../errors/CoreError.js'; // Adjust path
// import { ErrorCodes } from '../errors/ErrorCodes.js'; // Adjust path
// import { ServiceError } from '../errors/types/ServiceError.js'; // Adjust path

// class MyComponent {
//   constructor(deps) {
//     this.deps = deps; // Should include errorSystem, logger, etc.
//     // this.state = { errors: [] }; // Standard state
//   }

//   async _handleInternalError(error, context = {}) { // Example internal error handler
//       // Ensure it's a CoreError or subclass. If not, wrap it.
//       // If it's a generic error within a service context, use ServiceError.
//       // ErrorCodes.SERVICE.OPERATION_FAILED is now 'OPERATION_FAILED'
//       const internalError = !(error instanceof CoreError)
//         ? new ServiceError(
//             ErrorCodes.SERVICE.OPERATION_FAILED, 
//             error.message,
//             context,
//             { cause: error }
//           ) 
//         : error; 
//       // internalError.code will be 'SERVICE_OPERATION_FAILED' if wrapped

//       // this.state.errors.push({ error: internalError, timestamp: new Date().toISOString(), context });
//       // ... (error array capping logic) ...
//       // this.recordMetric('mycomponent.errors.internal', 1, { errorName: internalError.name });
//       await safeHandleError(this.deps.errorSystem, internalError, { source: this.constructor.name, ...context });
//   }

//   async checkMySpecificFeature() { // Example health check function
//     let isFeatureHealthy = true;
//     let featureDetails = { status: 'online', version: '1.2.3' };
//     let encounteredErrors = [];

//     try {
//       // if (await this.someDependency.isUnresponsive()) {
//       //   isFeatureHealthy = false;
//       //   featureDetails.status = 'dependency_issue';
//       //   // ErrorCodes.SERVICE.UNAVAILABLE is now 'UNAVAILABLE'
//       //   encounteredErrors.push(new ServiceError(
//       //       ErrorCodes.SERVICE.UNAVAILABLE, 
//       //       'Dependency X is unresponsive.'
//       //   )); // ServiceError constructor will prepend 'SERVICE_'
//       // }
//     } catch (error) {
//       isFeatureHealthy = false;
//       featureDetails.error = error.message;
//       encounteredErrors.push(error);
//     }

//     return createStandardHealthCheckResult(
//       isFeatureHealthy ? SYSTEM_STATUS.HEALTHY : SYSTEM_STATUS.UNHEALTHY,
//       featureDetails,
//       encounteredErrors
//     );
//   }
// }
```

---
## 9. Conclusion & Future Directions

### 9.1. Summary of Achievements
The refactored TSMIS core architecture provides a robust, consistent, observable, and maintainable foundation by standardizing key aspects across core systems, enhancing developer experience and system stability.

### 9.2. Reinforcing the Standardization Pillars
Continued success depends on adherence to: Standard State, Standardized Error Handling (unprefixed codes in `ErrorCodes.js` for domains, subclass prefixing), Standardized Lifecycle, Standardized Health Monitoring, Standardized Metrics Tracking, and Clear Naming Conventions.

### 9.3. Future Directions & Potential Enhancements
* **`ContainerSystem`**: Scoped containers, advanced discovery, lazy initialization.
* **`ErrorSystem`**: Enhanced tracking/analytics, more integrations.
* **`EventBusSystem`**: Advanced routing, schema validation, distributed bus.
* **`ModuleSystem`**: Dynamic management, inter-module contracts, advanced DI options.
* **`RouterSystem`**: Advanced matching, more granular dynamic routing, deeper validation integration. The current dynamic routing capability via adapter refresh is a significant step for development workflows.
This standardized foundation enables structured evolution.


// src/core/errors/CoreError.js

/**
 * @file CoreError.js
 * @description Universal base error class for the application.
 */

import { SYSTEM_STATUS } from '../common/SystemConstants.js'; // Optional: if used for env checks

export class CoreError extends Error {
  /**
   * Creates a new CoreError instance.
   * @param {string} code - A unique error code, typically UPPER_SNAKE_CASE.
   * @param {string} message - A human-readable description of the error.
   * @param {object} [details={}] - An object containing additional error-specific information.
   * @param {object} [options={}] - Additional options.
   * @param {Error} [options.cause] - The original error that caused this error.
   */
  constructor(code, message, details = {}, options = {}) {
    super(message); // Pass message to the native Error class

    // Standard error properties
    this.name = this.constructor.name; // E.g., "CoreError", "ValidationError"
    this.code = code; // E.g., "VALIDATION_FAILED"
    this.details = this.sanitizeDetails(details); // Ensure details are serializable
    this.timestamp = new Date().toISOString();

    // Store the original cause of the error, if provided
    if (options.cause) {
      this.initCause(options.cause);
    }

    // Improve stack trace (if supported by the environment)
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }

    // Standard V8 property to control stack trace formatting (optional)
    // Error.prepareStackTrace = (error, structuredStackTrace) => { /* custom formatting */ };

    // Ensure 'instanceof' works correctly after extending native Error
    Object.setPrototypeOf(this, new.target.prototype);
  }

  /**
   * Initializes the error cause, ensuring it's a proper Error instance.
   * @private
   * @param {Error|object|string} cause - The potential cause of the error.
   */
  initCause(cause) {
    const ensureValidName = (errorInstance) => {
      if (!errorInstance.name || !String(errorInstance.name).trim()) {
        errorInstance.name = 'Error'; // Default if name is missing or empty
      }
      return errorInstance;
    };

    if (cause instanceof Error) {
      this.cause = ensureValidName(cause); // [cite: 198]
    } else if (cause && typeof cause === 'object' && cause !== null) {
      const err = new Error(cause.message || JSON.stringify(cause)); // [cite: 199]
      if (cause.name && typeof cause.name === 'string' && cause.name.trim()) {
        err.name = cause.name; // [cite: 200]
      }
      if (cause.stack) {
        err.stack = cause.stack;
      }
      this.cause = err;
    } else if (typeof cause === 'string') {
      this.cause = new Error(cause); // [cite: 201]
    }
  }

  /**
   * Sanitizes error details to ensure they are serializable and prevent sensitive data leakage.
   * @private
   * @param {object} details - The original details object.
   * @returns {object} The sanitized details object.
   */
  sanitizeDetails(details) {
    if (typeof details !== 'object' || details === null) {
      return {};
    }
    try {
      // Attempt to serialize to catch non-serializable values like functions or complex objects
      JSON.stringify(details); // [cite: 202]
      // In a real application, you might want to filter out sensitive keys here
      return details;
    } catch (error) {
      // If serialization fails, return a safe representation
      return { // [cite: 203]
        error: 'Details contained non-serializable or circular values.',
        originalDetailsType: typeof details,
        safeDetailsRepresentation: String(details).substring(0, 256) // Truncate potentially large strings
      };
    }
  }

  /**
   * Determines if the current environment is considered 'development' or 'test'.
   * This can influence aspects like stack trace inclusion in toJSON().
   * @private
   * @returns {boolean}
   */
  isDevEnvironment() {
    if (typeof process !== 'undefined' && process.env) {
      return process.env.NODE_ENV === 'development' || process.env.NODE_ENV === 'test'; // [cite: 207]
    }
    // Basic client-side check (can be expanded)
    if (typeof window !== 'undefined') {
      // You might have a global ENV variable set during build
      return window.ENV === 'development' || window.location.hostname === 'localhost'; // [cite: 208]
    }
    return false; // Default to false if environment cannot be determined
  }

  /**
   * Converts the error object to a JSON representation.
   * Stack trace is typically included only in development environments.
   * @returns {object} A plain object representation of the error.
   */
  toJSON() {
    const jsonError = {
      name: this.name,
      code: this.code,
      message: this.message,
      details: this.details,
      timestamp: this.timestamp,
    }; // [cite: 209]

    if (this.cause) {
      jsonError.cause = {
        name: this.cause.name || 'Error', // [cite: 211]
        message: this.cause.message,
        // Optionally include code and details from the cause if they exist
        ...(this.cause.code && { code: this.cause.code }),
        ...(this.cause.details && { details: this.cause.details }),
      };
      if (this.isDevEnvironment() && this.cause.stack) {
        jsonError.cause.stack = this.cause.stack.split('\n'); // [cite: 212]
      }
    }

    if (this.isDevEnvironment() && this.stack) {
      jsonError.stack = this.stack.split('\n'); // [cite: 210]
    }

    return jsonError; // [cite: 213]
  }

  /**
   * Creates a CoreError (or a subclass) instance from a JSON-like object.
   * Useful for deserializing errors, e.g., from an API response.
   * @static
   * @param {object} data - The plain object containing error data.
   * @param {typeof CoreError} [ErrorType=CoreError] - The specific error class to instantiate. Defaults to CoreError.
   * @returns {CoreError} An instance of CoreError or its subclass.
   */
  static fromJSON(data, ErrorType = CoreError) {
    if (!data || typeof data !== 'object') {
      return new ErrorType(
        'DESERIALIZATION_FAILED',
        'Invalid data provided for error deserialization.',
        { providedData: data }
      );
    }

    const { code, message, details, cause: causeData, name } = data;
    const options = {};

    if (causeData) {
      if (typeof causeData === 'string') {
        options.cause = new Error(causeData); // [cite: 215]
      } else if (typeof causeData === 'object' && causeData !== null) {
        const reconstructedCause = new Error(causeData.message || 'Caused by an unspecified error.');
        reconstructedCause.name = causeData.name || 'Error'; // [cite: 216]
        if (causeData.code) reconstructedCause.code = causeData.code;
        // Note: Cause's own 'details' and 'stack' are not typically reconstructed deeply here
        // to avoid complexity, but could be if needed.
        options.cause = reconstructedCause;
      }
    }

    const errorInstance = new ErrorType(
      code || 'UNKNOWN_ERROR',
      message || 'An unspecified error occurred.',
      details || {},
      options
    ); // [cite: 217]

    // Restore original name if it was different (e.g. "ValidationError" from data)
    // and the ErrorType is the generic CoreError.
    if (name && ErrorType === CoreError && errorInstance.name !== name) {
        errorInstance.name = name;
    }

    return errorInstance;
  }
}


// src/core/errors/ErrorCodes.js

/**
 * @file ErrorCodes.js
 * @description Standardized error codes for the TSMIS application.
 * Domain-specific codes (outside of CORE) are unprefixed here;
 * the respective CoreError subclasses will prepend the domain.
 */

export const ErrorCodes = Object.freeze({
  // --- Generic Core System Errors (values are full codes) ---
  CORE: Object.freeze({
    UNKNOWN_ERROR: 'CORE_UNKNOWN_ERROR',
    INTERNAL_ERROR: 'CORE_INTERNAL_ERROR', // For unexpected internal issues
    INITIALIZATION_FAILED: 'CORE_INITIALIZATION_FAILED',
    ALREADY_INITIALIZED: 'CORE_ALREADY_INITIALIZED',
    NOT_INITIALIZED: 'CORE_NOT_INITIALIZED',
    SHUTDOWN_FAILED: 'CORE_SHUTDOWN_FAILED',
    VALIDATION_FAILED: 'CORE_VALIDATION_FAILED', // General validation failure
    INVALID_ARGUMENT: 'CORE_INVALID_ARGUMENT', // For invalid function/method arguments
    INVALID_OPERATION: 'CORE_INVALID_OPERATION', // Operation not allowed in current state
    INVALID_TYPE: 'CORE_INVALID_TYPE', // General type mismatch
    INVALID_HANDLER: 'CORE_INVALID_HANDLER', // Handler function is not valid
    INTEGRATION_FAILED: 'CORE_INTEGRATION_FAILED', // Generic failure with an external integration
    NOT_IMPLEMENTED: 'CORE_NOT_IMPLEMENTED', // Feature or method not implemented
    DEPRECATED: 'CORE_DEPRECATED', // Feature or method is deprecated
    RESOURCE_NOT_FOUND: 'CORE_RESOURCE_NOT_FOUND', // Generic resource not found
  }),

  // --- Configuration System Errors (unprefixed values) ---
  CONFIG: Object.freeze({
    LOAD_FAILED: 'LOAD_FAILED',
    SAVE_FAILED: 'SAVE_FAILED',
    VALIDATION_FAILED: 'VALIDATION_FAILED', // Specific to config validation
    MISSING_REQUIRED_FIELD: 'MISSING_REQUIRED_FIELD',
    INVALID_FIELD_TYPE: 'INVALID_FIELD_TYPE',
    INVALID_ENUM_VALUE: 'INVALID_ENUM_VALUE',
    PATTERN_MISMATCH: 'PATTERN_MISMATCH',
    INVALID_CONFIG_OBJECT: 'INVALID_CONFIG_OBJECT', // If config itself is not an object
    DUPLICATE_MANIFEST: 'DUPLICATE_MANIFEST', // Container specific
    DUPLICATE_COMPONENT: 'DUPLICATE_COMPONENT', // Container specific
    MISSING_DEPENDENCY: 'MISSING_DEPENDENCY', // Container specific: component dependency
    CIRCULAR_DEPENDENCY: 'CIRCULAR_DEPENDENCY', // Container specific
    MANIFEST_TYPE_NOT_FOUND: 'MANIFEST_TYPE_NOT_FOUND', // Container specific
  }),

  // --- Service & Component Errors (unprefixed values) ---
  SERVICE: Object.freeze({
    UNKNOWN_COMPONENT: 'UNKNOWN_COMPONENT', // Container specific
    COMPONENT_LOAD_FAILED: 'COMPONENT_LOAD_FAILED', // Container specific
    IMPLEMENTATION_LOAD_FAILED: 'IMPLEMENTATION_LOAD_FAILED', // Container specific
    DISCOVERY_FAILED: 'DISCOVERY_FAILED', // Container specific
    DIRECTORY_SCAN_FAILED: 'DIRECTORY_SCAN_FAILED', // Container specific
    OPERATION_FAILED: 'OPERATION_FAILED', // Generic service operation failure
    EXTERNAL_API_ERROR: 'EXTERNAL_API_ERROR',
    DATABASE_ERROR: 'DATABASE_ERROR',
    CACHE_ERROR: 'CACHE_ERROR',
    UNAVAILABLE: 'UNAVAILABLE', // Service is not available
    // Note: Original ErrorCodes.js SERVICE had INITIALIZATION_FAILED, ALREADY_INITIALIZED, NOT_INITIALIZED, SHUTDOWN_FAILED
    // These are now primarily under CORE or specific systems (like EVENT, MODULE, ROUTER) for their own lifecycle.
    // If needed for a generic "Service" component that's not a full system, they could be added here (unprefixed).
  }),

  // --- Event System Errors (unprefixed values) ---
  EVENT: Object.freeze({
    INTERNAL_ERROR: 'INTERNAL_ERROR',
    INITIALIZATION_FAILED: 'INITIALIZATION_FAILED', // Specific to Event system
    ALREADY_INITIALIZED: 'ALREADY_INITIALIZED', // Specific to Event system
    NOT_INITIALIZED: 'NOT_INITIALIZED', // Specific to Event system
    SHUTDOWN_FAILED: 'SHUTDOWN_FAILED', // Specific to Event system
    MISSING_DEPENDENCIES: 'MISSING_DEPENDENCIES', // For EventBus/System deps
    INVALID_DEPENDENCY: 'INVALID_DEPENDENCY', // For EventBus/System deps
    INVALID_EVENT_NAME: 'INVALID_EVENT_NAME',
    INVALID_HANDLER: 'INVALID_HANDLER', // Handler function validation
    INVALID_PATTERN: 'INVALID_PATTERN', // Subscription pattern validation
    EMISSION_FAILED: 'EMISSION_FAILED',
    SUBSCRIPTION_FAILED: 'SUBSCRIPTION_FAILED',
    HANDLER_NOT_FOUND: 'HANDLER_NOT_FOUND', // For unsubscribe if ID not found
    HANDLER_ERROR: 'HANDLER_ERROR', // Error *thrown by* an event handler
    QUEUE_OPERATION_FAILED: 'QUEUE_OPERATION_FAILED', // Generic queue add/remove issue
    QUEUE_PROCESSING_FAILED: 'QUEUE_PROCESSING_FAILED', // Error during processQueue
    LEGACY_WILDCARD_FORWARD: 'LEGACY_WILDCARD_FORWARD', // Specific internal diagnostic
  }),

  // --- Module System Errors (unprefixed values) ---
  MODULE: Object.freeze({
    INTERNAL_ERROR: 'INTERNAL_ERROR', // CoreModule internal
    SYSTEM_ERROR: 'SYSTEM_ERROR', // ModuleSystem internal
    INITIALIZATION_FAILED: 'INITIALIZATION_FAILED', // Specific to Module system/instance
    ALREADY_INITIALIZED: 'ALREADY_INITIALIZED', // Specific to Module system/instance
    NOT_INITIALIZED: 'NOT_INITIALIZED', // Specific to Module system/instance
    SHUTDOWN_FAILED: 'SHUTDOWN_FAILED', // Specific to Module system/instance
    MISSING_DEPENDENCIES: 'MISSING_DEPENDENCIES', // For Module deps
    INVALID_DEPENDENCY: 'INVALID_DEPENDENCY', // For Module deps
    DEPENDENCY_NOT_READY: 'DEPENDENCY_NOT_READY',
    DEPENDENCY_RESOLUTION_FAILED: 'DEPENDENCY_RESOLUTION_FAILED', // Added for clarity
    CONFIG_VALIDATION_FAILED: 'CONFIG_VALIDATION_FAILED',
    INVALID_HEALTH_CHECK: 'INVALID_HEALTH_CHECK',
    HEALTH_CHECK_FAILED: 'HEALTH_CHECK_FAILED', // Error *executing* a health check
    UNHEALTHY: 'UNHEALTHY', // Module reported unhealthy status
    OPERATION_FAILED: 'OPERATION_FAILED', // Generic failure in a module's business logic
    DUPLICATE_MODULE: 'DUPLICATE_MODULE', // ModuleSystem: registration
    REGISTRATION_FAILED: 'REGISTRATION_FAILED', // ModuleSystem: registration
    UNREGISTER_FAILED: 'UNREGISTER_FAILED', // ModuleSystem: unregistration
    NOT_FOUND: 'NOT_FOUND', // ModuleSystem: resolve
    CIRCULAR_DEPENDENCY: 'CIRCULAR_DEPENDENCY', // ModuleSystem: dependency order
    INVALID_MODULE: 'INVALID_MODULE', // Added for type validation (e.g. not extending CoreModule)
  }),

  // --- Router System Errors (unprefixed values) ---
  ROUTER: Object.freeze({
    SYSTEM_INTERNAL_ERROR: 'SYSTEM_INTERNAL_ERROR', // RouterSystem internal
    INTERNAL_SYSTEM_ERROR: 'INTERNAL_SYSTEM_ERROR', // CoreRouter internal (distinguish if needed)
    INITIALIZATION_FAILED: 'INITIALIZATION_FAILED', // Specific to Router system/instance
    ALREADY_INITIALIZED: 'ALREADY_INITIALIZED', // Specific to Router system/instance
    NOT_INITIALIZED: 'NOT_INITIALIZED', // Specific to Router system/instance
    SHUTDOWN_FAILED: 'SHUTDOWN_FAILED', // Specific to Router system/instance
    CREATION_FAILED: 'CREATION_FAILED', // For factory function issues
    MISSING_DEPENDENCIES: 'MISSING_DEPENDENCIES',
    INVALID_DEPENDENCY: 'INVALID_DEPENDENCY',
    INVALID_FRAMEWORK: 'INVALID_FRAMEWORK', // Added for clarity
    INVALID_MODULE_ID: 'INVALID_MODULE_ID',
    INVALID_METHOD: 'INVALID_METHOD',
    INVALID_PATH: 'INVALID_PATH',
    INVALID_HANDLER: 'INVALID_HANDLER', // Handler function for a route
    INVALID_PAYLOAD: 'INVALID_PAYLOAD', // e.g. event payload missing data
    INVALID_API_VERSION: 'INVALID_API_VERSION',
    ROUTE_CONFLICT: 'ROUTE_CONFLICT',
    ROUTE_REGISTRATION_FAILED: 'ROUTE_REGISTRATION_FAILED',
    ROUTE_UNREGISTRATION_FAILED: 'ROUTE_UNREGISTRATION_FAILED',
    MODULE_UNREGISTRATION_FAILED: 'MODULE_UNREGISTRATION_FAILED',
    ROUTES_APPLICATION_FAILED: 'ROUTES_APPLICATION_FAILED',
    ADAPTER_NOT_FOUND: 'ADAPTER_NOT_FOUND',
    INVALID_ADAPTER: 'INVALID_ADAPTER',
    INVALID_ADAPTER_NAME: 'INVALID_ADAPTER_NAME',
    INVALID_MIDDLEWARE: 'INVALID_MIDDLEWARE',
    INVALID_MIDDLEWARE_NAME: 'INVALID_MIDDLEWARE_NAME',
    INVALID_HEALTH_CHECK: 'INVALID_HEALTH_CHECK', // If router system has own health checks
  }),

  // --- Specific Error Type Codes (unprefixed values, used by respective Error classes) ---
  VALIDATION: Object.freeze({ // Used by ValidationError
    INVALID_INPUT: 'INVALID_INPUT',
    SCHEMA_MISMATCH: 'SCHEMA_MISMATCH',
    REQUIRED_FIELD: 'REQUIRED_FIELD',
    TYPE_ERROR: 'TYPE_ERROR',
    ENUM_MISMATCH: 'ENUM_MISMATCH',
    PATTERN_ERROR: 'PATTERN_ERROR',
    CUSTOM_VALIDATION_FAILED: 'CUSTOM_VALIDATION_FAILED',
    FAILED: 'FAILED', // General catch-all for validation if not more specific
  }),

  NETWORK: Object.freeze({ // Used by NetworkError
    REQUEST_FAILED: 'REQUEST_FAILED',
    RESPONSE_ERROR: 'RESPONSE_ERROR',
    TIMEOUT: 'TIMEOUT',
    CONNECTION_REFUSED: 'CONNECTION_REFUSED',
    HOST_UNREACHABLE: 'HOST_UNREACHABLE',
    DNS_LOOKUP_FAILED: 'DNS_LOOKUP_FAILED',
    SSL_ERROR: 'SSL_ERROR',
    ROUTE_NOT_FOUND: 'ROUTE_NOT_FOUND', // For 404s from external calls
  }),

  AUTH: Object.freeze({ // Used by AuthError (Authentication)
    UNAUTHORIZED: 'UNAUTHORIZED',
    INVALID_CREDENTIALS: 'INVALID_CREDENTIALS',
    TOKEN_EXPIRED: 'TOKEN_EXPIRED',
    TOKEN_INVALID: 'TOKEN_INVALID',
    TOKEN_MISSING: 'TOKEN_MISSING',
    ACCOUNT_LOCKED: 'ACCOUNT_LOCKED',
    ACCOUNT_DISABLED: 'ACCOUNT_DISABLED',
    MFA_REQUIRED: 'MFA_REQUIRED',
    MFA_FAILED: 'MFA_FAILED',
  }),

  ACCESS: Object.freeze({ // Used by AccessError (Authorization)
    FORBIDDEN: 'FORBIDDEN',
    INSUFFICIENT_PERMISSIONS: 'INSUFFICIENT_PERMISSIONS',
    RESOURCE_OWNERSHIP_REQUIRED: 'RESOURCE_OWNERSHIP_REQUIRED',
    RATE_LIMIT_EXCEEDED: 'RATE_LIMIT_EXCEEDED',
    FEATURE_NOT_ENABLED: 'FEATURE_NOT_ENABLED',
  }),
});


// src/core/errors/ErrorSystem.js

/**
 * @file ErrorSystem.js
 * @description Manages error types, framework integrations, and centralized error handling.
 */

import { EventEmitter } from 'events';
import { CoreError } from './CoreError.js';
import * as ErrorTypes from './types/index.js'; // Assuming types/index.js exports all named error types
import { ErrorCodes } from './ErrorCodes.js'; // Assuming ErrorCodes are in their own file
// import { FastifyErrorHandler } from './integrations/fastify/FastifyErrorHandler.js'; // Not used directly, registered via registerIntegration
import { SYSTEM_STATUS, LIFECYCLE_EVENTS, DEFAULT_CONFIG } from '../common/SystemConstants.js';
import { safeHandleError, createStandardHealthCheckResult } from '../common/ErrorUtils.js';

export class ErrorSystem extends EventEmitter {
  static dependencies = ['logger', 'config']; // config might be used for maxErrorHistory etc.
  static version = '2.0.0'; // Example version bump

  /**
   * Creates a new ErrorSystem instance.
   * @param {object} [deps={}] - Dependencies for the ErrorSystem.
   * @param {object} [deps.logger=console] - Logger instance.
   * @param {object} [deps.config={}] - Configuration object.
   */
  constructor(deps = {}) {
    super();
    this.deps = {
      logger: deps.logger || console,
      config: deps.config || {},
      // ErrorSystem does not depend on itself for safeHandleError
    };

    this.errorTypes = new Map(Object.entries(ErrorTypes.ErrorTypes || ErrorTypes)); // Access ErrorTypes from the imported namespace
    this.customHandlers = new Map(); // Renamed from 'handlers' to be more specific
    this.integrations = new Map();
    // this.initialized = false; // Will be driven by state.status // This line was commented in original, keeping it so.

    this.state = {
      status: SYSTEM_STATUS.CREATED,
      startTime: null,
      errors: [], // For internal errors of ErrorSystem
      metrics: new Map(),
      healthChecks: new Map(),
    };
    // Ensure a default handler is always present for unhandled CoreErrors
    this.registerHandler(CoreError.name, this.defaultCoreErrorHandler.bind(this));
    // More specific default
    this.registerHealthCheck('errorsystem.state', this.checkSystemState.bind(this));
    this.registerHealthCheck('errorsystem.handlers', this.checkHandlerStatus.bind(this));
    this.registerHealthCheck('errorsystem.integrations', this.checkIntegrationStatus.bind(this));
  }

  /**
   * Initializes the ErrorSystem.
   * Validates error types and sets up the system.
   * @returns {Promise<ErrorSystem>}
   */
  async initialize() {
    if (this.state.status === SYSTEM_STATUS.RUNNING || this.state.status === SYSTEM_STATUS.INITIALIZING) {
      // Use internal handler for this operational error
      const err = new CoreError(
        ErrorCodes.CORE.ALREADY_INITIALIZED, // Using CORE prefixed code
        'ErrorSystem is already initialized or initializing.'
      );
      await this._handleInternalError(err, { currentStatus: this.state.status });
      return this; // Or throw err if preferred
    }

    this.emit(LIFECYCLE_EVENTS.INITIALIZING, { system: 'ErrorSystem' });
    this.state.status = SYSTEM_STATUS.INITIALIZING;
    this.state.startTime = Date.now();

    try {
      // Validate registered error types
      for (const [name, ErrorTypeClass] of this.errorTypes) {
        if (!(ErrorTypeClass.prototype instanceof CoreError)) {
          throw new CoreError(
            ErrorCodes.CORE.INVALID_TYPE, // Using CORE prefixed code
            `Registered error type '${name}' must extend CoreError.`
          );
        }
      }

      // Potentially initialize default integrations if specified in config
      // Example: if (this.deps.config.errorSystem?.defaultIntegration === 'fastify') { ... }

      // this.initialized = true; // Redundant with state.status but kept for current compatibility // This line was commented in original
      this.state.status = SYSTEM_STATUS.RUNNING;
      this.recordMetric('errorsystem.initialized.success', 1, { timestamp: Date.now() });
      this.emit(LIFECYCLE_EVENTS.INITIALIZED, { system: 'ErrorSystem', timestamp: new Date().toISOString() });
      this.emit(LIFECYCLE_EVENTS.RUNNING, { system: 'ErrorSystem', timestamp: new Date().toISOString() });


    } catch (error) {
      this.state.status = SYSTEM_STATUS.ERROR;
      this.recordMetric('errorsystem.initialized.failure', 1, { error: error.code, timestamp: Date.now() });
      await this._handleInternalError(error, { phase: 'initialization' });
      // Re-throw to signal catastrophic failure of ErrorSystem initialization
      throw error instanceof CoreError ?
      error : new CoreError(
        ErrorCodes.CORE.INITIALIZATION_FAILED, // Using CORE prefixed code
        'ErrorSystem failed to initialize.',
        { originalMessage: error.message },
        { cause: error }
      );
    }
    return this;
  }

  /**
   * Registers a specific error handler for a given error type name.
   * @param {string} errorTypeName - The name of the error class (e.g., 'ValidationError', 'CoreError').
   * @param {Function} handler - The async function to handle the error: async (error, context) => {}.
   */
  registerHandler(errorTypeName, handler) {
    if (typeof handler !== 'function') {
      const err = new CoreError(ErrorCodes.CORE.INVALID_HANDLER, 'Error handler must be a function.', { errorTypeName }); // Using CORE prefixed code
      this._handleInternalError(err); // Log internal error
      throw err; // Throw for immediate feedback
    }
    if (typeof errorTypeName !== 'string' || !errorTypeName.trim()) {
        const err = new CoreError(ErrorCodes.CORE.INVALID_TYPE, 'Error type name must be a non-empty string.', { handlerName: handler.name }); // Using CORE prefixed code
        this._handleInternalError(err);
        throw err;
    }
    this.customHandlers.set(errorTypeName, handler);
    this.recordMetric('errorsystem.handlers.registered', 1, { errorTypeName });
  }

  /**
   * Registers and initializes a framework integration.
   * @param {string} integrationName - A name for the integration (e.g., 'fastify').
   * @param {IFrameworkIntegration} IntegrationClass - The class for the framework integration (e.g., FastifyErrorHandler).
   * @param {object} frameworkInstance - The instance of the web framework (e.g., Fastify app).
   * @param {object} [options={}] - Options to pass to the integration's initialize method.
   * @returns {Promise<object>} The initialized integration instance.
   */
  async registerIntegration(integrationName, IntegrationClass, frameworkInstance, options = {}) {
    if (!integrationName || typeof integrationName !== 'string') {
        const err = new CoreError(ErrorCodes.CORE.INVALID_ARGUMENT, 'Integration name must be a non-empty string.'); // Using CORE prefixed code
        await this._handleInternalError(err);
        throw err;
    }
    if (!IntegrationClass || typeof IntegrationClass !== 'function' || !IntegrationClass.prototype || typeof IntegrationClass.prototype.initialize !== 'function') {
        const err = new CoreError(ErrorCodes.CORE.INVALID_ARGUMENT, `IntegrationClass for '${integrationName}' is invalid or does not have an initialize method.`); // Using CORE prefixed code
        await this._handleInternalError(err);
        throw err;
    }
     if (!frameworkInstance) {
        const err = new CoreError(ErrorCodes.CORE.INVALID_ARGUMENT, `Framework instance for '${integrationName}' is required.`); // Using CORE prefixed code
        await this._handleInternalError(err);
        throw err;
    }

    try {
      const integration = new IntegrationClass(this); // Pass ErrorSystem instance if needed by integration
      await integration.initialize(frameworkInstance, options); // Ensure initialize is async if it does async work
      this.integrations.set(integrationName, integration);
      this.recordMetric('errorsystem.integrations.registered', 1, { integrationName });
      return integration;
    } catch (error) {
      const err = new CoreError(
          ErrorCodes.CORE.INTEGRATION_FAILED, // Using CORE prefixed code
          `Failed to register or initialize integration '${integrationName}'.`,
          { integrationName, originalMessage: error.message },
          { cause: error }
      );
      await this._handleInternalError(err);
      throw err;
    }
  }


  /**
   * Handles an error by finding the appropriate registered handler or using the default.
   * @param {Error} error - The error object. Ideally an instance of CoreError or its subclass.
   * @param {object} [context={}] - Additional context about where/how the error occurred.
   */
  async handleError(error, context = {}) {
    this.recordMetric('errorsystem.errors.received', 1, { errorName: error.name, errorCode: error.code });
    // Ensure the error is a CoreError or subclass, or wrap it.
    let processedError = error;
    if (!(error instanceof CoreError)) {
      this.deps.logger.warn('[ErrorSystem] Received non-CoreError. Wrapping it:', { originalError: error, context });
      processedError = new CoreError(
        ErrorCodes.CORE.UNKNOWN_ERROR, // CHANGED: Was ErrorCodes.CORE.UNKNOWN
        error.message || 'An unknown error occurred.',
        { originalErrorName: error.name, context },
        { cause: error }
      );
    }

    // Find the most specific handler
    let handler = this.customHandlers.get(processedError.constructor.name) ||
                  this.customHandlers.get(CoreError.name); // Fallback to default CoreError handler

    if (!handler) {
        // This should ideally not happen if CoreError.name handler is always registered
        this.deps.logger.error('[ErrorSystem] No default CoreError handler found. Logging directly.', {
            error: processedError.toJSON(), // Use toJSON for structured logging
            context
        });
        this.emit('error:unhandled', { error: processedError, context }); //
        return;
    }

    try {
      await handler(processedError, context);
      this.emit('error:handled', { error: processedError, context, handler: handler.name }); //
    } catch (handlerError) {
      this.deps.logger.error('[ErrorSystem] Error handler itself failed:', {
        handlerName: handler.name,
        originalError: processedError.toJSON(),
        handlerError: (handlerError instanceof CoreError) ? handlerError.toJSON() : { message: handlerError.message, name: handlerError.name },
        context
      });
      this.emit('error:handler_failed', { error: handlerError, originalError: processedError, context }); //
      // Decide if handlerError should be re-thrown or if ErrorSystem absorbs it
    }
  }

  /**
   * Default handler for CoreError instances if no more specific handler is found.
   * @private
   */
  defaultCoreErrorHandler(error, context = {}) {
    this.deps.logger.error(`[ErrorSystem DefaultHandler] Unhandled CoreError:`, {
      error: error.toJSON(), // Use toJSON for structured logging
      context,
      timestamp: new Date().toISOString()
    });
  }

  /**
   * Creates an instance of a registered error type.
   * @param {string} typeName - The name of the error type (e.g., 'ValidationError').
   * @param {string} code - The specific, **unprefixed** error code from `ErrorCodes.DOMAIN.CODE`.
   * @param {string} message - The error message.
   * @param {object} [details={}] - Additional error details.
   * @param {object} [options={}] - Error options, including 'cause'.
   * @returns {CoreError} An instance of the specified error type, or CoreError if type not found.
   */
  createError(typeName, code, message, details = {}, options = {}) {
    const ErrorTypeClass = this.errorTypes.get(typeName) || CoreError;
    // If ErrorTypeClass is CoreError itself and typeName was different, it means the specific type wasn't found.
    // The 'code' for specific errors (passed to subclass constructors) should be the unprefixed part.
    // The subclass constructor will add the prefix.
    // If ErrorTypeClass is CoreError, the 'code' argument should be the full, prefixed code.
    if (ErrorTypeClass === CoreError && typeName !== CoreError.name) {
        this.deps.logger.warn(`[ErrorSystem] createError: Type '${typeName}' not found, defaulting to CoreError. Ensure code '${code}' is fully prefixed if intended for CoreError.`);
    }
    return new ErrorTypeClass(code, message, details, options);
  }

  /**
   * Gracefully shuts down the ErrorSystem.
   * @returns {Promise<void>}
   */
  async shutdown() {
    if (this.state.status === SYSTEM_STATUS.SHUTDOWN || this.state.status === SYSTEM_STATUS.SHUTTING_DOWN) {
      return;
    }
    this.emit(LIFECYCLE_EVENTS.SHUTTING_DOWN, { system: 'ErrorSystem' });
    this.state.status = SYSTEM_STATUS.SHUTTING_DOWN;
    try {
      // Perform any cleanup for integrations if they have a shutdown method
      for (const [name, integration] of this.integrations) {
        if (typeof integration.shutdown === 'function') {
          await integration.shutdown();
        }
      }
      this.integrations.clear();
      this.customHandlers.clear();
      // this.errorTypes.clear(); // Usually, error type definitions are static and don't need clearing

      this.removeAllListeners(); // Clear all event listeners for this ErrorSystem instance

      // this.initialized = false; // This line was commented in original
      this.state.status = SYSTEM_STATUS.SHUTDOWN;
      this.recordMetric('errorsystem.shutdown.success', 1, { timestamp: Date.now() });
      // Cannot emit shutdown if all listeners are removed, log instead or emit before removeAllListeners
      this.deps.logger.info('[ErrorSystem] Shutdown complete.');
      // If you want to emit a shutdown event, do it before removeAllListeners()
      // this.emit(LIFECYCLE_EVENTS.SHUTDOWN, { system: 'ErrorSystem', timestamp: new Date().toISOString() });
    } catch (error) {
      this.state.status = SYSTEM_STATUS.ERROR;
      this.recordMetric('errorsystem.shutdown.failure', 1, { error: error.code, timestamp: Date.now() });
      // Use console.error directly as _handleInternalError might try to use parts of a shutdown system
      console.error('[ErrorSystem] Shutdown failed:', error);
      // Do not re-throw during shutdown of ErrorSystem itself unless absolutely necessary
    }
  }

  // --- State, Health, Metrics ---
  /**
   * Handles internal operational errors of the ErrorSystem.
   * @private
   */
  async _handleInternalError(error, context = {}) {
    const internalError = !(error instanceof CoreError) ?
      new CoreError(ErrorCodes.CORE.INTERNAL_ERROR, error.message, context, { cause: error }) : // CHANGED: Was ErrorCodes.CORE.INTERNAL
      error;

    this.state.errors.push({ error: internalError, timestamp: new Date().toISOString(), context });
    if (this.state.errors.length > (this.deps.config?.maxErrorHistory || DEFAULT_CONFIG.MAX_ERROR_HISTORY)) {
      this.state.errors.shift();
    }
    // Log directly to prevent loops if ErrorSystem.handleError is itself broken
    this.deps.logger.error('[ErrorSystem Internal]', internalError.toJSON());
  }

  recordMetric(name, value, tags = {}) {
    this.state.metrics.set(name, { value, timestamp: Date.now(), tags });
  }

  getMetrics() {
    const metrics = {};
    for (const [name, data] of this.state.metrics) {
      metrics[name] = data;
    }
    return metrics;
  }

  registerHealthCheck(name, checkFn) {
    if (typeof checkFn !== 'function') {
        const err = new CoreError(ErrorCodes.CORE.INVALID_HANDLER, `Health check '${name}' must be a function.`); // Using CORE prefixed code
        this._handleInternalError(err);
        throw err;
    }
    this.state.healthChecks.set(name, checkFn);
  }

  async checkHealth() {
    const results = {};
    let overallStatus = SYSTEM_STATUS.HEALTHY;

    for (const [name, checkFn] of this.state.healthChecks) {
      try {
        const checkResult = await checkFn(); // Expects { status, detail, errors }
        results[name] = checkResult;
        if (checkResult.status !== SYSTEM_STATUS.HEALTHY) {
          // If any check is unhealthy, the system might be degraded or unhealthy
          overallStatus = (overallStatus === SYSTEM_STATUS.HEALTHY) ?
          SYSTEM_STATUS.DEGRADED : SYSTEM_STATUS.UNHEALTHY;
          if (checkResult.status === SYSTEM_STATUS.UNHEALTHY) overallStatus = SYSTEM_STATUS.UNHEALTHY;
        }
      } catch (error) {
        results[name] = createStandardHealthCheckResult(SYSTEM_STATUS.UNHEALTHY, { error: 'Health check threw an exception' }, [error]);
        overallStatus = SYSTEM_STATUS.UNHEALTHY;
      }
    }

    return {
      name: this.constructor.name,
      version: ErrorSystem.version,
      status: overallStatus,
      timestamp: new Date().toISOString(),
      uptime: this.state.startTime ? Date.now() - this.state.startTime : 0,
      errorCount: this.state.errors.length,
      checks: results,
    };
  }

  async checkSystemState() {
    return createStandardHealthCheckResult(
      this.state.status === SYSTEM_STATUS.RUNNING ? SYSTEM_STATUS.HEALTHY : SYSTEM_STATUS.UNHEALTHY,
      {
        status: this.state.status,
        uptime: this.state.startTime ? Date.now() - this.state.startTime : 0,
        internalErrorCount: this.state.errors.length
      }
    );
  }

  async checkHandlerStatus() {
    return createStandardHealthCheckResult(SYSTEM_STATUS.HEALTHY, {
      customHandlerCount: this.customHandlers.size,
      registeredHandlerKeys: Array.from(this.customHandlers.keys())
    });
  }

  async checkIntegrationStatus() {
    const integrationDetails = {};
    let allIntegrationsHealthy = true;
    for (const [name, integration] of this.integrations) {
        if (typeof integration.checkHealth === 'function') {
            try {
                const iHealth = await integration.checkHealth();
                integrationDetails[name] = iHealth;
                if (iHealth.status !== SYSTEM_STATUS.HEALTHY) allIntegrationsHealthy = false;
            } catch (e) {
                integrationDetails[name] = createStandardHealthCheckResult(SYSTEM_STATUS.UNHEALTHY, { error: 'Integration health check failed' }, [e]);
                allIntegrationsHealthy = false;
            }
        } else {
            integrationDetails[name] = createStandardHealthCheckResult(SYSTEM_STATUS.HEALTHY, { status: 'No health check available' });
        }
    }
    return createStandardHealthCheckResult(
      allIntegrationsHealthy ? SYSTEM_STATUS.HEALTHY : SYSTEM_STATUS.DEGRADED,
      {
        integrationCount: this.integrations.size,
        registeredIntegrationKeys: Array.from(this.integrations.keys()),
        details: integrationDetails
      }
    );
  }

  getSystemStatus() { // For consistency with other systems if they have this
    return {
        name: this.constructor.name,
        version: ErrorSystem.version,
        status: this.state.status,
        uptime: this.state.startTime ? Date.now() - this.state.startTime : 0,
        initialized: this.state.status === SYSTEM_STATUS.RUNNING,
        errorCount: this.state.errors.length,
        timestamp: new Date().toISOString()
    };
  }
}

/**
 * Factory function for creating an ErrorSystem instance.
 * @param {object} [deps={}] - Dependencies for the ErrorSystem.
 * @returns {ErrorSystem}
 */
export function createErrorSystem(deps = {}) {
  return new ErrorSystem(deps);
}


// src/core/errors/error-system.md

# TSMIS Error Handling System Documentation
Version: 2.1.0 (Refactored Core)

## Table of Contents

1.  [Introduction to the Error Handling System](#1-introduction-to-the-error-handling-system)
    * [1.1. Purpose & Philosophy](#11-purpose--philosophy)
    * [1.2. Key Components & Their Roles](#12-key-components--their-roles)
    * [1.3. Core Dependencies (System-Wide)](#13-core-dependencies-system-wide)
    * [1.4. Architectural Flow](#14-architectural-flow)
2.  [Component: `CoreError.js` - The Foundational Error Class](#2-component-coreerrorjs---the-foundational-error-class)
    * [2.1. Overview](#21-overview)
    * [2.2. Purpose & Key Features](#22-purpose--key-features)
    * [2.3. API Reference (`CoreError`)](#23-api-reference-coreerror)
        * [2.3.1. Constructor](#231-constructor)
        * [2.3.2. Instance Properties](#232-instance-properties)
        * [2.3.3. Instance Methods](#233-instance-methods)
        * [2.3.4. Static Methods](#234-static-methods)
    * [2.4. State Management](#24-state-management)
    * [2.5. Lifecycle Management](#25-lifecycle-management)
    * [2.6. Error Handling (Usage Context)](#26-error-handling-usage-context)
    * [2.7. Event Integration](#27-event-integration)
    * [2.8. Health Monitoring](#28-health-monitoring)
    * [2.9. Metrics Tracking](#29-metrics-tracking)
    * [2.10. Integrations (How CoreError is Used)](#210-integrations-how-coreerror-is-used)
    * [2.11. Usage Examples & Best Practices](#211-usage-examples--best-practices)
    * [2.12. Testing Strategy Notes](#212-testing-strategy-notes)
3.  [Component: Specialized Error Types (`src/core/errors/types/`)](#3-component-specialized-error-types-srccoreerrorstypes)
    * [3.1. Overview and Purpose](#31-overview-and-purpose)
    * [3.2. Common Pattern & Extension of `CoreError`](#32-common-pattern--extension-of-coreerror)
    * [3.3. Key Individual Error Types (Brief Descriptions & Purpose)](#33-key-individual-error-types-brief-descriptions--purpose)
        * [`AccessError.js`](#accesserrorjs)
        * [`AuthError.js`](#autherrorjs)
        * [`ConfigError.js`](#configerrorjs)
        * [`EventError.js`](#eventerrorjs)
        * [`ModuleError.js`](#moduleerrorjs)
        * [`NetworkError.js`](#networkerrorjs)
        * [`RouterError.js`](#routererrorjs)
        * [`ServiceError.js`](#serviceerrorjs)
        * [`ValidationError.js`](#validationerrorjs)
4.  [Component: Standardized Error Codes (`ErrorCodes.js`)](#4-component-standardized-error-codes-errorcodesjs)
    * [4.1. Overview & Purpose](#41-overview--purpose)
    * [4.2. Structure and Naming Convention](#42-structure-and-naming-convention)
    * [4.3. Usage Guidelines](#43-usage-guidelines)
    * [4.4. Integration with `CoreError` and `ErrorSystem`](#44-integration-with-coreerror-and-errorsystem)
5.  [Component: Central Management (`ErrorSystem.js`)](#5-component-central-management-errorsystemjs)
    * [5.1. Overview & Primary Responsibility](#51-overview--primary-responsibility)
    * [5.2. Key Functionalities & API](#52-key-functionalities--api)
    * [5.3. Adherence to Standardization Pillars (Recap)](#53-adherence-to-standardization-pillars-recap)
    * [5.4. State Management (`ErrorSystem` Specifics)](#54-state-management-errorsystem-specifics)
    * [5.5. Lifecycle Management (`ErrorSystem` Specifics)](#55-lifecycle-management-errorsystem-specifics)
    * [5.6. Error Handling within `ErrorSystem`](#56-error-handling-within-errorsystem)
        * [5.6.1. Internal Error Handling (`_handleInternalError`)](#561-internal-error-handling-_handleinternalerror)
        * [5.6.2. Processing Application Errors (`handleError`)](#562-processing-application-errors-handleerror)
        * [5.6.3. Default Error Handler (`defaultCoreErrorHandler`)](#563-default-error-handler-defaultcoreerrorhandler)
    * [5.7. Event Integration (`ErrorSystem` Specifics)](#57-event-integration-errorsystem-specifics)
    * [5.8. Health Monitoring (`ErrorSystem` Specifics)](#58-health-monitoring-errorsystem-specifics)
    * [5.9. Metrics Tracking (`ErrorSystem` Specifics)](#59-metrics-tracking-errorsystem-specifics)
    * [5.10. Integrations (Managed by `ErrorSystem`)](#510-integrations-managed-by-errorsystem)
    * [5.11. Usage Examples & Best Practices (`ErrorSystem`)](#511-usage-examples--best-practices-errorsystem)
    * [5.12. Testing Strategy Notes (`ErrorSystem`)](#512-testing-strategy-notes-errorsystem)
6.  [Framework Integration Layer (`src/core/errors/integrations/`)](#6-framework-integration-layer-srccoreerrorsintegrations)
    * [6.1. Interface: `IFrameworkIntegration.js`](#61-interface-iframeworkintegrationjs)
        * [6.1.1. Purpose & Role](#611-purpose--role)
        * [6.1.2. API Definition (`initialize`, `mapError`, `serializeError`, `shutdown`)](#612-api-definition-initialize-maperror-serializeerror-shutdown)
    * [6.2. Example Implementation: `FastifyErrorHandler.js`](#62-example-implementation-fastifyerrorhandlerjs)
        * [6.2.1. Overview](#621-overview)
        * [6.2.2. Key Methods & Logic Explained](#622-key-methods--logic-explained)
        * [6.2.3. How it Integrates with `ErrorSystem` and Fastify](#623-how-it-integrates-with-errorsystem-and-fastify)
    * [6.3. Logger Serialization Helper (`FastifyErrorSerializer.js`)](#63-logger-serialization-helper-fastifyerrorserializerjs)
7.  [Shared Error Utilities (`src/core/common/ErrorUtils.js`)](#7-shared-error-utilities-srccorecommonerrorutilsjs)
    * [7.1. `async safeHandleError(errorSystem, error, context = {})`](#71-async-safehandleerrorerrorsystem-error-context---)
        * [7.1.1. Purpose and Functionality](#711-purpose-and-functionality)
        * [7.1.2. Usage Example](#712-usage-example)
8.  [Overall Error Handling Workflow & Best Practices](#8-overall-error-handling-workflow--best-practices)
9.  [Testing Strategies for the Error Handling System](#9-testing-strategies-for-the-error-handling-system)
10. [Future Considerations & Improvements for Error Handling](#10-future-considerations--improvements-for-error-handling)

---

## 1. Introduction to the Error Handling System

### 1.1. Purpose & Philosophy
The TSMIS Error Handling System is a foundational part of the core architecture designed to provide a robust, consistent, and manageable approach to dealing with exceptions and operational errors throughout the application[cite: 1520]. Its core philosophy is to ensure that errors are:

* **Consistently Structured**: All custom application errors inherit from a base `CoreError` class, providing uniform properties like `code`, `message`, `details`, `timestamp`, and `cause`[cite: 1521].
* **Clearly Identifiable**: Standardized `ErrorCodes` allow for programmatic identification and precise understanding of specific error conditions[cite: 1522].
* **Centrally Processed**: The `ErrorSystem` acts as a central hub for reported errors, allowing for consistent logging, metrics, and custom handling logic[cite: 1523].
* **Contextually Rich**: Errors are encouraged to carry detailed contextual information to aid in debugging and resolution[cite: 1524].
* **User-Friendly (where applicable)**: For errors that propagate to users (e.g., via API responses), framework integrations ensure responses are informative and well-formatted[cite: 1525].
* **Resilient**: Mechanisms like `safeHandleError` prevent critical error reporting paths from failing silently[cite: 1526].
This systematic approach is vital for building a robust, maintainable, and observable application[cite: 1527].

### 1.2. Key Components & Their Roles
The Error Handling System is composed of several interconnected components, primarily residing within the `src/core/errors/` directory[cite: 1528]:

* **`CoreError.js`**: The foundational base class for all custom errors. Defines the standard structure and core functionalities for error objects[cite: 1529].
* **Specialized Error Types** (in `src/core/errors/types/`): Subclasses of `CoreError` (e.g., `ValidationError`, `ServiceError`, `ModuleError`) tailored for specific error domains[cite: 1530].
* **`ErrorCodes.js`**: A centralized registry of all unique error code strings used within the application, categorized by domain. Domain-specific codes are stored unprefixed, while `CoreError` subclasses handle prefixing[cite: 1532].
* **`ErrorSystem.js`**: The central service that manages error types, registers custom error handlers, processes reported errors, and coordinates framework integrations for error responses[cite: 1533].
* **`IFrameworkIntegration.js`** (in `src/core/errors/integrations/`): An interface defining the contract for adapters that bridge the `ErrorSystem` with specific web frameworks (e.g., Fastify)[cite: 1534].
* **`FastifyErrorHandler.js`** (in `src/core/errors/integrations/fastify/` - Example Integration): An implementation of `IFrameworkIntegration` tailored for the Fastify web framework[cite: 1535].
* **`FastifyErrorSerializer.js`** (in `src/core/errors/integrations/fastify/`): A utility to help format errors for Fastify's internal logger[cite: 1536].
* **`ErrorUtils.js`** (from `src/core/common/`): Contains shared utilities like `safeHandleError`[cite: 1537].

These components work together to create a cohesive error management strategy[cite: 1537].

### 1.3. Core Dependencies (System-Wide)
The error handling system, particularly `ErrorSystem.js` and its integrations, typically relies on:
* **Logger**: An injected logger instance (e.g., from `deps.logger`, defaulting to `console`) for outputting error information[cite: 1538].
* **Configuration**: Application configuration (e.g., `deps.config`) can influence aspects like development mode (for stack traces) or error history limits[cite: 1539].

### 1.4. Architectural Flow
Errors in TSMIS follow a structured reporting and handling path[cite: 1540]:
1. An error occurs. A `CoreError` subclass (e.g., `ValidationError`) is instantiated using an *unprefixed specific code* from `ErrorCodes.js` (e.g., `ErrorCodes.VALIDATION.INVALID_INPUT` which provides `'INVALID_INPUT'`). The subclass constructor prepends its domain prefix (e.g., `VALIDATION_`) to form the final `error.code` (e.g., `'VALIDATION_INVALID_INPUT'`)[cite: 1541].
2. The component encountering the error uses `safeHandleError` (often via its own `this.handleError` or `this._handleInternalError` method) to report it to the central `ErrorSystem`[cite: 1541].
3. `ErrorSystem` processes the error, potentially invoking custom handlers based on the error type or code[cite: 1542].
4. If the error originated from an HTTP request, a registered framework integration (like `FastifyErrorHandler`) uses `ErrorSystem` to process the error and then formats a standardized HTTP error response[cite: 1543].

**General Error Handling Flow in TSMIS**:
```mermaid
sequenceDiagram
    participant AppComp as Application Component
    participant CoreErrUtil as ErrorCodes.js / SpecificError Class
    participant ModHndlErr as Module.handleError() (if applicable)
    participant SafeHndlErr as ErrorUtils.safeHandleError()
    participant ErrSys as ErrorSystem
    participant CustomHndlr as CustomErrorHandler (in ErrorSystem)
    participant DefaultHndlr as DefaultCoreErrorHandler (in ErrorSystem)
    participant FwInt as FrameworkIntegration (e.g., FastifyErrorHandler)
    participant Logger as Logger
    participant HttpClient as HTTP Client

    AppComp->>AppComp: 1. Error Occurs
    AppComp->>CoreErrUtil: 2. new SpecificError(ErrorCodes.DOMAIN.UNPREFIXED_CODE, msg, details, {cause}) OR new CoreError(ErrorCodes.CORE.PREFIXED_CODE, ...)
    CoreErrUtil-->>AppComp: Returns CoreError instance (code is now prefixed)

    alt Error within a CoreModule derivative
        AppComp->>ModHndlErr: 3a. this.handleError(error, context)
        ModHndlErr->>ModHndlErr: Logs to module.state.errors, records metric
        ModHndlErr->>SafeHndlErr: safeHandleError(this.deps.errorSystem, error, context)
    else Direct reporting
        AppComp->>SafeHndlErr: 3b. safeHandleError(errorSystemInstance, error, context)
    end

    SafeHndlErr->>ErrSys: 4. errorSystem.handleError(error, context)
    Note over ErrSys: Records metric, ensures CoreError type
    ErrSys->>ErrSys: 5. Lookup Handler (Specific or Default)

    alt Specific Handler Found
        ErrSys->>CustomHndlr: 6a. specificHandler(error, context)
        CustomHndlr->>CustomHndlr: (Performs custom actions: logging, notifications, etc.)
        CustomHndlr-->>ErrSys: (Handler completes)
    else Default CoreError Handler
        ErrSys->>DefaultHndlr: 6b. defaultCoreErrorHandler(error, context)
        DefaultHndlr->>Logger: Logs error via this.deps.logger
        DefaultHndlr-->>ErrSys: (Handler completes)
    end
    
    ErrSys->>ErrSys: 7. Emits 'error:handled' or 'error:handler_failed'

    opt HTTP Context Error (Error propagates to Framework)
        AppComp-->>FwInt: (Error reaches Framework's global handler, which uses Integration)
        FwInt->>FwInt: mapError(rawError) -> mappedCoreError
        FwInt->>ErrSys: (Potentially) errorSystem.handleError(mappedCoreError, reqContext)
        FwInt->>FwInt: serializeError(mappedCoreError) -> httpPayload
        FwInt-->>HttpClient: HTTP Error Response
    end
```

---
## 2. Component: `CoreError.js` - The Foundational Error Class

### 2.1. Overview
`CoreError.js` defines the `CoreError` class, which is the cornerstone of TSMIS's standardized error handling[cite: 1550]. All custom application errors must extend this class or one of its specific subclasses[cite: 1551]. It extends the native JavaScript `Error` class, enhancing it with additional structured properties[cite: 1552].

### 2.2. Purpose & Key Features
* **Standardized Structure**: Provides `name`, `code` (fully prefixed on the instance), `message`, `details`, `timestamp`, and `cause` properties[cite: 1553].
* **Error Codes**: Designed to be used with unique codes. When used with `ErrorCodes.js`[cite: 1554]:
    * `CoreError` subclasses receive an *unprefixed specific code* and prepend their domain[cite: 1554].
    * Direct `CoreError` instantiation typically uses a fully prefixed code (e.g., from `ErrorCodes.CORE`)[cite: 1554].
* **Contextual Details**: Allows attaching arbitrary, serializable `details`[cite: 1556].
* **Causation Chain**: Supports an `options.cause` parameter to link to the original error[cite: 1556].
* **Timestamping**: Automatically records the ISO 8601 timestamp of creation[cite: 1557].
* **JSON Serialization**: Provides a `toJSON()` method for structured JSON output[cite: 1558].
* **Deserialization**: Includes a static `fromJSON(data, ErrorType)` method[cite: 1559].
* **Extensibility**: Serves as the base for more specific error classes[cite: 1560].
* **Environment Awareness**: Includes logic (`isDevEnvironment`) for conditional behavior (e.g., stack traces in `toJSON()`)[cite: 1561].

### 2.3. API Reference (`CoreError`)

#### 2.3.1. Constructor
**`new CoreError(code: string, message: string, details: object = {}, options: { cause?: Error } = {})`**
* **`code`**: `string` - A unique error code[cite: 1562].
    * When `CoreError` is instantiated directly (e.g., `new CoreError(...)`), this `code` argument should be the final, fully prefixed error code string (e.g., `'CORE_UNKNOWN_ERROR'`)[cite: 1562].
    * When `CoreError` is used as a base class (i.e., `super(code, ...)` is called from a subclass like `ValidationError`), the `code` passed to `super()` is the already-prefixed code that the subclass has constructed (e.g., `ValidationError` passes `'VALIDATION_INVALID_INPUT'`).
* **`message`**: `string` - A human-readable description of the error[cite: 1563].
* **`details`**: `object` (optional) - Additional serializable information about the error[cite: 1564].
* **`options.cause`**: `Error` (optional) - The underlying error that caused this one[cite: 1565].

#### 2.3.2. Instance Properties
* `name: string`: The class name (e.g., "CoreError", "ValidationError")[cite: 1566].
* `code: string`: The fully prefixed error code stored on the instance[cite: 1566].
* `message: string`: The error message[cite: 1567].
* `details: object`: Sanitized additional details[cite: 1567].
* `timestamp: string`: ISO 8601 timestamp of creation[cite: 1567].
* `cause?: Error`: The wrapped original error, if any[cite: 1568].
* `stack?: string`: The error stack trace[cite: 1568].

#### 2.3.3. Instance Methods
* **`toJSON(): object`**: Returns a plain object representation, including `name`, `code`, `message`, `details`, `timestamp`[cite: 1569]. Includes `cause` (name, message, code, details, and dev-mode stack) and `stack` (in dev-mode)[cite: 1570].
* **`initCause(cause)`**: Initializes `this.cause`, ensuring it's an `Error` instance[cite: 1318, 1571]. (Defined as `initCause` in code [cite: 1318])
* **`sanitizeDetails(details)`**: Ensures `details` are serializable, providing a safe fallback[cite: 1327, 1572]. (Defined as `sanitizeDetails` in code [cite: 1327])
* **`isDevEnvironment()`**: Checks `process.env.NODE_ENV` or `window.ENV` to determine if it's a development/test environment[cite: 1333, 1573]. (Defined as `isDevEnvironment` in code [cite: 1333])

#### 2.3.4. Static Methods
* **`static fromJSON(data: object, ErrorType: typeof CoreError = CoreError): CoreError`**: Reconstructs an error instance (of `ErrorType`) from a plain object representation[cite: 1346, 1574].

### 2.4. State Management
Not Applicable. `CoreError` instances are data objects representing an error state; they do not manage an ongoing operational state themselves.

### 2.5. Lifecycle Management
Not Applicable. `CoreError` instances are created when an error occurs and do not have an independent lifecycle like `initialize()` or `shutdown()`.

### 2.6. Error Handling (Usage Context)
`CoreError` *is* the primary tool for representing errors[cite: 1579]. It is created and thrown by components when exceptional conditions arise[cite: 1579]. It is then caught and processed by error handling logic, often within the `ErrorSystem` or framework integrations[cite: 1580].

### 2.7. Event Integration
Not Applicable. `CoreError` instances themselves do not directly emit or subscribe to events[cite: 1581]. Error events are typically emitted by the system or module that *handles* a `CoreError`[cite: 1582].

### 2.8. Health Monitoring
Not Applicable[cite: 1583].

### 2.9. Metrics Tracking
Not Applicable. Error metrics are tracked by the systems that handle these error objects[cite: 1583].

### 2.10. Integrations (How CoreError is Used)
* **All TSMIS Components**: Any component that needs to signal an error should create and throw a `CoreError` or one of its subclasses[cite: 1584].
* **`ErrorSystem`**: `ErrorSystem.handleError()` expects to process `CoreError` instances. `ErrorSystem.createError()` produces them[cite: 1585].
* **Framework Integrations (e.g., `FastifyErrorHandler`)**: These integrations typically map raw framework errors to `CoreError` instances and use `CoreError.toJSON()` to serialize errors for HTTP responses[cite: 1586].

### 2.11. Usage Examples & Best Practices
* **Creation & Throwing**:
    When creating errors, always use codes from `ErrorCodes.js`. If using a specialized error subclass (e.g., `ValidationError`), pass the *unprefixed specific code* from the relevant domain in `ErrorCodes.js` to the subclass constructor (e.g., `ErrorCodes.VALIDATION.INVALID_INPUT` which now resolves to `'INVALID_INPUT'`). The subclass constructor will handle prefixing (e.g., `VALIDATION_INVALID_INPUT`). If using `new CoreError(...)` directly, ensure the code is fully prefixed (e.g., `ErrorCodes.CORE.UNKNOWN_ERROR` which is `'CORE_UNKNOWN_ERROR'`, or manually construct like `\`DOMAIN_${ErrorCodes.DOMAIN.CODE}\``).

**CoreError.js**: Instantiation and Usage Example

```javascript
// Assuming CoreError.js is in src/core/errors/CoreError.js
// Assuming ErrorCodes.js is in src/core/errors/ErrorCodes.js

// import { CoreError } from './CoreError.js'; // Or from wherever it's exported via an index file
// import { ErrorCodes } from './ErrorCodes.js';
// import { ServiceError } from './types/ServiceError.js'; // Example specific error
// import { ValidationError } from './types/ValidationError.js'; // Example specific error

// function performRiskyOperation(someInput) {
//   if (!someInput) {
//     // Using ValidationError with an unprefixed code from ErrorCodes.VALIDATION
//     // ErrorCodes.VALIDATION.INVALID_INPUT will now resolve to 'INVALID_INPUT'
//     throw new ValidationError(
//       ErrorCodes.VALIDATION.INVALID_INPUT, 
//       "Input cannot be empty for risky operation.",
//       { providedInput: someInput, field: 'someInput' }
//     );
//     // The error.code on this instance will be 'VALIDATION_INVALID_INPUT'
//   }
//   try {
//     // const result = externalService.call(someInput);
//     // if (!result.success) throw new Error(result.errorMessage);
//     // Simulating external error
//     throw new Error("External service call failed!");
//   } catch (externalError) {
//     // Wrapping the externalError in a more specific ServiceError
//     // Pass the unprefixed specific code from ErrorCodes.SERVICE
//     // ErrorCodes.SERVICE.EXTERNAL_API_ERROR will now resolve to 'EXTERNAL_API_ERROR'
//     throw new ServiceError(
//       ErrorCodes.SERVICE.EXTERNAL_API_ERROR, 
//       "Failed to complete operation due to an external service failure.",
//       { operation: 'performRiskyOperation', input: someInput },
//       { cause: externalError } // Preserving the original error
//     );
//     // The error.code on this instance will be 'SERVICE_EXTERNAL_API_ERROR'
//   }
// }

// try {
//   // performRiskyOperation(null); 
//   // For a generic CORE error:
//   // ErrorCodes.CORE.UNKNOWN_ERROR will still resolve to 'CORE_UNKNOWN_ERROR' (prefixed)
//   throw new CoreError(ErrorCodes.CORE.UNKNOWN_ERROR, "A generic unknown core error.");
//   // Here error.code will be 'CORE_UNKNOWN_ERROR'
// } catch (error) {
//   if (error instanceof CoreError) {
//     console.error("Caught a CoreError based error:");
//     console.error("Name:", error.name); // e.g., ValidationError, ServiceError, CoreError
//     console.error("Code:", error.code); // e.g., VALIDATION_INVALID_INPUT, SERVICE_EXTERNAL_API_ERROR, CORE_UNKNOWN_ERROR
//     console.error("Message:", error.message);
//     console.error("Details:", JSON.stringify(error.details, null, 2));
//     console.error("Timestamp:", error.timestamp);
//     if (error.cause) {
//       console.error("Caused by:", error.cause.message);
//     }
//     // For API response or structured logging:
//     // const errorResponse = error.toJSON();
//     // console.error("Serialized JSON:", JSON.stringify(errorResponse, null, 2));
//   } else {
//     console.error("Caught an unexpected error type:", error);
//   }
// }
```
* **Extending `CoreError`**: See Section 3[cite: 1603].
* **Catching & Inspecting**:
    When catching errors, check `error.code` against the fully prefixed string (e.g., `if (error.code === \`VALIDATION_${ErrorCodes.VALIDATION.INVALID_INPUT}\`)` assuming `ErrorCodes.VALIDATION.INVALID_INPUT` is `'INVALID_INPUT'`).

**CoreError.js**: Catching and Inspecting Errors
```javascript
// // Assume performRiskyOperation and error classes are defined as in previous examples
// // import { CoreError, ServiceError, ValidationError } from './core/errors'; // Example import
// // import { ErrorCodes } from './core/errors/ErrorCodes.js';

// // try {
//   // Call a function that might throw a CoreError or its subclass
//   // performRiskyOperation({ data: "some data" }); // This might throw ServiceError
//   // validateUserInput({ email: "invalid" }); // This might throw ValidationError
// // } catch (error) {
//   if (error instanceof ValidationError) {
//     console.error("--- Validation Error Specific Handling ---");
//     // ErrorCodes.VALIDATION.INVALID_INPUT is 'INVALID_INPUT'
//     // error.code is 'VALIDATION_INVALID_INPUT'
//     if (error.code === `VALIDATION_${ErrorCodes.VALIDATION.INVALID_INPUT}`) {
//         console.log("Caught the specific 'VALIDATION_INVALID_INPUT' error!");
//     }
//     console.error(`Validation failed for field(s): ${error.validationErrors.map(ve => ve.field).join(', ')}`);
//     // sendSpecificValidationErrorResponse(error);
//   } else if (error instanceof ServiceError) {
//     console.error("--- Service Error Specific Handling ---");
//     console.error(`Service operation failed with code: ${error.code}`); // e.g., SERVICE_EXTERNAL_API_ERROR
//     // triggerAlertForServiceFailure(error);
//   } else if (error instanceof CoreError) {
//     console.error("--- Generic CoreError Handling ---");
//     // ErrorCodes.CORE.INTERNAL_ERROR is 'CORE_INTERNAL_ERROR'
//     if (error.code === ErrorCodes.CORE.INTERNAL_ERROR) {
//         console.log("Caught a generic CORE_INTERNAL_ERROR!");
//     }
//     console.error(`A core error occurred: [${error.code}] ${error.message}`);
//   } else {
//     console.error("--- Unexpected Non-CoreError ---");
//     console.error(error.message);
//     // const wrappedError = new CoreError(ErrorCodes.CORE.UNKNOWN_ERROR, "An unexpected error occurred.", {}, { cause: error });
//     // errorSystem.handleError(wrappedError, { originalErrorType: error.constructor.name });
//   }
// // }
```

* **Best Practices**:
    * Always use a defined `code` from `ErrorCodes.js`. For specialized subclasses, use the specific unprefixed code from the relevant domain[cite: 1619].
    * Provide a clear, concise `message`[cite: 1619].
    * Include relevant, serializable `details` for debugging. Avoid sensitive data[cite: 1620].
    * Wrap underlying exceptions using the `cause` option to preserve context[cite: 1620].
    * Use specific subclasses of `CoreError` where appropriate for better semantic meaning[cite: 1621].

### 2.12. Testing Strategy Notes
* Test instantiation with all constructor parameters (`code`, `message`, `details`, `cause`)[cite: 1622].
* Verify all instance properties are set correctly (`name`, prefixed `code`, `message`, `details`, `timestamp`, `cause`)[cite: 1623].
* Test `toJSON()` output in both development/test mode (with stack traces) and production mode (without stack traces)[cite: 1623].
* Test `toJSON()` includes `cause` information correctly[cite: 1624].
* Test `static fromJSON()` can accurately reconstruct error instances[cite: 1624].
* Test `sanitizeDetails()` with serializable and non-serializable inputs[cite: 1625].

---
## 3. Component: Specialized Error Types (`src/core/errors/types/`)

### 3.1. Overview and Purpose
To provide more semantic meaning and enable domain-specific handling for different kinds of errors, TSMIS utilizes a set of specialized error classes[cite: 1626]. These classes all extend the base `CoreError` and are located in the `src/core/errors/types/` directory[cite: 1627]. Using specialized types allows for more precise error identification (e.g., distinguishing a `ValidationError` from a `NetworkError`) and can facilitate type-specific error handling logic within custom handlers registered with `ErrorSystem`[cite: 1628].

### 3.2. Common Pattern & Extension of `CoreError`
Each specialized error class generally follows this pattern[cite: 1629]:
1.  **Extends `CoreError`**: `export class SpecificError extends CoreError { ... }` [cite: 1629]
2.  **Constructor**:
    * Typically accepts `(specificCode, message, details = {}, options = {})`[cite: 1630].
    * The `specificCode` argument is the **unprefixed specific part** of the error code, obtained from the relevant domain in `ErrorCodes.js` (e.g., for `ValidationError`, if `ErrorCodes.VALIDATION.INVALID_INPUT` provides `'INVALID_INPUT'`, then `'INVALID_INPUT'` is passed as `specificCode`)[cite: 1631].
    * Calls `super(\`DOMAIN_${specificCode}\`, message, details, options)`. The `DOMAIN_` prefix (e.g., `VALIDATION_`, `AUTH_`) is hardcoded within the subclass's constructor to form the final, fully prefixed `error.code`[cite: 1630, 1631].
    * Sets `this.name` explicitly to its own class name (e.g., `this.name = 'ValidationError';`)[cite: 1632].
    * Often sets a default `this.statusCode` property appropriate for HTTP responses related to that error type (e.g., `this.statusCode = 400;` for `ValidationError`)[cite: 1633].
3.  **Additional Properties/Methods (Optional)**: May define additional properties (like `this.validationErrors` in `ValidationError`) or override methods (like `toJSON()` in `ValidationError` to include these extra properties)[cite: 1634].

### 3.3. Key Individual Error Types (Brief Descriptions & Purpose)
The following are the standard specialized error types provided in the TSMIS core[cite: 1635]:

* **`AccessError.js`**: Represents errors related to authorization and access control (e.g., user lacks permission for an action). Default `statusCode: 403`[cite: 1636].
* **`AuthError.js`**: Represents errors during authentication (e.g., invalid credentials, expired token, missing token). Default `statusCode: 401`[cite: 1636].
* **`ConfigError.js`**: Represents errors encountered during application configuration (loading, validation, missing required values). Default `statusCode: 500`[cite: 1637].
* **`EventError.js`**: Represents errors specific to the operation of `EventBusSystem` or `CoreEventBus` (e.g., event emission failure, invalid subscription pattern). Default `statusCode: 500`[cite: 1638].
* **`ModuleError.js`**: Represents errors specific to the `ModuleSystem` or the lifecycle/operation of a `CoreModule` (e.g., module initialization failure, missing module dependency). Default `statusCode: 500`[cite: 1639].
* **`NetworkError.js`**: Represents errors occurring during external network communications (e.g., request timeouts to other services, DNS lookup failures, connection refused). Default `statusCode: 503`, but can be overridden by `details.statusCode`[cite: 1640].
* **`RouterError.js`**: Represents errors specific to `RouterSystem` or `CoreRouter` (e.g., route registration conflicts, adapter failures, invalid route definitions). Default `statusCode: 500`[cite: 1641].
* **`ServiceError.js`**: A more generic error for issues within application services or their dependencies that don't fit other categories (e.g., database unavailable, unexpected failure in a business operation). Default `statusCode: 503`[cite: 1642].
* **`ValidationError.js`**: Represents failures in data validation, typically for user input or API request payloads. Default `statusCode: 400`. Includes a `validationErrors` array property detailing specific field validation failures.

**Example**: Defining and Using ValidationError
```javascript
// Example definition (src/core/errors/types/ValidationError.js)
// import { CoreError } from '../CoreError.js';
// import { ErrorCodes } from '../ErrorCodes.js'; // Assuming ErrorCodes.VALIDATION.INVALID_INPUT exists

// export class ValidationError extends CoreError {
//   constructor(specificCode, message, details = {}, options = {}) {
//     // 'specificCode' is expected to be an unprefixed code like 'INVALID_INPUT'
//     // from ErrorCodes.VALIDATION.INVALID_INPUT
//     super(\`VALIDATION_${specificCode}\`, message, details, options);
//     this.name = 'ValidationError';
//     this.statusCode = 400;
//     this.validationErrors = Array.isArray(details?.validationErrors) ? details.validationErrors : [];
//   }

//   toJSON() {
//     const json = super.toJSON();
//     json.validationErrors = this.validationErrors;
//     return json;
//   }

//   static fromJSON(data) {
//     const errorInstance = super.fromJSON(data, ValidationError);
//     errorInstance.validationErrors = Array.isArray(data?.validationErrors) ? data.validationErrors : [];
//     return errorInstance;
//   }
// }


// Example Usage:
// function validateUserInput(input) {
//   const errors = [];
//   if (!input.email || !input.email.includes('@')) {
//     errors.push({ field: 'email', message: 'A valid email is required.' });
//   }
//   if (!input.password || input.password.length < 8) {
//     errors.push({ field: 'password', message: 'Password must be at least 8 characters long.' });
//   }

//   if (errors.length > 0) {
//     throw new ValidationError(
//       ErrorCodes.VALIDATION.INVALID_INPUT, // This now resolves to the unprefixed 'INVALID_INPUT'
//       'User input validation failed.',
//       { validationErrors: errors, attemptId: 'user-reg-123' }
//     );
//   }
//   return true;
// }

// try {
//   validateUserInput({ email: 'test', password: 'short' });
// } catch (error) {
//   if (error instanceof ValidationError) {
//     console.error("--- Validation Error Caught ---");
//     console.error("Name:", error.name);          // ValidationError
//     console.error("Code:", error.code);          // Will be 'VALIDATION_INVALID_INPUT'
//     console.error("Message:", error.message);    // User input validation failed.
//     console.error("Status Code:", error.statusCode); // 400
//     console.error("Details:", JSON.stringify(error.details, null, 2));
//     console.error("Validation Errors Array:", JSON.stringify(error.validationErrors, null, 2));
//   }
// }
```
---
## 4. Component: Standardized Error Codes (`ErrorCodes.js`)

### 4.1. Overview & Purpose
`ErrorCodes.js` (located at `src/core/errors/ErrorCodes.js`) is the central definition for all application-specific error code strings[cite: 1663]. Its purpose is to:
* Provide a single source of truth for all error identifiers.
* Ensure consistency and prevent typos when creating and checking errors.
* Facilitate programmatic handling of errors based on unique codes.
* Offer a categorized and human-readable (for developers) map of possible error conditions.

### 4.2. Structure and Naming Convention
* The file exports a single, deeply frozen `ErrorCodes` object[cite: 1668].
* **Top-level keys** within `ErrorCodes` represent major domains or systems (e.g., `CORE`, `CONFIG`, `MODULE`, `VALIDATION`). These keys are conventionally `PascalCase` or `UPPER_SNAKE_CASE`[cite: 1669].
* **Nested keys** under each domain are the specific error identifiers, always in `UPPER_SNAKE_CASE` (e.g., `UNKNOWN_ERROR`, `INITIALIZATION_FAILED`)[cite: 1670].
* **Value Format**[cite: 1671]:
    * For codes within the generic `CORE` domain, the string value includes the `CORE_` prefix (e.g., `ErrorCodes.CORE.UNKNOWN_ERROR` is `'CORE_UNKNOWN_ERROR'`). These are typically used directly with `new CoreError(...)`.
    * For codes within other specific domains (e.g., `VALIDATION`, `CONFIG`), the string value is the **unprefixed specific part** of the code (e.g., `ErrorCodes.VALIDATION.INVALID_INPUT` is `'INVALID_INPUT'`). These are intended for use with corresponding `CoreError` subclasses.
* **Important Note on Prefixes**: `CoreError` subclasses (e.g., `ValidationError`) are responsible for prepending their domain prefix (e.g., `VALIDATION_`) to the specific, unprefixed code part (obtained from `ErrorCodes.js`) when an error instance is created. The final `error.code` property on an instantiated specialized error will thus be fully prefixed (e.g., `'VALIDATION_INVALID_INPUT'`).

### 4.3. Usage Guidelines
* **Importing**: Import the `ErrorCodes` object where needed: `import { ErrorCodes } from '../core/errors/ErrorCodes.js';` [cite: 1676]
* **Creating Errors**[cite: 1676]:
    * For specialized subclasses: `new ValidationError(ErrorCodes.VALIDATION.INVALID_INPUT, ...)` (where `ErrorCodes.VALIDATION.INVALID_INPUT` provides the unprefixed `'INVALID_INPUT'`). The `ValidationError` constructor adds the `VALIDATION_` prefix.
    * For generic `CoreError` using `CORE` domain codes: `new CoreError(ErrorCodes.CORE.INTERNAL_ERROR, ...)` (where `ErrorCodes.CORE.INTERNAL_ERROR` provides the prefixed `'CORE_INTERNAL_ERROR'`).
    * For generic `CoreError` representing a specific domain error (less common, prefer subclasses): `new CoreError(\`CONFIG_${ErrorCodes.CONFIG.LOAD_FAILED}\`, ...)` (manually prepending prefix to the unprefixed code from `ErrorCodes.CONFIG`).
* **Checking Error Codes**[cite: 1680]: In error handlers, compare `error.code` against the fully prefixed codes (e.g., `if (error.code === \`VALIDATION_${ErrorCodes.VALIDATION.INVALID_INPUT}\`)`).
* **Adding New Codes**:
    1.  Identify or create the appropriate domain object within `ErrorCodes`.
    2.  Add a new `UPPER_SNAKE_CASE` key with its corresponding string value (unprefixed for specific domains, prefixed for `CORE`).
    3.  Ensure all nested objects are also frozen with `Object.freeze()`.

### 4.4. Integration with `CoreError` and `ErrorSystem`
* **`CoreError` Subclasses**: Use unprefixed codes from `ErrorCodes.DOMAIN.SPECIFIC_CODE` in their constructors, prepending their domain prefix to create the final `error.code`[cite: 1684].
* **`ErrorSystem`**:
    * `createError(typeName, code, ...)`: Expects the unprefixed `code` from `ErrorCodes.js` when `typeName` refers to a specialized subclass. The subclass constructor then adds the prefix. If `typeName` is `'CoreError'`, `code` should be the fully prefixed code (e.g., from `ErrorCodes.CORE`).
    * `handleError(error, ...)`: Works with `error.code` which will be the fully prefixed code, allowing handlers to switch on these specific codes.

**Example**: Snippet from `ErrorCodes.js` (Illustrative)
```javascript
// src/core/errors/ErrorCodes.js (Illustrative Snippet - showing new unprefixed style for domains)

// export const ErrorCodes = Object.freeze({
//   CORE: Object.freeze({ // Values are fully prefixed
//     UNKNOWN_ERROR: 'CORE_UNKNOWN_ERROR',
//     INTERNAL_ERROR: 'CORE_INTERNAL_ERROR',
//     // ... other core errors
//   }),

//   // --- Module System & CoreModule Errors ---
//   MODULE: Object.freeze({ // Values are unprefixed specific parts
//     INITIALIZATION_FAILED: 'INITIALIZATION_FAILED',
//     MISSING_DEPENDENCIES: 'MISSING_DEPENDENCIES',
//     // ... other module system or generic module errors
//   }),

//   // --- Validation Error Specific Codes (used by ValidationError type) ---
//   VALIDATION: Object.freeze({ // Values are unprefixed specific parts
//     INVALID_INPUT: 'INVALID_INPUT',
//     SCHEMA_MISMATCH: 'SCHEMA_MISMATCH',
//     REQUIRED_FIELD: 'REQUIRED_FIELD',
//     // ... other specific validation failure codes
//   }),

//   // ... other domains like CONFIG, EVENT, ROUTER, SERVICE, NETWORK, AUTH, ACCESS ...
//   // e.g., CONFIG: Object.freeze({ LOAD_FAILED: 'LOAD_FAILED' })
// });
```

---
## 5. Component: Central Management (`ErrorSystem.js`)

### 5.1. Overview & Primary Responsibility
`ErrorSystem.js` defines the `ErrorSystem` class, which acts as the central orchestrator for error management[cite: 1688]. Its primary responsibility is to process errors reported from any part of the application, route them to appropriate handlers based on their type, manage framework integrations for consistent error responses, and serve as a factory for creating standardized error objects[cite: 1689].

### 5.2. Key Functionalities & API
* **Initialization & Shutdown**: `async initialize()` and `async shutdown()`[cite: 1690].
* **Error Processing**: `async handleError(error: Error, context = {}): Promise<void>` is the main method for application components to report errors[cite: 1691].
* **Handler Management**: `registerHandler(errorTypeName: string, handler: Function)` allows defining custom logic for specific error types[cite: 1692].
* **Integration Management**: `async registerIntegration(name, IntegrationClass, frameworkInstance, options)` for plugging in adapters like `FastifyErrorHandler`[cite: 1693].
* **Error Factory**: `createError(typeName, code, message, details, options): CoreError` for instantiating error objects. Expects an *unprefixed specific code* for `code` when `typeName` refers to a specialized subclass[cite: 1438, 1694].

### 5.3. Adherence to Standardization Pillars (Recap)
* **State Management**: Implements the standard `this.state` object. Also maintains `errorTypes`, `customHandlers`, and `integrations` maps[cite: 1695].
* **Lifecycle Management**: Follows standard `initialize`/`shutdown` patterns, emitting `LIFECYCLE_EVENTS`. `initialize()` validates registered error types. `shutdown()` cleans up handlers and integrations[cite: 1696].
* **Error Handling (Internal)**: Uses `_handleInternalError` for its own operational errors, reporting via `safeHandleError` (which uses console for `ErrorSystem`'s own errors)[cite: 1697].
* **Health Monitoring**: `checkHealth()` aggregates status from `errorsystem.state`, `errorsystem.handlers` (counts), and `errorsystem.integrations` (counts, and individual integration health if supported)[cite: 1698].
* **Metrics Tracking**: Records metrics for its lifecycle, internal errors, errors processed by `handleError`, and registrations of handlers/integrations[cite: 1699].
* **Factory Function**: `createErrorSystem(deps = {})` is provided[cite: 1700].

### 5.4. State Management (`ErrorSystem` Specifics)
Beyond the standard `this.state` object, `ErrorSystem` manages[cite: 1701]:
* **`errorTypes: Map<string, typeof CoreError>`**: A map storing the constructors of known `CoreError` subclasses, keyed by their class name[cite: 1701]. Used by `ErrorSystem.createError`[cite: 1702].
* **`customHandlers: Map<string, Function>`**: A map storing custom error handling functions, keyed by the `error.constructor.name` they are registered for[cite: 1702].
* **`integrations: Map<string, IFrameworkIntegration>`**: A map storing active framework integration instances, keyed by the name provided during registration[cite: 1703].

### 5.5. Lifecycle Management (`ErrorSystem` Specifics)
* **`initialize()`**: Key tasks include validating registered error types and preparing default handlers[cite: 1705]. It ensures the system is ready to process errors. Emits `system:initializing`, `system:initialized`, `system:running`[cite: 1705].
* **`shutdown()`**: Key tasks include attempting to gracefully shut down any registered integrations, clearing its internal maps of handlers and integrations, and removing its own event listeners[cite: 1706]. Emits `system:shutting_down`, `system:shutdown`[cite: 1707].

### 5.6. Error Handling within `ErrorSystem`

#### 5.6.1. Internal Error Handling (`_handleInternalError`)
For errors arising from its own operations, `ErrorSystem` uses its private `async _handleInternalError(error, context)` method[cite: 1708]. This method ensures the error is a `CoreError`, logs it to `ErrorSystem`'s own `this.state.errors`, records an internal metric, and logs the error to `console.error` (as `safeHandleError` with a null `errorSystem` would do).

#### 5.6.2. Processing Application Errors (`handleError`)
The public `async handleError(error: Error, context = {})` method is the primary entry point for external errors[cite: 1712]:
1. Records an `errorsystem.errors.received` metric[cite: 1712].
2. Ensures the input `error` is an instance of `CoreError`[cite: 1712]. If not, it wraps the original error in a generic `CoreError` (with code `ErrorCodes.CORE.UNKNOWN_ERROR`), preserving the original as `cause`[cite: 1713].
3. **Handler Lookup**: It determines the most specific handler by checking `this.customHandlers` for `error.constructor.name`, then for `CoreError.name`.
4. The `defaultCoreErrorHandler` is registered for `CoreError.name` by default[cite: 1716].
5. The chosen handler function is invoked[cite: 1717].
6. After the handler executes, `ErrorSystem` emits `error:handled` or `error:handler_failed` events.

#### 5.6.3. Default Error Handler (`defaultCoreErrorHandler`)
Registered for `CoreError.name` by default[cite: 1721]. If no more specific handler processes an error, this handler will be invoked[cite: 1721]. Its primary action is to log the error in a structured format (using `error.toJSON()`) via `this.deps.logger.error()`[cite: 1722].

### 5.7. Event Integration (`ErrorSystem` Specifics)
`ErrorSystem` is an `EventEmitter` and emits operational events[cite: 1723]:
* **`error:handled`**: After an error is processed by a handler[cite: 1724]. Payload: `{ error: CoreError, context: object, handlerName: string }`[cite: 1724].
* **`error:handler_failed`**: If a handler itself throws an error[cite: 1725]. Payload: `{ error: Error (handler's error), originalError: CoreError, context: object }`[cite: 1725].
* **`error:unhandled`**: If no handler could be invoked (unlikely with default)[cite: 1726]. Payload: `{ error: CoreError, context: object }`[cite: 1727].
It also emits standard system lifecycle events for itself.

### 5.8. Health Monitoring (`ErrorSystem` Specifics)
`ErrorSystem` provides a `checkHealth()` method[cite: 1728]. Default checks include[cite: 1729]:
* **`errorsystem.state`**: Its `status`, `uptime`, and internal error count[cite: 1729].
* **`errorsystem.handlers`**: Number of custom error handlers[cite: 1730].
* **`errorsystem.integrations`**: Number of framework integrations and their individual health if supported.

### 5.9. Metrics Tracking (`ErrorSystem` Specifics)
`ErrorSystem` records key metrics[cite: 1733]:
* **Lifecycle**: `errorsystem.initialized.success/failure`, `errorsystem.shutdown.success/failure`[cite: 1733].
* **Internal Operations**: `errorsystem.errors.internal`[cite: 1734].
* **Error Processing**: `errorsystem.errors.received` (Tags: `errorName`, `errorCode`).
* **Registrations**: `errorsystem.handlers.registered` (Tags: `errorTypeName`), `errorsystem.integrations.registered` (Tags: `integrationName`).

### 5.10. Integrations (Managed by `ErrorSystem`)
This details how `ErrorSystem` *manages and interacts with* its framework integrations[cite: 1738].
* **Framework Integrations (e.g., `FastifyErrorHandler`)**[cite: 1739]:
    * Registered via `errorSystem.registerIntegration(name, IntegrationClass, frameworkInstance, options)`[cite: 1739].
    * `ErrorSystem` can pass itself (`this`) to the integration's `initialize` method[cite: 1740].
    * Integrations map raw errors to `CoreError`, pass to `errorSystem.handleError()`, serialize `CoreError` for HTTP response, and send response.
* **Logger Dependency (`deps.logger`)**: Used for default error logging[cite: 1746].
* **Configuration (`deps.config`)**: Can influence behavior (e.g., `maxErrorHistory`)[cite: 1747].

**ErrorSystem - Core Structure & Error Processing Flow**:
```mermaid
graph TD
    subgraph ErrorOrigin [Error Origin]
        AppCode["Application Code / Other System"]
        Framework["HTTP Web Framework"]
    end

    subgraph ErrorSystemCore [ErrorSystem Core Components]
        direction LR
        ES_State[("this.state")]
        ES_Handlers[("Custom Handlers Map")]
        ES_Integrations[("Integrations Map")]
        ES_ErrorTypes[("Error Types Registry")]
    end
    
    AppCode -- "Reports error (e.g., new SubError(ErrorCodes.DOMAIN.CODE, ...)) via safeHandleError()" --> SafeErrorUtil["ErrorUtils.safeHandleError()"];
    Framework -- "Catches HTTP error" --> FwInt["FrameworkIntegration Instance"];
    
    FwInt -- "mapError(rawError)" --> MappedCoreError["Standardized CoreError (prefixed code)"];
    FwInt -- "errorSystem.handleError(MappedCoreError, reqCtx)" --> ES_HandleError["ErrorSystem.handleError()"];
    SafeErrorUtil -- "errorSystem.handleError(errorWithPrefixedCode, context)" --> ES_HandleError;
    
    ES_HandleError -- "1. Record Metric, Ensure CoreError" --> ES_State;
    ES_HandleError -- "2. Lookup Handler (based on error.constructor.name)" --> ES_Handlers;
    ES_Handlers -- "3a. Found Specific/Default Handler" --> ChosenHandler["Chosen Error Handler"];
    ChosenHandler -- "4. Process Error (e.g., log, notify)" --> LoggingMonitoring["External Logging/Monitoring Services"];
    ChosenHandler -- "(or DefaultHandler logs via Logger)" --> LoggerDep["Logger Dependency"];
    ES_HandleError -- "5. Emit 'error:handled' or 'error:handler_failed'" --> EventBusLink["(Event on ErrorSystem)"];

    ES_CreateError["ErrorSystem.createError(typeName, unprefixedCode, ...)"] -- "Uses" --> ES_ErrorTypes;
    AppCode -- "Creates error via factory" --> ES_CreateError;
    ES_CreateError -- returns --> AppCodeErrInst["Instantiated Error (prefixed code)"]


    classDef stateNode fill:#f9f,stroke:#333,stroke-width:2px;
    classDef utilNode fill:#e8f8f5,stroke:#333,stroke-width:1px;
    class ES_State, ES_Handlers, ES_Integrations, ES_ErrorTypes stateNode;
    class SafeErrorUtil, MappedCoreError, SerializedPayload utilNode;
```

### 5.11. Usage Examples & Best Practices (`ErrorSystem`)

**ErrorSystem**: Registering a Custom Error Handler
```javascript
// // In application setup, after ErrorSystem is initialized
// // const errorSystem = container.resolve('errorSystem');
// // import { ValidationError } from '../core/errors/types/ValidationError.js';
// // import { CoreError } from '../core/errors/CoreError.js';

// // Custom handler for ValidationErrors
// errorSystem.registerHandler(ValidationError.name, async (validationError, context) => {
//   errorSystem.deps.logger.warn(`[ValidationErrorHandler] Validation Failed for ${context.source}:`, {
//     code: validationError.code, // This will be the prefixed code, e.g., VALIDATION_INVALID_INPUT
//     message: validationError.message,
//     validationErrors: validationError.validationErrors, // Specific to ValidationError
//     context: context,
//   });
//   // Example: Notify a monitoring service or take specific action
//   // await monitoringService.reportValidationError(validationError, context);
// });

// // Register a fallback handler for any CoreError not specifically handled by other custom handlers
// // Note: ErrorSystem constructor already registers a defaultCoreErrorHandler for CoreError.name
// // This would override it if registered after initialization.
// errorSystem.registerHandler(CoreError.name, async (coreError, context) => {
//   errorSystem.deps.logger.error(`[CustomDefaultCoreErrorHandler] Core Error Occurred for ${context.source}:`, {
//     error: coreError.toJSON(), // Use toJSON for structured logging
//     context: context,
//   });
// });
```

**ErrorSystem**: Registering FastifyErrorHandler Integration
```javascript
// // Assuming ErrorSystem instance and Fastify app instance are available
// // import { FastifyErrorHandler } from '../core/errors/integrations/fastify/FastifyErrorHandler.js';
// // import Fastify from 'fastify';

// // const errorSystem = container.resolve('errorSystem');
// // const fastifyApp = Fastify({ logger: true /* other options */ });
// // const appLogger = fastifyApp.log; // Or your main application logger

// async function setupFastifyErrorIntegration(app, errSys, logger) {
//   try {
//     await errSys.registerIntegration(
//       'fastifyMain',          // A name for this integration instance
//       FastifyErrorHandler,    // The integration class constructor
//       app,                    // The Fastify framework instance
//       { errorSystem: errSys, logger } // Options for the FastifyErrorHandler
//     );
//     logger.info('[AppSetup] FastifyErrorHandler integration registered with ErrorSystem.');
//   } catch (integrationError) {
//     logger.error('[AppSetup] Failed to register FastifyErrorHandler with ErrorSystem:', integrationError);
//     // Potentially a critical failure
//     throw integrationError;
//   }
// }

// // setupFastifyErrorIntegration(fastifyApp, errorSystem, appLogger);
```

**ErrorSystem**: Application Code Reporting an Error
```javascript
// // Inside a service or module method
// // Assume 'this.errorSystem' is an injected ErrorSystem instance
// // Assume 'this.logger' is an injected logger instance
// // import { ErrorCodes } from '../core/errors/ErrorCodes.js';
// // import { ValidationError } from '../core/errors/types/ValidationError.js'; // For typeName

// async function processUserData(userId, data) {
//   try {
//     if (!data.email) {
//       // Use errorSystem.createError for consistency.
//       // Pass the typeName and the unprefixed specific code.
//       // ErrorCodes.VALIDATION.REQUIRED_FIELD should now provide 'REQUIRED_FIELD'
//       throw this.errorSystem.createError(
//         'ValidationError', // Type name (class name of the error)
//         ErrorCodes.VALIDATION.REQUIRED_FIELD, // Specific unprefixed code from ErrorCodes.VALIDATION
//         'Email is required for user processing.',
//         { field: 'email', userId, component: 'UserProcessor' }
//       );
//       // The resulting error.code on the thrown error will be 'VALIDATION_REQUIRED_FIELD'
//     }
//     // ... other processing ...
//     this.logger.info(`[UserProcessor] Successfully processed data for user ${userId}`);
//   } catch (error) {
//     // Let ErrorSystem handle it
//     const processingContext = {
//       operation: 'processUserData',
//       userId,
//       inputDataSummary: { hasEmail: !!data.email, keyCount: Object.keys(data).length }
//     };
//     await this.errorSystem.handleError(error, processingContext);

//     // Re-throw if the caller needs to act on the error (e.g., API layer to send HTTP response)
//     throw error;
//   }
// }
```

* **Best Practices**:
    * Initialize `ErrorSystem` early[cite: 1777].
    * Register specific handlers for common, actionable error types[cite: 1777].
    * Always use a framework integration for web applications[cite: 1777].
    * Provide rich context when calling `handleError`[cite: 1778].
    * Ensure a capable, structured logger is injected[cite: 1778].

### 5.12. Testing Strategy Notes (`ErrorSystem`)
* Test handler registration and invocation[cite: 1779].
* Test `handleError` with `CoreError`s, subclasses, and native errors (wrapping)[cite: 1780].
* Test `createError` factory[cite: 1780].
* Test `registerIntegration` with mock `IFrameworkIntegration`[cite: 1781].
* Test lifecycle, health checks, and metrics[cite: 1781].
* Test behavior with misconfigured dependencies (graceful degradation, console fallbacks)[cite: 1782].

---
## 6. Framework Integration Layer (`src/core/errors/integrations/`)
To bridge `ErrorSystem` with web frameworks like Fastify, TSMIS employs an integration layer.

### 6.1. Interface: `IFrameworkIntegration.js`

#### 6.1.1. Purpose & Role
`IFrameworkIntegration.js` defines the standard contract for framework-specific error handling adapters[cite: 1785]. This allows `ErrorSystem` to manage integrations polymorphically[cite: 1786]. The integration captures framework errors, processes them via `ErrorSystem`, and formats HTTP error responses[cite: 1787].

#### 6.1.2. API Definition (`initialize`, `mapError`, `serializeError`, `shutdown`)
Key methods defined by `IFrameworkIntegration`[cite: 1788]:
* **`async initialize(framework: object, options: { errorSystem?: ErrorSystem, logger?: object })`**: Sets up integration with the framework (e.g., registers global error handler). Receives `ErrorSystem` and `logger`[cite: 1789].
* **`mapError(frameworkError: Error, requestContext = {}): CoreError`**: Converts raw framework error to a `CoreError`[cite: 1789].
* **`serializeError(coreError: CoreError, requestContext = {}): object`**: Transforms `CoreError` to HTTP response payload[cite: 1790].
* **`async shutdown(): Promise<void>|void`** (Optional): Cleanup for integration[cite: 1791].

**IFrameworkIntegration.js**: Interface Definition
```javascript
// src/core/errors/integrations/IFrameworkIntegration.js (Illustrative Content)
// import { CoreError } from '../CoreError.js';
// import { ErrorSystem } from '../ErrorSystem.js'; // For type hinting

// export class IFrameworkIntegration {
//   /**
//    * Initializes the integration with the specific web framework instance.
//    * @param {object} framework - The instance of the web framework.
//    * @param {object} [options={}] - Integration-specific options.
//    * @param {ErrorSystem} [options.errorSystem] - An instance of the ErrorSystem.
//    * @param {object} [options.logger] - A logger instance.
//    * @returns {Promise<void>|void}
//    */
//   async initialize(framework, options = {}) {
//     throw new Error('IFrameworkIntegration.initialize() must be implemented by subclass.');
//   }

//   /**
//    * Maps a raw error to a standardized CoreError instance.
//    * @param {Error} frameworkError - The raw error object.
//    * @param {object} [requestContext={}] - Optional context from the request.
//    * @returns {CoreError} An instance of CoreError or its subclass.
//    */
//   mapError(frameworkError, requestContext = {}) {
//     throw new Error('IFrameworkIntegration.mapError() must be implemented by subclass.');
//   }

//   /**
//    * Serializes a CoreError instance into a format for an HTTP response body.
//    * @param {CoreError} coreError - The CoreError instance to serialize.
//    * @param {object} [requestContext={}] - Optional context from the request.
//    * @returns {object} A plain object representing the error response payload.
//    */
//   serializeError(coreError, requestContext = {}) {
//     throw new Error('IFrameworkIntegration.serializeError() must be implemented by subclass.');
//   }

//   /**
//    * Optional method for cleanup during ErrorSystem shutdown.
//    * @returns {Promise<void>|void}
//    */
//   async shutdown() {
//     // Optional: Subclasses can implement this.
//   }
// }
```

### 6.2. Example Implementation: `FastifyErrorHandler.js`

#### 6.2.1. Overview
`FastifyErrorHandler.js` implements `IFrameworkIntegration` for Fastify[cite: 1797]. It hooks into Fastify's error handling for consistent error processing and HTTP responses[cite: 1798].

#### 6.2.2. Key Methods & Logic Explained
* **`async initialize(fastify, options)`**[cite: 1799]:
    * Stores `options.errorSystem` and `options.logger`[cite: 1800].
    * Adds Fastify `onRequest` hook for `request.errorContext`[cite: 1800].
    * Calls `fastify.setErrorHandler()` to register Fastify's global error handler. This handler[cite: 1801]:
        1.  Calls `this.mapError()` to get a `CoreError`[cite: 1801].
        2.  Calls `await this.errorSystem.handleError()` for processing[cite: 1802].
        3.  Calls `this.serializeError()` for JSON payload[cite: 1803].
        4.  Uses `reply.status().send()` to send HTTP response[cite: 1804].
* **`mapError(frameworkError, requestContext)`**[cite: 1805]:
    * Returns `frameworkError` if already `CoreError`[cite: 1806].
    * Handles Fastify validation errors (`.validation` or `FST_ERR_VALIDATION`) creating `ValidationError`[cite: 1807].
    * Handles Fastify "Not Found" errors (`FST_ERR_NOT_FOUND` or `statusCode 404`) creating `NetworkError`[cite: 1808].
    * Wraps other errors in `CoreError` with `ErrorCodes.CORE.UNKNOWN_ERROR`[cite: 1809].
    * Ensures appropriate `statusCode` on the `CoreError`[cite: 1810].
* **`serializeError(coreError, requestContext)`**[cite: 1811]:
    * Relies on `coreError.toJSON()`[cite: 1812].
    * May add minimal, safe `requestContext` (like `requestId`).

**FastifyErrorHandler.js**: Example Implementation Snippet
```javascript
// src/core/errors/integrations/fastify/FastifyErrorHandler.js (Illustrative Snippet)
// import { IFrameworkIntegration } from '../IFrameworkIntegration.js';
// import { CoreError } from '../../CoreError.js';
// import { ErrorCodes } from '../../ErrorCodes.js';
// import { ValidationError, NetworkError } from '../../types/index.js';

// export class FastifyErrorHandler extends IFrameworkIntegration {
//   errorSystem = null;
//   logger = console;
//   initialized = false;

//   constructor() { super(); }

//   async initialize(fastify, options = {}) {
//     if (this.initialized) return;
//     this.errorSystem = options.errorSystem;
//     this.logger = options.logger || this.logger;
//     fastify.addHook('onRequest', async (request, reply) => {
//       request.errorContext = { /* requestId, url, method, ip, timestamp */ };
//     });
//     fastify.setErrorHandler(async (error, request, reply) => {
//       const requestContext = { ...request.errorContext, params: request.params, query: request.query };
//       const mappedCoreError = this.mapError(error, requestContext); // mappedCoreError.code will be prefixed

//       if (this.errorSystem) {
//         await this.errorSystem.handleError(mappedCoreError, requestContext);
//       } else {
//         this.logger.error('[FastifyErrorHandler] ErrorSystem unavailable. Logging raw mapped error:', {
//           error: mappedCoreError.toJSON ? mappedCoreError.toJSON() : mappedCoreError, context: requestContext,
//         });
//       }
//       const responsePayload = this.serializeError(mappedCoreError, requestContext);
//       let statusCode = mappedCoreError.statusCode || 500;
//       if (typeof statusCode !== 'number' || statusCode < 100 || statusCode > 599) statusCode = 500;
//       reply.status(statusCode).send(responsePayload);
//     });
//     this.initialized = true;
//   }

//   mapError(frameworkError, requestContext = {}) {
//     if (frameworkError instanceof CoreError) return frameworkError;
//     // Example: Fastify validation errors
//     if (frameworkError.code === 'FST_ERR_VALIDATION' || frameworkError.validation) {
//       const validationDetails = frameworkError.validation?.map(vErr => ({ /* ... */ }));
//       // ErrorCodes.VALIDATION.SCHEMA_MISMATCH is now 'SCHEMA_MISMATCH'
//       const validationError = new ValidationError(
//         ErrorCodes.VALIDATION.SCHEMA_MISMATCH,
//         frameworkError.message || 'Request validation failed.',
//         { validationErrors: validationDetails || [], rawFastifyValidation: frameworkError.validation },
//         { cause: frameworkError }
//       );
//       validationError.statusCode = frameworkError.statusCode || 400;
//       return validationError; // error.code will be 'VALIDATION_SCHEMA_MISMATCH'
//     }
//     // ... other specific mappings ...
//     // Fallback for generic errors
//     return new CoreError(
//         ErrorCodes.CORE.UNKNOWN_ERROR, // This is already 'CORE_UNKNOWN_ERROR'
//         frameworkError.message, {}, { cause: frameworkError }
//     );
//   }

//   serializeError(coreError, requestContext = {}) {
//     if (coreError instanceof CoreError) {
//       const serialized = coreError.toJSON(); // This contains the prefixed error.code
//       return { ...serialized /*, context: { requestId: requestContext?.requestId } */ };
//     }
//     return { /* fallback serialization */ };
//   }
// }
```

#### 6.2.3. How it Integrates with `ErrorSystem` and Fastify
1.  **Registration**: `FastifyErrorHandler` instance registered with `ErrorSystem` via `errorSystem.registerIntegration()`[cite: 1830].
2.  **Initialization**: `ErrorSystem` calls `fastifyErrorHandler.initialize()`[cite: 1831].
3.  **Runtime**: Fastify's global error handler (set by `FastifyErrorHandler`) invokes `FastifyErrorHandler` methods, which coordinate with `ErrorSystem`[cite: 1832].

### 6.3. Logger Serialization Helper (`FastifyErrorSerializer.js`)
Fastify uses Pino logger, allowing custom error serializers[cite: 1833]. `FastifyErrorSerializer.js` provides `createFastifyLoggerErrorSerializer(serializeMethod)` to configure Fastify's logger to use `FastifyErrorHandler.serializeError` for consistent structured error logging.

**FastifyErrorSerializer.js**: Utility Definition
```javascript
// src/core/errors/integrations/fastify/FastifyErrorSerializer.js (Illustrative Content)

// export function createFastifyLoggerErrorSerializer(serializeMethod) {
//   if (typeof serializeMethod !== 'function') {
//     console.warn('[FastifyErrorSerializer] serializeMethod is not a function.');
//     return {
//       serializer: (error) => ({ 
//         message: error.message, 
//         stack: error.stack, 
//         code: error.code, // This will be the prefixed code
//         name: error.name 
//       })
//     };
//   }
//   return {
//     serializer: (error) => serializeMethod(error, {}), // serializeMethod expects a CoreError
//   };
// }
```

---
## 7. Shared Error Utilities (`src/core/common/ErrorUtils.js`)

### 7.1. `async safeHandleError(errorSystem, error, context = {})`

#### 7.1.1. Purpose and Functionality
This utility (in `src/core/common/ErrorUtils.js`) provides a fallback for error reporting[cite: 1840]. It tries to delegate to `errorSystem.handleError()`[cite: 1841]. If `errorSystem` is unavailable or `handleError()` fails, `safeHandleError` catches this and logs the original (and forwarding error) to `console.error`, ensuring errors are not lost[cite: 1842].

#### 7.1.2. Usage Example
**Example**: Usage of safeHandleError
```javascript
// Example usage of safeHandleError within a component's method:
// Assume 'this.deps.errorSystem' holds the ErrorSystem instance
// import { CoreError } from '../errors/CoreError.js';
// import { ServiceError } from '../errors/types/ServiceError.js'; // Example specific error
// import { ErrorCodes } from '../errors/ErrorCodes.js';
// import { safeHandleError } from '../common/ErrorUtils.js';

// async function someOperationInComponent() {
//   try {
//     if (true /* some condition leads to error */) {
//       throw new Error("A raw error occurred during the operation.");
//     }
//   } catch (rawError) {
//     // Create a standardized ServiceError
//     // ErrorCodes.SERVICE.OPERATION_FAILED is now 'OPERATION_FAILED'
//     const operationError = new ServiceError(
//       ErrorCodes.SERVICE.OPERATION_FAILED, 
//       `The operation failed: ${rawError.message}`,
//       { operationName: 'someOperationInComponent', inputParameters: { /*...*/ } },
//       { cause: rawError }
//     );
//     // operationError.code will be 'SERVICE_OPERATION_FAILED'

//     await safeHandleError(this.deps.errorSystem, operationError, {
//       source: this.constructor.name,
//       customContext: 'Additional info about where in the operation it failed.'
//     });
//     // throw operationError; // Optionally re-throw
//   }
// }
```

---
## 8. Overall Error Handling Workflow & Best Practices

The general workflow for errors in TSMIS:
1.  **Detection & Instantiation**: Errors are detected. Specific `CoreError` subclasses are instantiated with **unprefixed specific codes** from `ErrorCodes.DOMAIN.CODE_NAME` (the subclass constructor prepends the domain). Generic `CoreError` instances use fully prefixed codes from `ErrorCodes.CORE.CODE_NAME` or manually constructed prefixed codes. All include clear messages, details, and wrapped causes[cite: 1851].
2.  **Local Handling Attempt (Optional)**: A component might attempt local recovery[cite: 1852].
3.  **Centralized Reporting**: Significant errors are reported to `ErrorSystem` via `module.handleError()` or `safeHandleError()`[cite: 1853].
4.  **`ErrorSystem` Processing**: `ErrorSystem` invokes appropriate handlers[cite: 1854]. Handlers perform logging, metrics, notifications[cite: 1854].
5.  **API Response (if applicable)**: For HTTP errors, the framework integration uses the processed `CoreError` for a standardized response[cite: 1855].

**General Error Handling Flow in TSMIS (Recap)**:
```mermaid
sequenceDiagram
    participant AppComp as Application Component
    participant CoreErrUtil as ErrorCodes.js / SpecificError Class
    participant ModHndlErr as Module.handleError() (if applicable)
    participant SafeHndlErr as ErrorUtils.safeHandleError()
    participant ErrSys as ErrorSystem
    participant CustomHndlr as CustomErrorHandler (in ErrorSystem)
    participant DefaultHndlr as DefaultCoreErrorHandler (in ErrorSystem)
    participant FwInt as FrameworkIntegration (e.g., FastifyErrorHandler)
    participant Logger as Logger
    participant HttpClient as HTTP Client

    AppComp->>AppComp: 1. Error Occurs
    AppComp->>CoreErrUtil: 2. new SpecificError(ErrorCodes.DOMAIN.UNPREFIXED_CODE, msg, details, {cause}) <br> OR new CoreError(ErrorCodes.CORE.PREFIXED_CODE, ...)
    CoreErrUtil-->>AppComp: Returns CoreError instance (code is now fully prefixed)

    alt Error within a CoreModule derivative
        AppComp->>ModHndlErr: 3a. this.handleError(error, context)
        ModHndlErr->>ModHndlErr: Logs to module.state.errors, records metric
        ModHndlErr->>SafeHndlErr: safeHandleError(this.deps.errorSystem, error, context)
    else Direct reporting
        AppComp->>SafeHndlErr: 3b. safeHandleError(errorSystemInstance, error, context)
    end

    SafeHndlErr->>ErrSys: 4. errorSystem.handleError(errorWithPrefixedCode, context)
    Note over ErrSys: Records metric, ensures CoreError type
    ErrSys->>ErrSys: 5. Lookup Handler (based on error.constructor.name)

    alt Specific Handler Found
        ErrSys->>CustomHndlr: 6a. specificHandler(errorWithPrefixedCode, context)
        CustomHndlr->>CustomHndlr: (Performs custom actions)
        CustomHndlr-->>ErrSys: (Handler completes)
    else Default CoreError Handler
        ErrSys->>DefaultHndlr: 6b. defaultCoreErrorHandler(errorWithPrefixedCode, context)
        DefaultHndlr->>Logger: Logs error via this.deps.logger
        DefaultHndlr-->>ErrSys: (Handler completes)
    end
    
    ErrSys->>ErrSys: 7. Emits 'error:handled' or 'error:handler_failed'

    opt HTTP Context Error (Error propagates to Framework)
        AppComp-->>FwInt: (Error reaches Framework's global handler, uses Integration)
        FwInt->>FwInt: mapError(rawError) -> mappedCoreError (with prefixed code)
        FwInt->>ErrSys: (Potentially) errorSystem.handleError(mappedCoreError, reqContext)
        FwInt->>FwInt: serializeError(mappedCoreError) -> httpPayload
        FwInt-->>HttpClient: HTTP Error Response
    end
```

**Best Practices:**
* **Specificity**: Use the most specific `CoreError` subclass. Pass the corresponding *unprefixed specific code* from `ErrorCodes.js` to its constructor[cite: 1863].
* **Context is Key**: Always provide rich, serializable `details` and wrap `cause`[cite: 1863].
* **Report, Don't Just Log (Usually)**: Prefer reporting to `ErrorSystem` over just `console.log` for significant errors[cite: 1864].
* **Idempotent Handlers**: Design custom error handlers in `ErrorSystem` to be idempotent if they might be called multiple times[cite: 1865].
* **Security**: Be mindful of not leaking sensitive information in error messages or details exposed to clients. `CoreError.toJSON()` and framework serializers should consider this[cite: 1867].
* **Test Error Paths**: Thoroughly test error conditions[cite: 1868].

---
## 9. Testing Strategies for the Error Handling System
* **`CoreError` & Subclasses**: Verify properties, `toJSON()` (dev/prod), `cause`, `fromJSON()`. For subclasses, test `statusCode` and specific properties (e.g., `ValidationError.validationErrors`).
* **`ErrorCodes.js`**: Ensure correct import and use in error instantiation tests[cite: 1870].
* **`ErrorSystem.js`**:
    * Test `initialize()`/`shutdown()` lifecycles, state, events.
    * Test `registerHandler()`: invocation by `handleError()` based on error type.
    * Test `handleError()`: with `CoreError`s, subclasses, native errors (wrapping), event emissions.
    * Test `defaultCoreErrorHandler` behavior.
    * Test `createError()` factory method.
    * Test `registerIntegration()` with mock `IFrameworkIntegration`.
    * Test internal error handling.
    * Test health checks and metrics.
* **`IFrameworkIntegration.js` Implementations (e.g., `FastifyErrorHandler.js`)**:
    * Test `initialize()` with mock framework.
    * Test `mapError()` with various errors for correct mapping to `CoreError` types.
    * Test `serializeError()` for correct HTTP payload generation.
    * Conduct integration tests with mock framework routes.
* **`ErrorUtils.js`**:
    * Test `safeHandleError()` with working, null/invalid, and failing `ErrorSystem` mock, verify console fallbacks.
    * Test `createStandardHealthCheckResult()` for correct output structure.

---
## 10. Future Considerations & Improvements for Error Handling
(Drawn from the more general "ErrorSystem Related" in the main SoT conclusion)
* **Enhanced Error Tracking & Analytics**: Aggregation, deduplication, unique IDs for cross-system tracing. Integration with services like Sentry, Rollbar[cite: 1882].
* **Expanded Framework Integrations**: Adapters for other frameworks (Express, Koa) or API styles (GraphQL)[cite: 1883].
* **Security for Error Details**: Sophisticated sanitization and configurable redaction for sensitive data[cite: 1884].
* **Error Analysis Tools**: Develop tools for pattern analysis, automated root cause analysis[cite: 1885].
* **Improved Developer Experience for Error Debugging**: Enhance context in dev mode, link error codes to detailed documentation[cite: 1886].
* **Error Code to Message Localization**: For user-facing errors, map `ErrorCodes` to localized messages[cite: 1887].


// src/core/errors/index.js

/**
 * @file src/core/errors/index.js
 * @description Main public interface for the TSMIS Error System.
 * Exports CoreError, ErrorSystem, factory functions, all specific error types,
 * standardized error codes, and framework integration components.
 */

import { CoreError } from './CoreError.js';
import { ErrorSystem, createErrorSystem } from './ErrorSystem.js';
import { ErrorCodes } from './ErrorCodes.js'; // Assuming ErrorCodes.js is now a separate file

// Import all specific error types and the ErrorTypes namespace from ./types/index.js
import * as SpecificErrorTypes from './types/index.js';

// Import integration components from ./integrations/index.js
import * as Integrations from './integrations/index.js';

// Export the main classes and factory
export {
  CoreError,
  ErrorSystem,
  createErrorSystem,
  ErrorCodes,
};

// Export all specific error types individually for direct consumption
export {
  SpecificErrorTypes_ AccessError,
  SpecificErrorTypes_ AuthError,
  SpecificErrorTypes_ ConfigError,
  SpecificErrorTypes_ EventError,
  SpecificErrorTypes_ ModuleError,
  SpecificErrorTypes_ NetworkError,
  SpecificErrorTypes_ RouterError,
  SpecificErrorTypes_ ServiceError,
  SpecificErrorTypes_ ValidationError,
} from './types/index.js'; // This re-exports named exports from types/index.js

// Export the ErrorTypes namespace object
// (This is the object containing all specific error type classes, e.g., ErrorTypes.ValidationError)
export const ErrorTypes = SpecificErrorTypes.ErrorTypes;


// Export integration-related components
export {
  Integrations_ IFrameworkIntegration,
  Integrations_ FastifyErrorHandler, // The class itself
  Integrations_ createFastifyLoggerErrorSerializer, // The utility function
  // Add other specific integrations here if they are directly exported, e.g., ExpressErrorHandler
} from './integrations/index.js';


/**
 * Utility function to create a CoreError (or subclass) from an HTTP-like response object.
 * This is similar to the original `createErrorFromResponse`.
 *
 * @param {object} response - The response object, expected to have properties like
 * `data.name`, `data.code`, `data.message`, `data.details`.
 * If `data` is not present, it will look at the root of `response`.
 * @param {string} [defaultMessage='Unknown error occurred'] - Default message if not found in response.
 * @returns {CoreError} An instance of CoreError or its determined subclass.
 */
export function createErrorFromResponse(response, defaultMessage = 'Unknown error occurred') {
  const errorData = response?.data || response || {}; // [cite: 333]
  let message = errorData.message || defaultMessage; // [cite: 335]
  let code = errorData.code || ErrorCodes.CORE.UNKNOWN_ERROR; // [cite: 335]
  let details = errorData.details || {}; // [cite: 335]
  let cause = errorData.cause; // The original createErrorFromResponse passed the whole response as cause [cite: 335]

  // Determine the ErrorConstructor based on errorData.name
  // This relies on ErrorTypes namespace being available (either imported here or from SpecificErrorTypes)
  const ErrorConstructor = SpecificErrorTypes.ErrorTypes[errorData.name] || CoreError; // [cite: 334]

  // If the ErrorConstructor is a specific type (e.g., ValidationError),
  // the code passed to it should be the specific part, not the prefixed one.
  // However, errorData.code might already be the full prefixed code if coming from another TSMIS service.
  // For now, we assume errorData.code is the intended code to pass to the constructor.
  // The constructors of specific error types will add their prefixes.
  // If errorData.code ALREADY has a prefix and ErrorConstructor is specific, it might get double-prefixed.
  // This needs careful handling based on expected `errorData.code` format.
  // Let's assume `errorData.code` is the *full* code for now, and constructors are idempotent with prefixes
  // OR that `errorData.code` is the *specific* part of the code.
  // Given the refactored error constructors expect the specific part (e.g. 'INVALID_INPUT'),
  // we might need to strip a prefix from `errorData.code` if `ErrorConstructor` is not `CoreError`.

  if (ErrorConstructor !== CoreError && typeof code === 'string') {
    const prefix = `${ErrorConstructor.name.replace('Error', '').toUpperCase()}_`; // e.g., VALIDATION_
    if (code.startsWith(prefix)) {
        // Code already seems to have a prefix that matches the error type name,
        // or it's a code that the subclass constructor expects without the prefix.
        // The subclass constructors now expect the unprefixed code.
        // So, if `errorData.name` is `ValidationError` and `code` is `VALIDATION_INVALID_INPUT`,
        // we should pass `INVALID_INPUT` to `new ValidationError()`.
        code = code.substring(prefix.length);
    } else if (code.includes('_') && ErrorConstructor.name.toUpperCase().startsWith(code.split('_')[0])) {
        // Heuristic: If code is FOO_BAR and ErrorConstructor is FooError, pass BAR.
        // This is a bit fragile. Better if errorData.code is always the non-prefixed version
        // when errorData.name indicates a specific type.
        // For now, we'll pass it as is and rely on constructor logic or specific code format.
    }
  }


  const errorInstance = new ErrorConstructor(
    code,
    message,
    details,
    { cause: cause || response } // Pass original response as part of the cause if no specific cause data
  );

  // If errorData.name was present and we used CoreError as fallback, set the name.
  if (errorData.name && ErrorConstructor === CoreError && errorInstance.name !== errorData.name) {
      errorInstance.name = errorData.name;
  }

  // For ValidationError, specifically re-attach validationErrors if present in details
  if (errorInstance instanceof SpecificErrorTypes.ValidationError && Array.isArray(details.validationErrors)) {
    errorInstance.validationErrors = details.validationErrors;
  }

  return errorInstance;
}

// Default export can be the ErrorTypes namespace or the ErrorSystem class,
// depending on the most common usage.
// Your original had 'export default ErrorTypes;' [cite: 336]
// Sticking to named exports mostly, but if a default is desired:
// export default ErrorTypes;
// Or for more comprehensive default:
export default {
  CoreError,
  ErrorSystem,
  createErrorSystem,
  ErrorCodes,
  ErrorTypes: SpecificErrorTypes.ErrorTypes, // Explicitly re-exporting here too
  createErrorFromResponse,
  Integrations,
  // Individually exporting types again for convenience if default is used by consumer
  AccessError: SpecificErrorTypes.AccessError,
  AuthError: SpecificErrorTypes.AuthError,
  ConfigError: SpecificErrorTypes.ConfigError,
  EventError: SpecificErrorTypes.EventError,
  ModuleError: SpecificErrorTypes.ModuleError,
  NetworkError: SpecificErrorTypes.NetworkError,
  RouterError: SpecificErrorTypes.RouterError,
  ServiceError: SpecificErrorTypes.ServiceError,
  ValidationError: SpecificErrorTypes.ValidationError,
};


// src/core/errors/integrations/IFrameworkIntegration.js

/**
 * @file IFrameworkIntegration.js
 * @description Defines the interface for framework-specific error handling integrations
 * that work with the ErrorSystem.
 */

import { CoreError } from '../CoreError.js'; // For type hinting and potential use in implementations

/**
 * @interface IFrameworkIntegration
 * @description Interface that framework-specific error handling integrations must implement.
 * These integrations bridge the ErrorSystem with HTTP frameworks like Fastify or Express.
 */
export class IFrameworkIntegration {
  /**
   * Initializes the integration with the specific web framework instance.
   * This method should set up global error handlers for the framework.
   *
   * @param {object} framework - The instance of the web framework (e.g., Fastify app, Express app).
   * @param {object} [options={}] - Integration-specific options. May include a reference to ErrorSystem.
   * @param {ErrorSystem} [options.errorSystem] - An instance of the ErrorSystem for centralized error processing.
   * @param {object} [options.logger] - A logger instance.
   * @returns {Promise<void>|void}
   * @throws {Error} If initialization fails or framework instance is invalid.
   */
  async initialize(framework, options = {}) { // [cite: 337]
    throw new Error('IFrameworkIntegration.initialize() must be implemented by subclass.');
  }

  /**
   * Maps a raw error (often framework-specific or a native JavaScript Error)
   * to a standardized CoreError instance or one of its subclasses.
   *
   * @param {Error} frameworkError - The raw error object caught by the framework.
   * @param {object} [requestContext={}] - Optional context from the request (e.g., request.id, url, method).
   * @returns {CoreError} An instance of CoreError or its subclass.
   * @throws {Error} If mapping fails.
   */
  mapError(frameworkError, requestContext = {}) { // [cite: 339]
    throw new Error('IFrameworkIntegration.mapError() must be implemented by subclass.');
  }

  /**
   * Serializes a CoreError instance into a format suitable for an HTTP response body.
   *
   * @param {CoreError} coreError - The CoreError instance to serialize.
   * @param {object} [requestContext={}] - Optional context from the request.
   * @returns {object} A plain object representing the error response payload.
   * @throws {Error} If serialization fails.
   */
  serializeError(coreError, requestContext = {}) { // [cite: 338]
    throw new Error('IFrameworkIntegration.serializeError() must be implemented by subclass.');
  }

  /**
   * Optional method for integrations to perform cleanup during ErrorSystem shutdown.
   * @returns {Promise<void>|void}
   */
  async shutdown() {
    // Optional: Subclasses can implement this if they need to clean up resources.
  }
}

// For clarity, an interface is often not exported as default if it's truly just a contract.
// However, if it's used as a base class from which others must inherit (as in JS), default export is fine.
// export default IFrameworkIntegration;


// src/core/errors/integrations/fastify/FastifyErrorHandler.js

/**
 * @file FastifyErrorHandler.js
 * @description Implements IFrameworkIntegration for Fastify, providing standardized
 * error handling, mapping, and serialization for Fastify applications.
 */

import { IFrameworkIntegration } from '../IFrameworkIntegration.js';
import { CoreError } from '../../CoreError.js';
import { ErrorCodes } from '../../ErrorCodes.js';
import { ValidationError, NetworkError } from '../../types/index.js'; // Ensure types index exports these

export class FastifyErrorHandler extends IFrameworkIntegration {
  /**
   * @type {ErrorSystem | null}
   */
  errorSystem = null;
  /**
   * @type {object}
   */
  logger = console;
  /**
   * @type {boolean}
   */
  initialized = false;

  constructor() {
    super();
    // Dependencies like errorSystem and logger will be passed via options in initialize
  }

  /**
   * Initializes the Fastify error handling integration.
   * Sets up Fastify's global error handler and an onRequest hook for error context.
   * @param {object} fastify - The Fastify framework instance.
   * @param {object} [options={}] - Integration options.
   * @param {ErrorSystem} [options.errorSystem] - The ErrorSystem instance for processing errors.
   * @param {object} [options.logger] - A logger instance.
   * @override
   */
  async initialize(fastify, options = {}) {
    if (this.initialized) {
      this.logger.warn('[FastifyErrorHandler] Already initialized.');
      return;
    }
    if (!fastify || typeof fastify.setErrorHandler !== 'function' || typeof fastify.addHook !== 'function') {
      throw new CoreError(ErrorCodes.CORE.INVALID_ARGUMENT, 'Invalid Fastify instance provided to FastifyErrorHandler.');
    }

    this.errorSystem = options.errorSystem;
    this.logger = options.logger || this.logger;

    // Add error context to request
    fastify.addHook('onRequest', async (request, reply) => {
      // Create a basic error context on the request object
      // This can be enriched by other middleware or route handlers
      request.errorContext = {
        requestId: request.id,
        url: request.raw?.url || request.url, // Prefer raw.url if available
        method: request.raw?.method || request.method,
        ip: request.ip,
        timestamp: new Date().toISOString(),
      };
    });

    // Set Fastify's global error handler
    fastify.setErrorHandler(async (error, request, reply) => {
      const requestContext = { // Augment context from request if available
        ...(request.errorContext || {}), // Base context from onRequest hook
        params: request.params,
        query: request.query,
        // Avoid logging full body by default unless configured, can be large/sensitive
        // bodySummary: request.body ? { keys: Object.keys(request.body) } : undefined,
      };

      // 1. Map the raw Fastify error to a CoreError instance
      const mappedCoreError = this.mapError(error, requestContext);

      // 2. Process with ErrorSystem (logging, custom handlers, metrics, etc.)
      if (this.errorSystem && typeof this.errorSystem.handleError === 'function') {
        await this.errorSystem.handleError(mappedCoreError, requestContext);
      } else {
        // Fallback logging if ErrorSystem is not available
        this.logger.error('[FastifyErrorHandler] ErrorSystem not available. Logging raw mapped error:', {
          error: mappedCoreError.toJSON ? mappedCoreError.toJSON() : mappedCoreError,
          context: requestContext,
        });
      }

      // 3. Serialize the CoreError for the HTTP response
      const responsePayload = this.serializeError(mappedCoreError, requestContext);

      // 4. Send the HTTP response
      // Ensure status code is a number and in valid HTTP range
      let statusCode = mappedCoreError.statusCode || 500;
      if (typeof statusCode !== 'number' || statusCode < 100 || statusCode > 599) {
          this.logger.warn(`[FastifyErrorHandler] Invalid statusCode ${statusCode} from error ${mappedCoreError.code}. Defaulting to 500.`);
          statusCode = 500;
      }
      reply.status(statusCode).send(responsePayload);
    });

    this.initialized = true;
    this.logger.info('[FastifyErrorHandler] Initialized and Fastify error handler set.');
  }

  /**
   * Maps a raw Fastify error to a standardized CoreError.
   * @param {Error} frameworkError - The error object caught by Fastify.
   * @param {object} [requestContext={}] - Context from the HTTP request.
   * @returns {CoreError}
   * @override
   */
  mapError(frameworkError, requestContext = {}) { //
    if (frameworkError instanceof CoreError) {
      return frameworkError; //
    }

    // Handle Fastify's built-in validation errors (FST_ERR_VALIDATION)
    if (frameworkError.code === 'FST_ERR_VALIDATION' || frameworkError.validation) { //
      const validationDetails = frameworkError.validation?.map(vErr => ({
        field: vErr.dataPath || vErr.instancePath || 'N/A', // dataPath for ajv v6, instancePath for v7+
        message: vErr.message,
        keyword: vErr.keyword,
        params: vErr.params,
      }));
      const validationError = new ValidationError(
        ErrorCodes.VALIDATION.SCHEMA_MISMATCH || 'SCHEMA_MISMATCH', // Using a defined code
        frameworkError.message || 'Request validation failed.',
        { validationErrors: validationDetails || [], rawFastifyValidation: frameworkError.validation },
        { cause: frameworkError }
      );
      validationError.statusCode = frameworkError.statusCode || 400;
      return validationError;
    }

    // Handle Fastify's Not Found errors (FST_ERR_NOT_FOUND)
    if (frameworkError.code === 'FST_ERR_NOT_FOUND' || frameworkError.statusCode === 404) { //
      const path = requestContext?.url || 'unknown path';
      const method = requestContext?.method || 'unknown method';
      const notFoundError = new NetworkError(
        ErrorCodes.NETWORK.ROUTE_NOT_FOUND, //
        `Route ${method} ${path} not found.`,
        { method, path },
        { cause: frameworkError }
      );
      notFoundError.statusCode = 404;
      return notFoundError;
    }

    // Generic error mapping
    const message = frameworkError.message || 'An unexpected error occurred.';
    const details = {
      originalErrorName: frameworkError.name,
      // Avoid exposing raw error in production by default from generic mapping
      ...( (this.errorSystem && this.errorSystem.deps.config?.isDevEnvironment) || // Check dev env via errorSystem config
           (process.env.NODE_ENV === 'development' || process.env.NODE_ENV === 'test')
           ? { rawError: String(frameworkError) } : {} )
    };

    const genericError = new CoreError(
      ErrorCodes.CORE.UNKNOWN_ERROR, //
      message,
      details,
      { cause: frameworkError }
    );
    genericError.statusCode = typeof frameworkError.statusCode === 'number' ? frameworkError.statusCode : 500; //
    return genericError;
  }

  /**
   * Serializes a CoreError for an HTTP response.
   * @param {CoreError} coreError - The CoreError instance.
   * @param {object} [requestContext={}] - Context from the HTTP request.
   * @returns {object} The error payload for the HTTP response.
   * @override
   */
  serializeError(coreError, requestContext = {}) { //
    if (coreError instanceof CoreError) {
      const serialized = coreError.toJSON(); //
      // Add minimal, safe request context to the response payload if desired
      return { //
        ...serialized,
        // Only include non-sensitive parts of requestContext if needed for client
        // context: { requestId: requestContext?.requestId } // Example
      };
    }

    // Fallback for non-CoreError (should ideally be caught by mapError)
    this.logger.warn('[FastifyErrorHandler] serializeError received a non-CoreError:', coreError);
    return { //
      name: coreError.name || 'Error',
      code: ErrorCodes.CORE.UNKNOWN_ERROR, //
      message: coreError.message || 'An unexpected error occurred.',
      timestamp: new Date().toISOString(),
      // context: { requestId: requestContext?.requestId }
    };
  }

  /**
   * Optional shutdown logic for the integration.
   */
  async shutdown() {
    this.initialized = false;
    this.logger.info('[FastifyErrorHandler] Shutdown.');
    // No specific resources to release for this basic handler.
  }
}


// src/core/errors/integrations/fastify/FastifyErrorSerializer.js

/**
 * @file FastifyErrorSerializer.js
 * @description Provides a utility for creating a Fastify logger error serializer
 * using a standardized error serialization method.
 */

/**
 * Creates a Fastify logger error serializer object.
 * This is intended to be used when configuring the Fastify logger instance.
 * The provided `serializeMethod` should be the `serializeError` method from an
 * instantiated and configured FastifyErrorHandler.
 *
 * @example
 * // In your Fastify setup:
 * // const errorSystem = await container.resolve('errorSystem');
 * // const fastifyFrameworkInstance = Fastify({ logger: true }); // example
 * // const options = { errorSystem, logger: fastifyFrameworkInstance.log };
 * // const fastifyErrorHandlerInstance = new FastifyErrorHandler(); // ErrorSystem would typically do this
 * // await fastifyErrorHandlerInstance.initialize(fastifyFrameworkInstance, options);
 * //
 * // const fastify = Fastify({
 * //   logger: {
 * //     level: 'info',
 * //     serializers: {
 * //       // Use the serializeError method from your configured FastifyErrorHandler instance
 * //       error: createFastifyLoggerErrorSerializer(fastifyErrorHandlerInstance.serializeError.bind(fastifyErrorHandlerInstance))
 * //     }
 * //   }
 * // });
 *
 * @param {Function} serializeMethod - The method to use for serializing errors.
 * This should typically be `fastifyErrorHandlerInstance.serializeError.bind(fastifyErrorHandlerInstance)`.
 * It's expected to take an error and an optional context, returning a plain object.
 * @returns {{serializer: Function}} A Fastify logger serializer object for errors.
 */
export function createFastifyLoggerErrorSerializer(serializeMethod) {
  if (typeof serializeMethod !== 'function') {
    console.warn('[FastifyErrorSerializer] serializeMethod provided is not a function. Logger might not serialize errors correctly.');
    // Fallback to a very basic serializer
    return {
      serializer: (error) => {
        return {
          message: error.message,
          stack: error.stack,
          code: error.code,
          name: error.name,
          type: Object.prototype.toString.call(error).slice(8, -1)
        };
      }
    };
  }
  return {
    // The serializer function for Fastify logger takes only the error object.
    // Our `serializeError` method takes `(coreError, requestContext = {})`.
    // For logger purposes, requestContext might not be available or relevant.
    // We pass an empty context.
    serializer: (error) => serializeMethod(error, {}),
  };
}

// Note: The original file directly imported a singleton.
// This version is a utility function because FastifyErrorHandler is no longer a singleton.
// The application setup code is responsible for instantiating FastifyErrorHandler
// (likely via ErrorSystem.registerIntegration) and then using its serializeError
// method when configuring Fastify's logger.

// If you want a more direct export similar to the original, and assuming you
// will *always* have a single, globally accessible instance of FastifyErrorHandler
// (which is less aligned with the DI pattern for ErrorSystem managing integrations),
// then that instance would need to be exported from somewhere and imported here.
// The functional approach above is more flexible.


// src/core/errors/integrations/fastify/index.js

/**
 * @file src/core/errors/integrations/fastify/index.js
 * @description Barrel file for exporting Fastify error integration components.
 */

import { FastifyErrorHandler } from './FastifyErrorHandler.js';
import { createFastifyLoggerErrorSerializer } from './FastifyErrorSerializer.js';

export {
  FastifyErrorHandler,
  createFastifyLoggerErrorSerializer
};

// Optional: If you want to export a pre-configured or default setup function
// similar to the original `setupErrorHandler`, you could add it here,
// but it would typically be part of application bootstrap code or a higher-level setup utility.
// For example:
//
// export function setupFastifyErrorHandling(fastifyInstance, errorSystemInstance, loggerInstance) {
//   const handler = new FastifyErrorHandler();
//   handler.initialize(fastifyInstance, { errorSystem: errorSystemInstance, logger: loggerInstance });
//
//   // To configure logger serializer (example, actual logger config is more complex):
//   // if (fastifyInstance.log && fastifyInstance.log.serializers) {
//   //   fastifyInstance.log.serializers.error = createFastifyLoggerErrorSerializer(handler.serializeError.bind(handler));
//   // }
//   return handler; // Return the instance if needed
// }

// The original file [cite: 372] exported `setupErrorHandler` from `handler.js`
// and `errorSerializer` from `serializer.js`.
// Our refactored approach exports the class `FastifyErrorHandler` and the utility
// function `createFastifyLoggerErrorSerializer`. The actual setup (instantiation
// and initialization of FastifyErrorHandler) is now handled by ErrorSystem.registerIntegration
// or directly in the application's Fastify setup code.


// src/core/errors/integrations/index.js

/**
 * @file src/core/errors/integrations/index.js
 * @description Barrel file for exporting error handling integration interfaces and modules.
 */

import { IFrameworkIntegration } from './IFrameworkIntegration.js';
import {
  FastifyErrorHandler,
  createFastifyLoggerErrorSerializer
} from './fastify/index.js'; // Imports from the fastify integration's own index.js

// You would add other integrations here if they existed, e.g.:
// import { ExpressErrorHandler } from './express/index.js';

export {
  IFrameworkIntegration,
  FastifyErrorHandler,
  createFastifyLoggerErrorSerializer,
  // ExpressErrorHandler, // Example if it existed
};

// Optionally, provide a default export if that suits your module consumption pattern,
// though named exports are generally clear for ES Modules.
// export default {
//   IFrameworkIntegration,
//   fastify: {
//     FastifyErrorHandler,
//     createFastifyLoggerErrorSerializer,
//   },
//   // express: { ExpressErrorHandler }
// };


// src/core/errors/types/AccessError.js

/**
 * @file AccessError.js
 * @description Defines errors related to authorization and access control.
 */

import { CoreError } from '../CoreError.js';

/**
 * Represents an error where access to a resource or operation is denied.
 * Typically corresponds to HTTP 403 Forbidden.
 * @extends CoreError
 */
export class AccessError extends CoreError {
  /**
   * Creates a new AccessError instance.
   * The constructor will prepend "ACCESS_" to the provided specific code.
   * @param {string} code - A specific, **unprefixed** error code from `ErrorCodes.ACCESS` (e.g., 'INSUFFICIENT_PERMISSIONS').
   * @param {string} message - A human-readable description of the error.
   * @param {object} [details={}] - Additional details about the access error.
   * @param {object} [options={}] - Additional error options, including 'cause'.
   */
  constructor(code, message, details = {}, options = {}) {
    super(`ACCESS_${code}`, message, details, options); // [cite: 2038]
    this.name = 'AccessError';
    this.statusCode = 403; // [cite: 2038]
  }
}


// src/core/errors/types/AuthError.js

/**
 * @file AuthError.js
 * @description Defines errors related to authentication.
 */

import { CoreError } from '../CoreError.js'; // [cite: 375]

/**
 * Represents an error during the authentication process.
 * Typically corresponds to HTTP 401 Unauthorized.
 * @extends CoreError
 */
export class AuthError extends CoreError {
  /**
   * Creates a new AuthError instance.
   * The constructor will prepend "AUTH_" to the provided specific code.
   * @param {string} code - A specific, **unprefixed** error code from `ErrorCodes.AUTH` (e.g., 'INVALID_CREDENTIALS', 'TOKEN_EXPIRED').
   * @param {string} message - A human-readable description of the error.
   * @param {object} [details={}] - Additional details about the authentication error.
   * @param {object} [options={}] - Additional error options, including 'cause'.
   */
  constructor(code, message, details = {}, options = {}) {
    super(`AUTH_${code}`, message, details, options); // [cite: 376]
    this.name = 'AuthError';
    this.statusCode = 401; // [cite: 376]
  }
}


// src/core/errors/types/ConfigError.js

/**
 * @file ConfigError.js
 * @description Defines errors related to application configuration.
 */

import { CoreError } from '../CoreError.js'; // [cite: 2047]

/**
 * Represents an error encountered during application configuration loading, validation, or access.
 * Typically corresponds to HTTP 500 Internal Server Error.
 * @extends CoreError
 */
export class ConfigError extends CoreError {
  /**
   * Creates a new ConfigError instance.
   * The constructor will prepend "CONFIG_" to the provided specific code.
   * @param {string} code - A specific, **unprefixed** error code from `ErrorCodes.CONFIG` (e.g., 'LOAD_FAILED', 'VALIDATION_FAILED').
   * @param {string} message - A human-readable description of the error.
   * @param {object} [details={}] - Additional details about the configuration error.
   * @param {object} [options={}] - Additional error options, including 'cause'.
   */
  constructor(code, message, details = {}, options = {}) {
    super(`CONFIG_${code}`, message, details, options); // [cite: 2054]
    this.name = 'ConfigError';
    this.statusCode = 500; // [cite: 2054]
  }
}


// src/core/errors/types/EventError.js

/**
 * @file EventError.js
 * @description Defines errors related to the event system.
 */

import { CoreError } from '../CoreError.js'; // [cite: 2055]

/**
 * Represents an error occurring within the event bus or event handling system.
 * Typically corresponds to HTTP 500 Internal Server Error. [cite: 2056]
 * @extends CoreError
 */
export class EventError extends CoreError {
  /**
   * Creates a new EventError instance.
   * The constructor will prepend "EVENT_" to the provided specific code.
   * @param {string} code - A specific, **unprefixed** error code from `ErrorCodes.EVENT` (e.g., 'EMIT_FAILED', 'HANDLER_ERROR').
   * @param {string} message - A human-readable description of the error. [cite: 2059]
   * @param {object} [details={}] - Additional details about the event system error. [cite: 2060]
   * @param {object} [options={}] - Additional error options, including 'cause'. [cite: 2061]
   */
  constructor(code, message, details = {}, options = {}) {
    super(`EVENT_${code}`, message, details, options); // [cite: 2062]
    this.name = 'EventError';
    this.statusCode = 500; // [cite: 2062]
  }
}


// src/core/errors/types/ModuleError.js

/**
 * @file ModuleError.js
 * @description Defines errors related to the module system.
 */

import { CoreError } from '../CoreError.js'; // [cite: 2063]

/**
 * Represents an error occurring within a module or the module management system.
 * Typically corresponds to HTTP 500 Internal Server Error.
 * @extends CoreError
 */
export class ModuleError extends CoreError {
  /**
   * Creates a new ModuleError instance.
   * The constructor will prepend "MODULE_" to the provided specific code.
   * @param {string} code - A specific, **unprefixed** error code from `ErrorCodes.MODULE` (e.g., 'LOAD_FAILED', 'DEPENDENCY_MISSING').
   * @param {string} message - A human-readable description of the error.
   * @param {object} [details={}] - Additional details about the module system error.
   * @param {object} [options={}] - Additional error options, including 'cause'.
   */
  constructor(code, message, details = {}, options = {}) {
    super(`MODULE_${code}`, message, details, options); // [cite: 2070]
    this.name = 'ModuleError';
    this.statusCode = 500; // [cite: 2070]
  }
}


// src/core/errors/types/NetworkError.js

/**
 * @file NetworkError.js
 * @description Defines errors related to network operations.
 */

import { CoreError } from '../CoreError.js'; // [cite: 2071]

/**
 * Represents an error occurring during network communication (e.g., request timeouts, connection issues).
 * Default statusCode is 503 Service Unavailable, but can be overridden by details.statusCode.
 * @extends CoreError
 */
export class NetworkError extends CoreError {
  /**
   * Creates a new NetworkError instance.
   * The constructor will prepend "NETWORK_" to the provided specific code.
   * @param {string} code - A specific, **unprefixed** error code from `ErrorCodes.NETWORK` (e.g., 'REQUEST_TIMEOUT', 'CONNECTION_REFUSED').
   * @param {string} message - A human-readable description of the error.
   * @param {object} [details={}] - Additional details about the network error. Can include `details.statusCode` to override default.
   * @param {object} [options={}] - Additional error options, including 'cause'.
   */
  constructor(code, message, details = {}, options = {}) {
    super(`NETWORK_${code}`, message, details, options); // [cite: 2079]
    this.name = 'NetworkError';
    // Original code allowed details.statusCode to override. We'll keep this behavior.
    this.statusCode = (details && typeof details.statusCode === 'number') ? details.statusCode : 503; // [cite: 2080, 2081]
  }
}


// src/core/errors/types/RouterError.js

/**
 * @file RouterError.js
 * @description Defines errors related to the routing system.
 */
import { CoreError } from '../CoreError.js';

/**
 * Represents an error occurring within the routing system (e.g., route not found, registration conflict).
 * Typically corresponds to HTTP 500 Internal Server Error for system issues, or others depending on context.
 * @extends CoreError
 */
export class RouterError extends CoreError {
  /**
   * Creates a new RouterError instance.
   * The constructor will prepend "ROUTER_" to the provided specific code.
   * @param {string} code - A specific, **unprefixed** error code from `ErrorCodes.ROUTER` (e.g., 'ROUTE_NOT_FOUND', 'INVALID_ADAPTER').
   * @param {string} message - A human-readable description of the error.
   * @param {object} [details={}] - Additional details about the router system error.
   * @param {object} [options={}] - Additional error options, including 'cause'.
   */
  constructor(code, message, details = {}, options = {}) {
    super(`ROUTER_${code}`, message, details, options); // [cite: 2090]
    this.name = 'RouterError';
    this.statusCode = 500; // [cite: 2090]
  }
}


// src/core/errors/types/ServiceError.js

/**
 * @file ServiceError.js
 * @description Defines errors related to service-level operations.
 */

import { CoreError } from '../CoreError.js'; // [cite: 2094]

/**
 * Represents an error occurring within a service or a dependency it relies on.
 * Typically corresponds to HTTP 503 Service Unavailable. [cite: 2095]
 * @extends CoreError
 */
export class ServiceError extends CoreError {
  /**
   * Creates a new ServiceError instance.
   * The constructor will prepend "SERVICE_" to the provided specific code.
   * @param {string} code - A specific, **unprefixed** error code from `ErrorCodes.SERVICE` (e.g., 'DATABASE_UNAVAILABLE', 'EXTERNAL_API_FAILED').
   * @param {string} message - A human-readable description of the error. [cite: 2097]
   * @param {object} [details={}] - Additional details about the service error. [cite: 2098]
   * @param {object} [options={}] - Additional error options, including 'cause'. [cite: 2099]
   */
  constructor(code, message, details = {}, options = {}) {
    super(`SERVICE_${code}`, message, details, options); // [cite: 2101]
    this.name = 'ServiceError';
    this.statusCode = 503; // [cite: 2101]
  }
}


// src/core/errors/types/ValidationError.js

/**
 * @file ValidationError.js
 * @description Defines errors related to data validation.
 */

import { CoreError } from '../CoreError.js'; // [cite: 2102]

/**
 * Represents an error that occurs when input data fails validation.
 * Typically corresponds to HTTP 400 Bad Request.
 * @extends CoreError
 */
export class ValidationError extends CoreError {
  /**
   * Creates a new ValidationError instance.
   * The constructor will prepend "VALIDATION_" to the provided specific code.
   * @param {string} code - A specific, **unprefixed** error code from `ErrorCodes.VALIDATION` (e.g., 'INVALID_INPUT', 'SCHEMA_MISMATCH').
   * @param {string} message - A human-readable description of the error.
   * @param {object} [details={}] - Additional details, expected to contain a `validationErrors` array.
   * @param {Array<object>} [details.validationErrors=[]] - An array of specific validation failure objects (e.g., { field, message }).
   * @param {object} [options={}] - Additional error options, including 'cause'.
   */
  constructor(code, message, details = {}, options = {}) {
    super(`VALIDATION_${code}`, message, details, options); // [cite: 2110]
    this.name = 'ValidationError';
    this.statusCode = 400; // [cite: 2110]
    // Ensure validationErrors is always an array, even if not provided or malformed in details.
    this.validationErrors = Array.isArray(details?.validationErrors) ? details.validationErrors : []; // [cite: 2111]
  }

  /**
   * Converts the error object to a JSON representation, including `validationErrors`.
   * @returns {object} A plain object representation of the error.
   */
  toJSON() {
    const json = super.toJSON(); //
    json.validationErrors = this.validationErrors; // [cite: 2114]
    return json;
  }

  /**
   * Creates a ValidationError instance from a JSON-like object.
   * @static
   * @param {object} data - The plain object containing error data.
   * @returns {ValidationError} An instance of ValidationError.
   */
  static fromJSON(data) {
    const errorInstance = super.fromJSON(data, ValidationError); // [cite: 2117]
    // Pass ValidationError as the type
    // Ensure validationErrors is an array after deserialization.
    errorInstance.validationErrors = Array.isArray(data?.validationErrors) ? data.validationErrors : []; // [cite: 2118]
    return errorInstance;
  }
}


// src/core/errors/types/index.js

/**
 * @file src/core/errors/types/index.js
 * @description Barrel file for exporting all specific CoreError subclasses
 * and an ErrorTypes namespace object.
 */

import { AccessError } from './AccessError.js';
import { AuthError } from './AuthError.js';
import { ConfigError } from './ConfigError.js';
import { EventError } from './EventError.js';
import { ModuleError } from './ModuleError.js';
import { NetworkError } from './NetworkError.js';
import { RouterError } from './RouterError.js';
import { ServiceError } from './ServiceError.js';
import { ValidationError } from './ValidationError.js';

// Export individual error types for direct import
export {
  AccessError,
  AuthError,
  ConfigError,
  EventError,
  ModuleError,
  NetworkError,
  RouterError,
  ServiceError,
  ValidationError,
};

// Create and export the ErrorTypes namespace object
// This provides a convenient way to access error types, similar to the original.
export const ErrorTypes = Object.freeze({
  AccessError,
  AuthError,
  ConfigError,
  EventError,
  ModuleError,
  NetworkError,
  RouterError,
  ServiceError,
  ValidationError,
});

// Optionally, make ErrorTypes the default export if desired,
// though named exports are common for ES Modules.
// The original had 'export default ErrorTypes;' [cite: 400] which is also fine.
// For consistency with how we are handling other index files that export multiple things,
// sticking to named exports for `ErrorTypes` might be cleaner unless a default is strongly preferred.


// src/core/event/CoreEventBus.js

/**
 * @file CoreEventBus.js
 * @description Centralized event bus for robust event management, queuing, and history.
 */

import { EventEmitter } from 'events'; // Node.js built-in
import { EventError } from '../errors/index.js'; // Assuming errors/index.js exports EventError
import { ErrorCodes } from '../errors/ErrorCodes.js';
import { SYSTEM_STATUS, LIFECYCLE_EVENTS, DEFAULT_CONFIG } from '../common/SystemConstants.js';
import { safeHandleError, createStandardHealthCheckResult } from '../common/ErrorUtils.js';

// Assuming crypto.randomUUID is available (Node.js 15.6.0+, or use a polyfill/library for broader compatibility)
// For older Node or browsers, you might need a library like 'uuid'.
// const { v4: uuidv4 } = require('uuid'); // Example if using uuid library

export class CoreEventBus extends EventEmitter {
  static dependencies = ['errorSystem', 'config']; // [cite: 2135]
  static version = '2.0.0'; // Example version bump

  /**
   * Creates a new CoreEventBus instance.
   * @param {object} [deps={}] - Dependencies for the CoreEventBus.
   * @param {object} [deps.errorSystem] - The ErrorSystem instance.
   * @param {object} [deps.config={}] - Configuration object.
   */
  constructor(deps = {}) { // [cite: 2138]
    super();
    this.deps = {
      errorSystem: deps.errorSystem,
      config: deps.config || {}, // [cite: 2139]
    };

    this.queues = new Map(); // [cite: 2140]
    this.subscriptions = new Map(); // [cite: 2140]
    this.history = new Map(); // [cite: 2140]
    this.maxHistorySize = this.deps.config?.eventBus?.maxHistorySize || // [cite: 2141] Adjusted config path
                          this.deps.config?.eventHistory?.maxSize || // [cite: 2142] Kept original for compatibility
                          DEFAULT_CONFIG.MAX_ERROR_HISTORY; // [cite: 2142] Default if none specified
    // this.initialized is now driven by this.state.status

    this.state = {
      status: SYSTEM_STATUS.CREATED,
      startTime: null,
      errors: [], // For internal errors of CoreEventBus
      metrics: new Map(),
      healthChecks: new Map(),
    }; // [cite: 2144]

    this._originalEmit = null; // For wildcard forwarding
    this._processingNewListener = false; // [cite: 2145] Guard for newListener recursion

    this.setupDefaultHealthChecks(); // [cite: 2145, 2312]
    this._setupInternalListeners(); // [cite: 2146] Setup newListener/removeListener logic
  }

  /**
   * Sets up internal listeners for managing wildcard forwarding.
   * @private
   */
  _setupInternalListeners() {
    this.on('newListener', (eventName, listener) => {
      if (this._processingNewListener) return;
      this._processingNewListener = true;
      try {
        const eventNameStr = typeof eventName === 'string' ? eventName : String(eventName);
        if (eventNameStr === '*') { // [cite: 2147]
          this._enableWildcardForwarding(); // [cite: 2147]
        }
      }
      finally {
        this._processingNewListener = false;
      }
    });
    this.on('removeListener', (eventName) => {
      const eventNameStr = typeof eventName === 'string' ? eventName : String(eventName);
      if (eventNameStr === '*' && this.listenerCount('*') === 0) { // [cite: 2149]
        this._disableWildcardForwarding(); // [cite: 2149]
      }
    });
  }

  /**
   * Handles internal operational errors of the CoreEventBus.
   * @private
   */
  async _handleInternalError(error, context = {}) {
    const errorToLog = !(error instanceof EventError)
      ? new EventError(ErrorCodes.EVENT.INTERNAL_ERROR, error.message, context, { cause: error }) // Uses unprefixed 'INTERNAL_ERROR'
      : error;
    this.state.errors.push({ error: errorToLog, timestamp: new Date().toISOString(), context });
    if (this.state.errors.length > (this.deps.config?.eventBus?.maxErrorHistory || DEFAULT_CONFIG.MAX_ERROR_HISTORY)) {
      this.state.errors.shift(); // [cite: 2154]
    }
    this.recordMetric('eventbus.errors.internal', 1, { errorName: errorToLog.name, errorCode: errorToLog.code });
    await safeHandleError(this.deps.errorSystem, errorToLog, { source: 'CoreEventBus', ...context }); // [cite: 2155]
  }

  /**
   * Initializes the CoreEventBus.
   * @returns {Promise<CoreEventBus>}
   */
  async initialize() {
    if (this.state.status === SYSTEM_STATUS.RUNNING || this.state.status === SYSTEM_STATUS.INITIALIZING) {
      const err = new EventError(ErrorCodes.EVENT.ALREADY_INITIALIZED, 'CoreEventBus is already initialized or initializing.'); // [cite: 2156] Uses unprefixed
      await this._handleInternalError(err, { currentStatus: this.state.status }); // [cite: 2156]
      return this; // [cite: 2157]
    }

    this.emit(LIFECYCLE_EVENTS.INITIALIZING, { system: 'CoreEventBus' });
    this.state.status = SYSTEM_STATUS.INITIALIZING; // [cite: 2158]
    this.state.startTime = Date.now(); // [cite: 2158]

    try {
      // Wildcard forwarding setup is now handled by newListener/removeListener
      this.state.status = SYSTEM_STATUS.RUNNING; // [cite: 2159]
      this.recordMetric('eventbus.initialized.success', 1, { timestamp: Date.now() }); // [cite: 2160]
      this.emit(LIFECYCLE_EVENTS.INITIALIZED, { system: 'CoreEventBus', timestamp: new Date().toISOString() }); // [cite: 2164]
      this.emit(LIFECYCLE_EVENTS.RUNNING, { system: 'CoreEventBus', timestamp: new Date().toISOString() }); // [cite: 2165]
    } catch (error) {
      this.state.status = SYSTEM_STATUS.ERROR; // [cite: 2166]
      this.recordMetric('eventbus.initialized.failure', 1, { error: error.code, timestamp: Date.now() }); // [cite: 2167]
      await this._handleInternalError(error, { phase: 'initialization' }); // [cite: 2169]
      throw error instanceof EventError ?
      error : new EventError( // [cite: 2170]
        ErrorCodes.EVENT.INITIALIZATION_FAILED, // Uses unprefixed // [cite: 2170]
        'CoreEventBus failed to initialize.', // [cite: 2170]
        { originalMessage: error.message }, // [cite: 2170]
        { cause: error } // [cite: 2170]
      );
    }
    return this;
  }

  /**
   * Enables wildcard event forwarding by wrapping the emit method.
   * @private
   */
  _enableWildcardForwarding() {
    if (this._originalEmit) return; // [cite: 2173]
    this._originalEmit = super.emit; // [cite: 2173]

    const newEmit = (eventName, ...args) => {
      const result = this._originalEmit.call(this, eventName, ...args); // [cite: 2178]

      if (eventName !== '*' && this.listenerCount('*') > 0) { // [cite: 2180]
        if (args.length > 0 && typeof args[0] === 'object' && args[0] !== null && args[0].id && args[0].name) {
            this._originalEmit.call(this, '*', args[0]); // [cite: 2186]
        } else {
            this._originalEmit.call(this, '*', eventName, ...args); // [cite: 2189]
        }
      }
      return result;
    };
    this.emit = newEmit;

    this.recordMetric('eventbus.wildcard.enabled', 1); // [cite: 2190]
  }

  /**
   * Disables wildcard event forwarding by restoring the original emit method.
   * @private
   */
  _disableWildcardForwarding() {
    if (!this._originalEmit) return; // [cite: 2192]
    this.emit = this._originalEmit; // [cite: 2192]
    this._originalEmit = null; // [cite: 2193]
    this.recordMetric('eventbus.wildcard.disabled', 1); // [cite: 2193]
  }

  /**
   * Emits an event with queuing, history, and pattern matching.
   * @param {string} eventName - Event name.
   * @param {*} data - Event data.
   * @param {object} [options={}] - Emission options (e.g., queue, metadata).
   * @returns {Promise<boolean>} Whether the event had listeners (or was queued).
   */
  async emit(eventName, data, options = {}) { // This is the public emit, potentially wrapped
    if (typeof eventName !== 'string' || !eventName.trim()) { // [cite: 2197]
      const err = new EventError(
        ErrorCodes.EVENT.INVALID_EVENT_NAME, // Uses unprefixed // [cite: 2197]
        'Event name must be a non-empty string.', // [cite: 2197]
        { providedEventName: eventName } // [cite: 2197]
      );
      await this._handleInternalError(err, { eventName, data, options });
      throw err;
    }

    const eventId = global.crypto && typeof global.crypto.randomUUID === 'function'
                    ? global.crypto.randomUUID() // [cite: 2199]
                    : Math.random().toString(36).substring(2) + Date.now().toString(36); // [cite: 2200]

    const event = { // [cite: 2200]
      id: eventId, // [cite: 2200]
      name: eventName, // [cite: 2200]
      data, // [cite: 2200]
      timestamp: new Date().toISOString(), // [cite: 2200]
      metadata: options.metadata || {}, // [cite: 2201]
    };

    try {
      this.trackEvent(event); // [cite: 2202]
      this.recordMetric('eventbus.events.emitted', 1, { eventName, queued: !!options.queue }); // [cite: 2203]

      if (options.queue) { // [cite: 2203]
        await this.queueEvent(event, options); // [cite: 2204]
        return true; // [cite: 2204]
      }

      const emitFn = this._originalEmit || super.emit; // [cite: 2206]
      return emitFn.call(this, eventName, event); // Pass the wrapped event object // [cite: 2206]

    } catch (error) {
      await this._handleInternalError(error, { eventName, eventId: event.id, options }); // [cite: 2207]
      throw error instanceof EventError ?
      error : new EventError( // [cite: 2207]
        ErrorCodes.EVENT.EMISSION_FAILED, // Uses unprefixed // [cite: 2208]
        `Failed to emit event: ${eventName}`, // [cite: 2208]
        { eventName, eventId: event.id, options }, // [cite: 2208]
        { cause: error } // [cite: 2208]
      );
    }
  }

  /**
   * Subscribes to events matching a pattern.
   * @param {string} pattern - Event pattern (e.g., 'user.created', 'item.*', '*').
   * @param {Function} handler - Async function to handle the event: async (event) => {}.
   * @param {object} [options={}] - Subscription options.
   * @returns {string} Subscription ID.
   */
  subscribe(pattern, handler, options = {}) { // [cite: 2210]
    if (typeof pattern !== 'string' || !pattern.trim()) { // [cite: 2213]
      const err = new EventError(ErrorCodes.EVENT.INVALID_PATTERN, 'Event pattern must be a non-empty string.', { pattern }); // Uses unprefixed // [cite: 2214]
      this._handleInternalError(err); // Log, then throw // [cite: 2214]
      throw err; // [cite: 2215]
    }
    if (typeof handler !== 'function') { // [cite: 2215]
      const err = new EventError(ErrorCodes.EVENT.INVALID_HANDLER, 'Event handler must be a function.', { pattern }); // Uses unprefixed // [cite: 2216]
      this._handleInternalError(err); // [cite: 2216]
      throw err; // [cite: 2217]
    }

    const subscriptionId = global.crypto && typeof global.crypto.randomUUID === 'function'
                        ? global.crypto.randomUUID() // [cite: 2218]
                        : Math.random().toString(36).substring(2) + Date.now().toString(36); // [cite: 2219]
    const subscription = { // [cite: 2219]
      id: subscriptionId, // [cite: 2219]
      pattern, // [cite: 2219]
      handler, // [cite: 2219]
      options: options || {}, // [cite: 2220]
      created: new Date().toISOString(), // [cite: 2220]
      // internalHandler will store the actual function passed to EventEmitter.on
    }; // [cite: 2221]

    try {
      if (pattern === '*') { // [cite: 2221]
        subscription.internalHandler = (event) => handler(event); // [cite: 2222]
        super.on('*', subscription.internalHandler); // [cite: 2222]
      } else if (pattern.includes('*')) {
        const regexPattern = new RegExp('^' + pattern.replace(/\./g, '\\.').replace(/\*/g, '.*') + '$'); // [cite: 2224]
        subscription.internalHandler = (event) => { // [cite: 2224]
          if (event && typeof event.name === 'string' && regexPattern.test(event.name)) { // [cite: 2225]
            handler(event); // [cite: 2225]
          }
        };
        super.on('*', subscription.internalHandler); // Listen on wildcard, filter by name // [cite: 2226]
      } else {
        subscription.internalHandler = (event) => handler(event); // [cite: 2227]
        super.on(pattern, subscription.internalHandler); // [cite: 2227]
      }

      this.subscriptions.set(subscription.id, subscription); // [cite: 2228]
      this.recordMetric('eventbus.subscriptions.added', 1, { pattern }); // [cite: 2229]
      return subscription.id; // [cite: 2229]
    } catch (error) {
      // Use _handleInternalError for subscription setup issues
      this._handleInternalError(error, { phase: 'subscribe', pattern }); // This line had await, but _handleInternalError is async. Assuming the original intent.
      throw error instanceof EventError ?
      error : new EventError( // [cite: 2232]
        ErrorCodes.EVENT.SUBSCRIPTION_FAILED, // Uses unprefixed // [cite: 2232]
        `Failed to subscribe to pattern: ${pattern}`, // [cite: 2232]
        { pattern }, // [cite: 2232]
        { cause: error } // [cite: 2232]
      );
    }
  }

  /**
   * Unsubscribes from events.
   * @param {string} subscriptionId - The ID returned by subscribe.
   * @returns {boolean} True if unsubscribed, false otherwise.
   */
  unsubscribe(subscriptionId) { // [cite: 2234]
    const subscription = this.subscriptions.get(subscriptionId); // [cite: 2236]
    if (!subscription) { // [cite: 2236]
      this.deps.logger?.warn(`[CoreEventBus] Unsubscribe failed: Subscription ID '${subscriptionId}' not found.`); // [cite: 2237]
      return false; // [cite: 2237]
    }

    try {
      const { pattern, internalHandler } = subscription; // [cite: 2238]
      if (pattern.includes('*')) { // [cite: 2238]
        super.removeListener('*', internalHandler); // [cite: 2239]
      } else {
        super.removeListener(pattern, internalHandler); // [cite: 2240]
      }

      this.subscriptions.delete(subscriptionId); // [cite: 2241]
      this.recordMetric('eventbus.subscriptions.removed', 1, { pattern: subscription.pattern }); // [cite: 2242]
      return true; // [cite: 2242]
    } catch (error) {
      this._handleInternalError(error, { phase: 'unsubscribe', subscriptionId }); // This line had await.
      if (!(error instanceof EventError)) {
          this.deps.logger?.error(`[CoreEventBus] Error during removeListener for ${subscriptionId}: ${error.message}`); // [cite: 2247]
      }
      return false; // Indicate potential issue // [cite: 2247]
    }
  }

  /**
   * Adds an event to a named queue for later processing.
   * @param {object} event - The full event object.
   * @param {object} [options={}] - Queuing options (e.g., immediate).
   * @returns {Promise<boolean>} True if queued successfully.
   */
  async queueEvent(event, options = {}) { // [cite: 2248]
    try {
      const queueName = event.name; // [cite: 2250]
      const queue = this.queues.get(queueName) || []; // [cite: 2250]
      const queueItem = { event, options, timestamp: new Date().toISOString() }; // [cite: 2251]
      queue.push(queueItem); // [cite: 2251]
      this.queues.set(queueName, queue); // [cite: 2252]

      this.recordMetric('eventbus.events.queued', 1, { eventName: queueName, queueSize: queue.length }); // [cite: 2253]

      if (options.immediate) { // [cite: 2253]
        await this.processQueue(queueName); // [cite: 2254]
      }
      return true; // [cite: 2255]
    } catch (error) {
      await this._handleInternalError(error, { phase: 'queueEvent', eventName: event.name }); // [cite: 2256]
      throw error instanceof EventError ?
      error : new EventError( // [cite: 2257]
        ErrorCodes.EVENT.QUEUE_OPERATION_FAILED, // Uses unprefixed (assuming it's 'QUEUE_OPERATION_FAILED') // [cite: 2257]
        `Failed to queue event: ${event.name}`, // [cite: 2257]
        { eventName: event.name }, // [cite: 2257]
        { cause: error } // [cite: 2257]
      );
    }
  }

  /**
   * Processes all events in a named queue.
   * @param {string} queueName - The name of the queue to process.
   * @returns {Promise<number>} The number of events processed.
   */
  async processQueue(queueName) { // [cite: 2259]
    const queue = this.queues.get(queueName) || []; // [cite: 2261]
    if (queue.length === 0) return 0;

    let processedCount = 0;
    const startTime = Date.now(); // [cite: 2262]
    const BATCH_SIZE = this.deps.config?.eventBus?.queueBatchSize || 100; // Process in batches // [cite: 2262]

    const itemsToProcess = queue.splice(0, Math.min(queue.length, BATCH_SIZE)); // [cite: 2263]
    for (const { event } of itemsToProcess) { // [cite: 2263]
      try {
        const emitFn = this._originalEmit || super.emit; // [cite: 2264]
        emitFn.call(this, event.name, event); // Emit the full event object // [cite: 2264]
        processedCount++; // [cite: 2265]
      } catch (handlerError) {
        const appError = new EventError(
          ErrorCodes.EVENT.HANDLER_ERROR, // Uses unprefixed // [cite: 2267]
          `Error in handler for event: ${event.name} (ID: ${event.id}) during queue processing.`, // [cite: 2267]
          { eventName: event.name, eventId: event.id }, // [cite: 2267]
          { cause: handlerError } // [cite: 2267]
        );
        await this.handleError(appError, { phase: 'processQueue-handler', queueName, eventId: event.id }); // [cite: 2269]
      }
    }

    this.recordMetric('eventbus.queue.processed', processedCount, { queueName, processingTimeMs: Date.now() - startTime }); // [cite: 2270]
    if (queue.length > 0) {
        this.recordMetric('eventbus.queue.remaining', queue.length, { queueName }); // [cite: 2271]
    }
    return processedCount; // [cite: 2271]
  }

  /**
   * Public error handler to be used by event listeners if they want to report errors
   * through the EventBus's configured ErrorSystem.
   * @param {Error} error - The error object from the event listener.
   * @param {object} [context={}] - Context from the event listener.
   */
  async handleError(error, context = {}) { // [cite: 2272]
    this.recordMetric('eventbus.errors.reported_by_listener', 1, { errorName: error.name, errorCode: error.code }); // [cite: 2276]
    await safeHandleError(this.deps.errorSystem, error, { source: 'CoreEventBusListener', ...context }); // [cite: 2276]
  }


  /**
   * Processes all events in all queues.
   * @returns {Promise<Object.<string, number>>} An object mapping queue names to processed counts.
   */
  async processAllQueues() { // [cite: 2277]
    const results = {}; // [cite: 2279]
    const queueNames = Array.from(this.queues.keys()); // [cite: 2279]
    let totalProcessed = 0; // [cite: 2280]
    for (const queueName of queueNames) { // [cite: 2280]
      try {
        results[queueName] = await this.processQueue(queueName); // [cite: 2281]
        totalProcessed += results[queueName]; // [cite: 2282]
      } catch (error) {
        await this._handleInternalError(error, { phase: 'processAllQueues', queueName }); // [cite: 2283]
        results[queueName] = 0; // Mark as 0 processed for this queue due to error
      }
    }
    this.recordMetric('eventbus.all_queues.processed_total', totalProcessed); // [cite: 2285]
    return results; // [cite: 2285]
  }

  trackEvent(event) { // [cite: 2285]
    const eventHistoryQueue = this.history.get(event.name) || []; // [cite: 2286]
    eventHistoryQueue.unshift(event); // [cite: 2286]
    if (eventHistoryQueue.length > this.maxHistorySize) { // [cite: 2286]
      eventHistoryQueue.pop(); // [cite: 2287]
    }
    this.history.set(event.name, eventHistoryQueue); // [cite: 2288]
    this.recordMetric('eventbus.history.size', eventHistoryQueue.length, { eventName: event.name }); // [cite: 2289]
  }

  getHistory(eventName, options = {}) { // [cite: 2289]
    const historyQueue = this.history.get(eventName) || []; // [cite: 2290]
    if (options.limit && options.limit > 0) { // [cite: 2290]
      return historyQueue.slice(0, options.limit); // [cite: 2291]
    }
    return [...historyQueue]; // [cite: 2292]
  }

  getAllHistory(options = {}) { // [cite: 2292]
    const result = {}; // [cite: 2293]
    for (const [eventName, historyQueue] of this.history) { // [cite: 2293]
      result[eventName] = options.limit ? historyQueue.slice(0, options.limit) : [...historyQueue]; // [cite: 2294]
    }
    return result; // [cite: 2295]
  }

  async reset() { // [cite: 2295]
    this.queues.clear(); // [cite: 2296]
    this.history.clear(); // [cite: 2296]
    const eventNames = super.eventNames().filter( // [cite: 2297]
      (name) => name !== 'newListener' && name !== 'removeListener' && !name.startsWith('system:')
    );
    for (const eventName of eventNames) { // [cite: 2298]
      super.removeAllListeners(eventName); // [cite: 2299]
    }
    this.subscriptions.clear(); // [cite: 2300]
    this.recordMetric('eventbus.reset', 1); // [cite: 2301]
    if (this._originalEmit) {
        this._disableWildcardForwarding(); // [cite: 2302]
    }
  }

  async shutdown() { // [cite: 2302]
    if (this.state.status === SYSTEM_STATUS.SHUTDOWN || this.state.status === SYSTEM_STATUS.SHUTTING_DOWN) { // [cite: 2303]
      return; // [cite: 2303]
    }
    this.emit(LIFECYCLE_EVENTS.SHUTTING_DOWN, { system: 'CoreEventBus' });
    this.state.status = SYSTEM_STATUS.SHUTTING_DOWN; // [cite: 2304]

    try {
      await this.reset(); // [cite: 2305]
      super.removeAllListeners(); // Remove ALL listeners, including internal ones // [cite: 2305]

      this.state.status = SYSTEM_STATUS.SHUTDOWN; // [cite: 2306]
      this.state.startTime = null;
      this.recordMetric('eventbus.shutdown.success', 1, { timestamp: Date.now() }); // [cite: 2307]
      this.deps.logger?.info('[CoreEventBus] Shutdown complete.'); // [cite: 2308]

    } catch (error) {
      this.state.status = SYSTEM_STATUS.ERROR; // [cite: 2309]
      this.recordMetric('eventbus.shutdown.failure', 1, { error: error.code, timestamp: Date.now() }); // [cite: 2310]
      console.error('[CoreEventBus] Shutdown failed:', error); // [cite: 2311]
    }
  }

  // --- Health Checks & Metrics ---
  setupDefaultHealthChecks() { // [cite: 2312]
    this.registerHealthCheck('eventbus.state', this.checkSystemState.bind(this)); // [cite: 2312]
    this.registerHealthCheck('eventbus.queues', this.checkQueueStatus.bind(this)); // [cite: 2312]
    this.registerHealthCheck('eventbus.subscriptions', this.checkSubscriptionStatus.bind(this)); // [cite: 2313]
  }

  recordMetric(name, value, tags = {}) { // [cite: 2313]
    this.state.metrics.set(name, { value, timestamp: Date.now(), tags }); // [cite: 2314]
  }

  getMetrics() {
    const metrics = {}; // [cite: 2315]
    for (const [name, data] of this.state.metrics) { // [cite: 2315]
      metrics[name] = data; // [cite: 2316]
    }
    return metrics;
  }

  registerHealthCheck(name, checkFn) { // [cite: 2317]
    if (typeof checkFn !== 'function') {
      const err = new EventError(ErrorCodes.EVENT.INVALID_HANDLER, `Health check '${name}' must be a function.`); // Uses unprefixed // [cite: 2317]
      this._handleInternalError(err); // Log, but rethrow as it's a programming error // [cite: 2317]
      throw err; // [cite: 2318]
    }
    this.state.healthChecks.set(name, checkFn); // [cite: 2318]
  }

  async checkHealth() { // [cite: 2318]
    const results = {}; // [cite: 2319]
    let overallStatus = SYSTEM_STATUS.HEALTHY; // [cite: 2320]

    for (const [name, checkFn] of this.state.healthChecks) { // [cite: 2320]
      try {
        const checkResult = await checkFn(); // [cite: 2321]
        results[name] = checkResult; // [cite: 2322]
        if (checkResult.status !== SYSTEM_STATUS.HEALTHY) { // [cite: 2322]
          overallStatus = (overallStatus === SYSTEM_STATUS.HEALTHY) ?
          SYSTEM_STATUS.DEGRADED : SYSTEM_STATUS.UNHEALTHY; // [cite: 2323]
          if (checkResult.status === SYSTEM_STATUS.UNHEALTHY) overallStatus = SYSTEM_STATUS.UNHEALTHY; // [cite: 2324]
        }
      } catch (error) {
        results[name] = createStandardHealthCheckResult(SYSTEM_STATUS.UNHEALTHY, { error: 'Health check threw an exception' }, [error]); // [cite: 2325]
        overallStatus = SYSTEM_STATUS.UNHEALTHY; // [cite: 2325]
      }
    }
    return { // [cite: 2326]
      name: this.constructor.name, // [cite: 2326]
      version: CoreEventBus.version, // [cite: 2326]
      status: overallStatus, // [cite: 2326]
      timestamp: new Date().toISOString(), // [cite: 2326]
      uptime: this.state.startTime ? Date.now() - this.state.startTime : 0, // [cite: 2327]
      errorCount: this.state.errors.length,
      checks: results, // [cite: 2327]
    };
  }

  async checkSystemState() { // [cite: 2328]
    return createStandardHealthCheckResult(
      this.state.status === SYSTEM_STATUS.RUNNING ? SYSTEM_STATUS.HEALTHY : SYSTEM_STATUS.UNHEALTHY,
      { // [cite: 2328]
        status: this.state.status, // [cite: 2329]
        uptime: this.state.startTime ? Date.now() - this.state.startTime : 0, // [cite: 2329]
        internalErrorCount: this.state.errors.length // [cite: 2329]
      }
    );
  }

  async checkQueueStatus() { // [cite: 2329]
    const queueCounts = {}; // [cite: 2330]
    let totalQueuedEvents = 0; // [cite: 2330]
    this.queues.forEach((queue, key) => { // [cite: 2331]
      queueCounts[key] = queue.length; // [cite: 2331]
      totalQueuedEvents += queue.length; // [cite: 2331]
    });
    return createStandardHealthCheckResult(SYSTEM_STATUS.HEALTHY, { // [cite: 2332]
      queueCount: this.queues.size, // [cite: 2332]
      totalQueuedEvents, // [cite: 2332]
      queues: queueCounts, // [cite: 2332]
    });
  }

  async checkSubscriptionStatus() { // [cite: 2333]
    return createStandardHealthCheckResult(SYSTEM_STATUS.HEALTHY, { // [cite: 2333]
      count: this.subscriptions.size, // [cite: 2333]
      patterns: Array.from(this.subscriptions.values()).map(s => s.pattern), // [cite: 2333]
    });
  }

   getSystemStatus() { // For consistency
    return {
        name: this.constructor.name,
        version: CoreEventBus.version,
        status: this.state.status,
        uptime: this.state.startTime ? Date.now() - this.state.startTime : 0, // [cite: 2335]
        initialized: this.state.status === SYSTEM_STATUS.RUNNING,
        errorCount: this.state.errors.length,
        timestamp: new Date().toISOString() // [cite: 2336]
    };
  }
}

/**
 * Factory function for creating a CoreEventBus instance.
 * @param {object} [deps={}] - Dependencies for the CoreEventBus.
 * @returns {CoreEventBus}
 */
export function createEventBus(deps = {}) { // [cite: 2337]
  return new CoreEventBus(deps); // [cite: 2338]
}


// src/core/event/EventBusSystem.js

/**
 * @file EventBusSystem.js
 * @description Manages the CoreEventBus and provides system-level eventing capabilities.
 */

import { EventEmitter } from 'events';
import { CoreEventBus } from './CoreEventBus.js';
import { EventError } from '../errors/index.js'; // Assuming errors/index.js exports EventError
import { ErrorCodes } from '../errors/ErrorCodes.js';
import { SYSTEM_STATUS, LIFECYCLE_EVENTS, DEFAULT_CONFIG } from '../common/SystemConstants.js';
import { safeHandleError, createStandardHealthCheckResult } from '../common/ErrorUtils.js';

export class EventBusSystem extends EventEmitter {
  static dependencies = ['errorSystem', 'config']; //
  static version = '2.0.0'; // Example version bump

  /**
   * Creates a new EventBusSystem instance.
   * @param {object} [deps={}] - Dependencies for the EventBusSystem.
   * @param {object} [deps.errorSystem] - The ErrorSystem instance.
   * @param {object} [deps.config={}] - Configuration object.
   */
  constructor(deps = {}) { //
    super();
    this.deps = {
      errorSystem: deps.errorSystem, // Will be validated in validateDependencies
      config: deps.config || {}, //
    };

    this.eventBus = null; // Will be an instance of CoreEventBus
    // this.initialized is now driven by this.state.status
    this._forwardingInitialized = false; // Instance flag for event forwarding setup

    this.state = {
      status: SYSTEM_STATUS.CREATED,
      startTime: null,
      errors: [], // For internal errors of EventBusSystem itself
      metrics: new Map(),
      healthChecks: new Map(),
    }; //

    this.validateDependencies(); // Validate early
    this.setupDefaultHealthChecks(); //
  }

  /**
   * Validates that required dependencies are provided and are valid.
   * @private
   */
  validateDependencies() { //
    const missing = EventBusSystem.dependencies.filter(dep => !this.deps[dep]); //
    if (missing.length > 0) { //
      throw new EventError( // Use EventError for its own domain
        ErrorCodes.EVENT.MISSING_DEPENDENCIES, // Uses unprefixed
        `EventBusSystem: Missing required dependencies: ${missing.join(', ')}`, //
        { missingDeps: missing } //
      );
    }
    if (this.deps.errorSystem && typeof this.deps.errorSystem.handleError !== 'function') { //
      throw new EventError( //
        ErrorCodes.EVENT.INVALID_DEPENDENCY, // Uses unprefixed
        'EventBusSystem: ErrorSystem dependency is invalid (missing handleError method).', //
        { dependency: 'errorSystem' } //
      );
    }
  }

  /**
   * Handles internal operational errors of the EventBusSystem.
   * @private
   */
  async _handleInternalError(error, context = {}) {
    const errorToLog = !(error instanceof EventError)
      ? new EventError(ErrorCodes.EVENT.INTERNAL_ERROR, error.message, context, { cause: error }) // Uses unprefixed
      : error;
    this.state.errors.push({ error: errorToLog, timestamp: new Date().toISOString(), context });
    if (this.state.errors.length > (this.deps.config?.eventBusSystem?.maxErrorHistory || DEFAULT_CONFIG.MAX_ERROR_HISTORY)) {
      this.state.errors.shift(); //
    }
    this.recordMetric('eventbussystem.errors.internal', 1, { errorName: errorToLog.name, errorCode: errorToLog.code });
    await safeHandleError(this.deps.errorSystem, errorToLog, { source: 'EventBusSystem', ...context }); //
  }

  /**
   * Initializes the EventBusSystem and the underlying CoreEventBus.
   * @returns {Promise<EventBusSystem>}
   */
  async initialize() { //
    if (this.state.status === SYSTEM_STATUS.RUNNING || this.state.status === SYSTEM_STATUS.INITIALIZING) {
      const err = new EventError(ErrorCodes.EVENT.ALREADY_INITIALIZED, 'EventBusSystem is already initialized or initializing.'); // Uses unprefixed
      await this._handleInternalError(err, { currentStatus: this.state.status }); //
      return this; //
    }

    this.emit(LIFECYCLE_EVENTS.INITIALIZING, { system: 'EventBusSystem' });
    this.state.status = SYSTEM_STATUS.INITIALIZING; //
    this.state.startTime = Date.now(); //

    try {
      // Create and initialize the CoreEventBus instance
      // Pass system dependencies to CoreEventBus
      this.eventBus = new CoreEventBus({
        errorSystem: this.deps.errorSystem,
        config: this.deps.config, // Pass the whole config, CoreEventBus can pick what it needs
      }); //
      await this.eventBus.initialize(); //

      this.setupEventForwarding(); //

      this.state.status = SYSTEM_STATUS.RUNNING; //
      this.recordMetric('eventbussystem.initialized.success', 1, { timestamp: Date.now() }); //
      this.emit(LIFECYCLE_EVENTS.INITIALIZED, { system: 'EventBusSystem', timestamp: new Date().toISOString() }); //
      this.emit(LIFECYCLE_EVENTS.RUNNING, { system: 'EventBusSystem', timestamp: new Date().toISOString() }); //
    } catch (error) {
      this.state.status = SYSTEM_STATUS.ERROR; //
      this.recordMetric('eventbussystem.initialized.failure', 1, { error: error.code, timestamp: Date.now() }); //
      await this._handleInternalError(error, { phase: 'initialization' }); //
      throw error instanceof EventError ?
      error : new EventError( //
        ErrorCodes.EVENT.INITIALIZATION_FAILED, // Uses unprefixed //
        'EventBusSystem failed to initialize.', //
        { originalMessage: error.message }, //
        { cause: error } //
      );
    }
    return this;
  }

  /**
   * Sets up event forwarding from the CoreEventBus to this EventBusSystem.
   * This allows listeners on EventBusSystem to receive events emitted on CoreEventBus.
   * @private
   */
  setupEventForwarding() { //
    if (!this.eventBus || this._forwardingInitialized) { //
      return; //
    }

    this.eventBus.on('*', (event) => { // `event` here is the full event object
      if (event && typeof event.name === 'string') { //
        if (event.name && !event.name.startsWith('system:')) {
             super.emit(event.name, event); //
        }

        if (event.name === LIFECYCLE_EVENTS.INITIALIZED && event.system === 'CoreEventBus') {
            super.emit('coreEventBus:initialized', event); //
        }
        if (event.name === LIFECYCLE_EVENTS.SHUTDOWN && event.system === 'CoreEventBus') {
            super.emit('coreEventBus:shutdown', event); //
        }

      } else if (event) {
        this._handleInternalError(new EventError(ErrorCodes.EVENT.LEGACY_WILDCARD_FORWARD, "Legacy wildcard format received by EventBusSystem forwarder."), { eventArg: event }); // Uses unprefixed
      }
    });
    this._forwardingInitialized = true; //
  }

  /**
   * Emits an event.
   * Primarily, this system manages CoreEventBus. Direct emission from EventBusSystem
   * should be for its own lifecycle or specific system-level events.
   * Application events should be emitted via the CoreEventBus instance.
   * @param {string} eventName - Event name.
   * @param {...any} args - Event arguments.
   * @returns {Promise<boolean>}
   */
  async emit(eventName, ...args) { //
    const localEmitResult = super.emit(eventName, ...args); //

    if (this.eventBus && typeof this.eventBus.emit === 'function' &&
        !eventName.startsWith('system:') && !eventName.startsWith('coreEventBus:')) { //
      try {
        await this.eventBus.emit(eventName, ...args); //
      } catch (error) {
        await this._handleInternalError(error, { phase: 'emit-forward', eventName }); //
      }
    }
    return localEmitResult; //
  }


  getEventBus() { //
    if (this.state.status !== SYSTEM_STATUS.RUNNING) { //
      throw new EventError( //
        ErrorCodes.EVENT.NOT_INITIALIZED, // Uses unprefixed
        'EventBusSystem (or its CoreEventBus) is not initialized or not running.', //
        { currentStatus: this.state.status } //
      );
    }
    return this.eventBus; //
  }

  async shutdown() { //
    if (this.state.status === SYSTEM_STATUS.SHUTDOWN || this.state.status === SYSTEM_STATUS.SHUTTING_DOWN) { //
      return this; //
    }
    this.emit(LIFECYCLE_EVENTS.SHUTTING_DOWN, { system: 'EventBusSystem' });
    this.state.status = SYSTEM_STATUS.SHUTTING_DOWN; //

    try {
      if (this.eventBus) { //
        await this.eventBus.shutdown(); //
      }
      super.removeAllListeners(); // Clear EventBusSystem's own listeners

      this.eventBus = null; //
      this.state.status = SYSTEM_STATUS.SHUTDOWN; //
      this.state.startTime = null; //
      this.recordMetric('eventbussystem.shutdown.success', 1, { timestamp: Date.now() }); //
      this.deps.logger?.info('[EventBusSystem] Shutdown complete.'); //
    } catch (error) {
      this.state.status = SYSTEM_STATUS.ERROR; //
      this.recordMetric('eventbussystem.shutdown.failure', 1, { error: error.code, timestamp: Date.now() }); //
      await this._handleInternalError(error, { phase: 'shutdown' }); //
      throw error instanceof EventError ?
      error : new EventError( //
        ErrorCodes.EVENT.SHUTDOWN_FAILED, // Uses unprefixed //
        'EventBusSystem failed to shutdown.', //
        { originalMessage: error.message }, //
        { cause: error } //
      );
    }
    return this; //
  }

  // --- State, Health, Metrics ---
  setupDefaultHealthChecks() { //
    this.registerHealthCheck('eventbussystem.state', this.checkSystemState.bind(this)); //
    this.registerHealthCheck('eventbussystem.corebus', this.checkCoreBusHealth.bind(this)); //
  }

  recordMetric(name, value, tags = {}) { //
    this.state.metrics.set(name, { value, timestamp: Date.now(), tags }); //
  }

  getMetrics() { //
    const metrics = {}; //
    for (const [name, data] of this.state.metrics) { //
      metrics[name] = data; //
    }
    return metrics; //
  }

  registerHealthCheck(name, checkFn) { //
    if (typeof checkFn !== 'function') {
      const err = new EventError(ErrorCodes.EVENT.INVALID_HANDLER, `Health check '${name}' must be a function.`); // Uses unprefixed
      this._handleInternalError(err); // Log, but rethrow //
      throw err; //
    }
    this.state.healthChecks.set(name, checkFn); //
  }

  async checkHealth() { //
    const results = {}; //
    let overallStatus = SYSTEM_STATUS.HEALTHY; //

    for (const [name, checkFn] of this.state.healthChecks) { //
      try {
        const checkResult = await checkFn(); //
        results[name] = checkResult; //
        if (checkResult.status !== SYSTEM_STATUS.HEALTHY) { //
          overallStatus = (overallStatus === SYSTEM_STATUS.HEALTHY) ?
          SYSTEM_STATUS.DEGRADED : SYSTEM_STATUS.UNHEALTHY; //
          if (checkResult.status === SYSTEM_STATUS.UNHEALTHY) overallStatus = SYSTEM_STATUS.UNHEALTHY; //
        }
      } catch (error) {
        results[name] = createStandardHealthCheckResult(SYSTEM_STATUS.UNHEALTHY, { error: 'Health check threw an exception' }, [error]); //
        overallStatus = SYSTEM_STATUS.UNHEALTHY; //
      }
    }
    return { //
      name: this.constructor.name, //
      version: EventBusSystem.version, //
      status: overallStatus, //
      timestamp: new Date().toISOString(), //
      uptime: this.state.startTime ? Date.now() - this.state.startTime : 0, //
      errorCount: this.state.errors.length,
      checks: results, //
    };
  }

  async checkSystemState() { //
    return createStandardHealthCheckResult( //
      this.state.status === SYSTEM_STATUS.RUNNING ? SYSTEM_STATUS.HEALTHY : SYSTEM_STATUS.UNHEALTHY, //
      { //
        status: this.state.status, //
        uptime: this.state.startTime ? Date.now() - this.state.startTime : 0, //
        internalErrorCount: this.state.errors.length //
      }
    );
  }

  async checkCoreBusHealth() { //
    if (!this.eventBus || typeof this.eventBus.checkHealth !== 'function') { //
      return createStandardHealthCheckResult( //
        SYSTEM_STATUS.UNHEALTHY, //
        { reason: 'CoreEventBus not available or does not support health checks.' } //
      );
    }
    try {
      return await this.eventBus.checkHealth(); //
    } catch (error) {
      return createStandardHealthCheckResult(SYSTEM_STATUS.UNHEALTHY, { error: 'CoreEventBus health check failed.' }, [error]); //
    }
  }

  getSystemStatus() { //
    return { //
        name: this.constructor.name, //
        version: EventBusSystem.version, //
        status: this.state.status, //
        uptime: this.state.startTime ? Date.now() - this.state.startTime : 0, //
        initialized: this.state.status === SYSTEM_STATUS.RUNNING, //
        errorCount: this.state.errors.length, //
        timestamp: new Date().toISOString(), //
        coreEventBusStatus: this.eventBus ? this.eventBus.getSystemStatus().status : (SYSTEM_STATUS.UNAVAILABLE || 'unavailable') //
    };
  }
}

/**
 * Factory function for creating an EventBusSystem instance.
 * @param {object} [deps={}] - Dependencies for the EventBusSystem.
 * @returns {EventBusSystem}
 */
export function createEventBusSystem(deps = {}) { //
  return new EventBusSystem(deps); //
}


// src/core/event/eventbus-system.md

# TSMIS EventBusSystem & CoreEventBus Documentation
Version: 2.1.0 (Refactored Core)

## Table of Contents

1.  [Introduction to the Eventing System](#1-introduction-to-the-eventing-system)
    * [1.1. Purpose & Philosophy](#11-purpose--philosophy)
    * [1.2. Key Components: `EventBusSystem` and `CoreEventBus`](#12-key-components-eventbussystem-and-coreeventbus)
2.  [Component: `CoreEventBus.js` - The Eventing Engine](#2-component-coreeventbusjs---the-eventing-engine)
    * [2.1. Overview & Primary Responsibility](#21-overview--primary-responsibility)
    * [2.2. Key Functionalities & API (`CoreEventBus`)](#22-key-functionalities--api-coreeventbus)
        * [2.2.1. Standard Event Object Structure](#221-standard-event-object-structure)
        * [2.2.2. `emit(eventName, data, options)`](#222-emiteventname-data-options)
        * [2.2.3. `subscribe(pattern, handler, options)`](#223-subscribepattern-handler-options)
        * [2.2.4. `unsubscribe(subscriptionId)`](#224-unsubscribesubscriptionid)
        * [2.2.5. Event Queuing (`queueEvent`, `processQueue`, `processAllQueues`)](#225-event-queuing-queueevent-processqueue-processallqueues)
        * [2.2.6. Event History (`trackEvent`, `getHistory`, `getAllHistory`)](#226-event-history-trackevent-gethistory-getallhistory)
        * [2.2.7. `handleError(error, context)` (for Listeners)](#227-handleerrorerror-context-for-listeners)
        * [2.2.8. `reset()`](#228-reset)
    * [2.3. Wildcard and Pattern Subscription Details](#23-wildcard-and-pattern-subscription-details)
    * [2.4. State Management (`CoreEventBus` Specifics)](#24-state-management-coreeventbus-specifics)
    * [2.5. Lifecycle Management (`CoreEventBus` Specifics)](#25-lifecycle-management-coreeventbus-specifics)
    * [2.6. Error Handling within `CoreEventBus`](#26-error-handling-within-coreeventbus)
    * [2.7. Health Monitoring (`CoreEventBus` Specifics)](#27-health-monitoring-coreeventbus-specifics)
    * [2.8. Metrics Tracking (`CoreEventBus` Specifics)](#28-metrics-tracking-coreeventbus-specifics)
    * [2.9. Static Factory (`createEventBus`)](#29-static-factory-createeventbus)
3.  [Component: `EventBusSystem.js` - The Managing Facade](#3-component-eventbussystemjs---the-managing-facade)
    * [3.1. Overview & Primary Responsibility](#31-overview--primary-responsibility)
    * [3.2. Key Functionalities & API (`EventBusSystem`)](#32-key-functionalities--api-eventbussystem)
        * [3.2.1. `initialize()`](#321-initialize)
        * [3.2.2. `getEventBus()`](#322-geteventbus)
        * [3.2.3. `emit(eventName, ...args)`](#323-emiteventname-args)
        * [3.2.4. `shutdown()`](#324-shutdown)
    * [3.3. Adherence to Standardization Pillars (Recap for `EventBusSystem`)](#33-adherence-to-standardization-pillars-recap-for-eventbussystem)
    * [3.4. State Management (`EventBusSystem` Specifics)](#34-state-management-eventbussystem-specifics)
    * [3.5. Lifecycle Management (`EventBusSystem` Specifics)](#35-lifecycle-management-eventbussystem-specifics)
    * [3.6. Error Handling within `EventBusSystem`](#36-error-handling-within-eventbussystem)
    * [3.7. Event Integration (`EventBusSystem` Specifics - Forwarding)](#37-event-integration-eventbussystem-specifics---forwarding)
    * [3.8. Health Monitoring (`EventBusSystem` Specifics)](#38-health-monitoring-eventbussystem-specifics)
    * [3.9. Metrics Tracking (`EventBusSystem` Specifics)](#39-metrics-tracking-eventbussystem-specifics)
    * [3.10. Static Factory (`createEventBusSystem`)](#310-static-factory-createeventbussystem)
4.  [Integrations (Eventing System Level)](#4-integrations-eventing-system-level)
5.  [Overall Eventing Flow Diagram](#5-overall-eventing-flow-diagram)
6.  [Usage Examples & Best Practices](#6-usage-examples--best-practices)
    * [6.1. Emitting an Event](#61-emitting-an-event)
    * [6.2. Subscribing to Events (Exact, Pattern, Wildcard)](#62-subscribing-to-events-exact-pattern-wildcard)
    * [6.3. Using Event Queuing](#63-using-event-queuing)
    * [6.4. Accessing Event History](#64-accessing-event-history)
    * [6.5. Error Handling in Event Listeners](#65-error-handling-in-event-listeners)
7.  [Testing Strategy Notes](#7-testing-strategy-notes)
8.  [Future Considerations & Potential Enhancements](#8-future-considerations--potential-enhancements)

---

## 1. Introduction to the Eventing System

### 1.1. Purpose & Philosophy
The TSMIS Eventing System, comprising `EventBusSystem` and its managed `CoreEventBus`, is a cornerstone of the application's architecture, designed to facilitate decoupled, asynchronous communication between various components, particularly business modules. The philosophy behind it is to enable a more modular, scalable, and maintainable system where components can react to occurrences (events) without being tightly bound to the components that produce those events. This promotes an event-driven architecture (EDA) pattern.

Key goals include:
* **Decoupling**: Publishers of events do not need to know about subscribers, and vice-versa.
* **Asynchronicity**: Allows for non-blocking operations and better system responsiveness.
* **Extensibility**: New listeners can be added to react to existing events without modifying the event publishers.
* **Standardization**: Provides a consistent way to define, emit, subscribe to, and manage events.
* **Observability**: Offers built-in features for history, health monitoring, and metrics related to event processing[cite: 2479].

### 1.2. Key Components: `EventBusSystem` and `CoreEventBus`
* **`CoreEventBus.js`**: This is the engine of the eventing system. It extends Node.js's `EventEmitter` and provides core functionalities like emitting events with a standard structure, managing subscriptions (exact, pattern, wildcard), optional event queuing, and event history. It adheres to TSMIS core standardization pillars.
* **`EventBusSystem.js`**: This system acts as a managing facade for `CoreEventBus`. Its responsibilities include lifecycle management of `CoreEventBus`, providing controlled access (`getEventBus()`), and integrating the eventing subsystem into the application's standard monitoring frameworks.
Application components primarily interact with the `CoreEventBus` instance obtained via `EventBusSystem.getEventBus()`.

---
## 2. Component: `CoreEventBus.js` - The Eventing Engine

### 2.1. Overview & Primary Responsibility
`CoreEventBus` is the central workhorse for event management in TSMIS. It provides robust implementation for emitting events, managing complex subscription patterns, queuing events, and maintaining event history, ensuring all events adhere to a standard structure.

### 2.2. Key Functionalities & API (`CoreEventBus`)

#### 2.2.1. Standard Event Object Structure
All events are wrapped in a standard object:
**CoreEventBus**: Standard Event Object Structure Example
```javascript
// {
//   id: "a1b2c3d4-e5f6-7890-1234-567890abcdef", // Unique event ID (e.g., UUID)
//   name: "user.created",                         // The original emitted eventName
//   data: {                                     // The event payload/data
//     userId: "usr_123",
//     username: "alice_wonder",
//     email: "alice@example.com"
//   },
//   timestamp: "2025-05-18T23:30:00.000Z",       // ISO 8601 timestamp of event creation
//   metadata: {                                   // User-supplied options.metadata or an empty object
//     correlationId: "corr_id_789",
//     sourceService: "AuthModule"
//   }
// }
```

#### 2.2.2. `emit(eventName: string, data: any, options = {}): Promise<boolean>`
Publishes events.
* **`eventName`**: Event identifier (e.g., `user.created`)[cite: 2498].
* **`data`**: Event payload.
* **`options`**: Can include `queue: boolean`, `immediate: boolean`, `metadata: object`.
* Wraps into standard event object, tracks history, records metrics, handles queuing or direct emission.
* **Returns**: `Promise<boolean>` (emitted/queued).
* **Throws**: `EventError` (using an unprefixed code from `ErrorCodes.EVENT` like `'INVALID_EVENT_NAME'` or `'EMISSION_FAILED'`) for issues[cite: 2505].

#### 2.2.3. `subscribe(pattern: string, handler: Function, options = {}): string`
Registers a handler for events matching `pattern` (exact, wildcard, global `*`).
* **`handler`**: `async function(event: object)` receiving the full standard event object.
* **Returns**: Unique `subscriptionId`.
* **Throws**: `EventError` (using unprefixed codes like `'INVALID_PATTERN'` or `'INVALID_HANDLER'`) for invalid arguments[cite: 2510].

#### 2.2.4. `unsubscribe(subscriptionId: string): boolean`
Removes a subscription.
* **Returns**: `true` if removed, `false` otherwise.

#### 2.2.5. Event Queuing (`queueEvent`, `processQueue`, `processAllQueues`)
* **`async queueEvent(event: object, options = {}): Promise<boolean>`**: Internally used by `emit` for queuing.
* **`async processQueue(queueName: string): Promise<number>`**: Processes a batch of events from a queue, emitting them. Errors in handlers are reported via `this.handleError()`.
* **`async processAllQueues(): Promise<object>`**: Processes all queues.

#### 2.2.6. Event History (`trackEvent`, `getHistory`, `getAllHistory`)
* **`trackEvent(event: object)`**: Automatically called by `emit` to add to in-memory, capped history per event name. Max size from `config.eventBus.maxHistorySize`.
* **`getHistory(eventName: string, options = { limit?: number }): Array<object>`**: Retrieves history for an event name.
* **`getAllHistory(options = { limit?: number }): object`**: Retrieves history for all event names[cite: 2519].

#### 2.2.7. `async handleError(error: Error, context = {}): Promise<void>`
Public method for event *listeners* to report their errors to `ErrorSystem` via `safeHandleError`.

#### 2.2.8. `async reset(): Promise<void>`
Clears queues, history, and application-level listeners/subscriptions. Disables wildcard forwarding.

### 2.3. Wildcard and Pattern Subscription Details
All event handlers receive a single argument: the full, standardized event object. `CoreEventBus` dynamically manages wildcard (`*`) forwarding by wrapping its native `emit` method. Pattern subscriptions (e.g., `item.*`) internally listen on `*` and filter based on `event.name`.

### 2.4. State Management (`CoreEventBus` Specifics)
Implements standard `this.state`. Operational data:
* `this.queues: Map<string, Array<object>>`
* `this.subscriptions: Map<string, object>`
* `this.history: Map<string, Array<object>>` [cite: 2534]
* `this.maxHistorySize: number`
* `this._originalEmit: Function | null`
* `this._processingNewListener: boolean` [cite: 2536]

### 2.5. Lifecycle Management (`CoreEventBus` Specifics)
* **`async initialize()`**: Sets up initial state. Wildcard forwarding driven by `newListener`/`removeListener`. Emits lifecycle events[cite: 2538].
* **`async shutdown()`**: Calls `reset()`, removes all listeners. Emits/logs lifecycle events[cite: 2539].

### 2.6. Error Handling within `CoreEventBus`
* Uses `_handleInternalError` for its own operational errors (throws `EventError` with unprefixed codes like `'INTERNAL_ERROR'`).
* Catches errors from handlers in `processQueue`, reports via `this.handleError()`.

### 2.7. Health Monitoring (`CoreEventBus` Specifics)
Provides `checkHealth()`. Default checks:
* **`eventbus.state`**: Lifecycle `status`, uptime, internal error count[cite: 2545].
* **`eventbus.queues`**: Queue counts and total events.
* **`eventbus.subscriptions`**: Subscription count and patterns[cite: 2546].

### 2.8. Metrics Tracking (`CoreEventBus` Specifics)
Records detailed metrics for lifecycle, errors, operations (wildcard, emit, queue, subscribe, history, reset).

### 2.9. Static Factory (`createEventBus`)
**`createEventBus(deps = {}): CoreEventBus`** for instantiation.

---
## 3. Component: `EventBusSystem.js` - The Managing Facade

### 3.1. Overview & Primary Responsibility
`EventBusSystem` manages the `CoreEventBus` instance, handling its lifecycle, providing controlled access (`getEventBus()`), and integrating eventing subsystem's monitoring into TSMIS standards.

### 3.2. Key Functionalities & API (`EventBusSystem`)

#### 3.2.1. `async initialize(): Promise<EventBusSystem>`
Validates dependencies, creates and initializes `CoreEventBus`, sets up event forwarding.

#### 3.2.2. `getEventBus(): CoreEventBus`
Primary method for components to get the `CoreEventBus` instance. Throws `EventError` (with unprefixed code `'NOT_INITIALIZED'`) if not running.

#### 3.2.3. `async emit(eventName, ...args)`
Primarily for `EventBusSystem`'s own lifecycle events. Forwards other non-system events to managed `CoreEventBus`. Apps should use `getEventBus().emit()`[cite: 2560].

#### 3.2.4. `async shutdown(): Promise<EventBusSystem>`
Manages `CoreEventBus.shutdown()` and cleans up its own resources.

### 3.3. Adherence to Standardization Pillars (Recap for `EventBusSystem`)
* **State Management**: Standard `this.state`, `eventBus` instance, `_forwardingInitialized` flag.
* **Lifecycle Management**: Manages its own and `CoreEventBus` lifecycle. Emits `LIFECYCLE_EVENTS`.
* **Error Handling**: `_handleInternalError` for own errors (throws `EventError` with unprefixed codes), reports via `safeHandleError`.
* **Health Monitoring**: `checkHealth()` aggregates its state with `CoreEventBus` health.
* **Metrics Tracking**: Records metrics for own lifecycle and internal errors.
* **Factory Function**: `createEventBusSystem(deps = {})`[cite: 2567].

### 3.4. State Management (`EventBusSystem` Specifics)
(Covered by 3.3).

### 3.5. Lifecycle Management (`EventBusSystem` Specifics)
* **`initialize()`**: Instantiates and initializes `CoreEventBus`. Calls `setupEventForwarding()`[cite: 2568].
* **`shutdown()`**: Ensures `CoreEventBus.shutdown()` is called.

### 3.6. Error Handling within `EventBusSystem`
Uses `_handleInternalError` for its operational errors (e.g., `CoreEventBus` init failure), reporting to global `ErrorSystem`. Errors thrown are `EventError` using unprefixed codes from `ErrorCodes.EVENT`.

### 3.7. Event Integration (`EventBusSystem` Specifics - Forwarding)
`setupEventForwarding()` listens to `CoreEventBus` (`on('*', ...)`).
* May re-emit certain non-system events from `CoreEventBus` on `EventBusSystem` itself.
* Forwards specific `CoreEventBus` lifecycle events with a differentiating prefix (e.g., `coreEventBus:initialized`).

### 3.8. Health Monitoring (`EventBusSystem` Specifics)
Default health checks:
* **`eventbussystem.state`**: Its own lifecycle `status`, uptime, internal error count.
* **`eventbussystem.corebus`**: Calls `this.eventBus.checkHealth()` for `CoreEventBus`'s full report.

### 3.9. Metrics Tracking (`EventBusSystem` Specifics)
Key metrics[cite: 2575]:
* `eventbussystem.initialized.success/failure`
* `eventbussystem.shutdown.success/failure`
* `eventbussystem.errors.internal`

### 3.10. Static Factory (`createEventBusSystem`)
**`createEventBusSystem(deps = {}): EventBusSystem`** for instantiation[cite: 2576].

---
## 4. Integrations (Eventing System Level)
The Eventing System integrates with:
* **`ContainerSystem`**: Instantiates `EventBusSystem` and provides dependencies[cite: 2577].
* **`ModuleSystem` & `CoreModule`s**: `ModuleSystem` injects `EventBusSystem` into `CoreModule`s, which use `getEventBus()` for emitting and subscribing.
* **`RouterSystem` & `CoreRouter`**: `CoreRouter` subscribes to route events via `CoreEventBus`.
* **`ErrorSystem`**: Both `CoreEventBus` and `EventBusSystem` report errors to `ErrorSystem`.
* **Application Services & Business Logic**: Use `CoreEventBus` for decoupled communication.

---
## 5. Overall Eventing Flow Diagram
**Eventing System**: Overall Event Flow Diagram
```mermaid
graph TD
    subgraph EventBusSystem_Facade [EventBusSystem Facade]
        direction LR
        EBS_State[("this.state (System)")]
        EBS_CEBInst(["Managed CoreEventBus Instance"])
    end

    subgraph CoreEventBus_Engine [CoreEventBus Engine]
        direction TB
        CEB_State[("this.state (Bus)")]
        CEB_Queues[("Queues Map")]
        CEB_History[("History Map")]
        CEB_Subscriptions[("Subscriptions Map")]
        CEB_WildcardLogic["Wildcard/Pattern Logic"]
    end
    
    EventBusSystem_Facade -- Manages/Creates & Initializes --> CoreEventBus_Engine;
    AppModuleA["App Module A (Emitter)"] -- "1. getEventBus()" --> EventBusSystem_Facade;
    EventBusSystem_Facade -- "2. Returns instance" --> AppModuleA;
    AppModuleA -- "3. coreEventBus.emit('eventX', data, options)" --> CoreEventBus_Engine;
    
    CoreEventBus_Engine -- "4. Create Event Object" --> StandardEvent["{id, name, data, ts, meta}"];
    StandardEvent -- "5. Track History" --> CEB_History;
    StandardEvent -- "6. Queue if options.queue" --> CEB_Queues;
    alt Direct Emission (Not Queued)
        StandardEvent -- "7. Find Subscribers" --> CEB_Subscriptions;
        CEB_Subscriptions -- "8. Match 'eventX' (Direct/Pattern/Wildcard)" --> CEB_WildcardLogic;
        CEB_WildcardLogic -- "9. Invoke Handler" --> HandlerB["AppModuleB.onEventX(eventObject)"];
        HandlerB -- "10. Processes Event" --> LogicB["Module B Logic Executed"];
    else Queued Event
        CEB_Queues -- Later via processQueue() --> StandardEvent;
        StandardEvent -- "Re-enters Emission Flow (steps 7-10)" --> CEB_Subscriptions;
    end

    HandlerB -- "Optional: Reports Error via coreEventBus.handleError()" --> CoreEventBus_Engine;
    CoreEventBus_Engine -- "Forwards error via safeHandleError" --> ErrorSystemGlobal["ErrorSystem"];


    classDef stateNode fill:#f9f,stroke:#333,stroke-width:2px;
    classDef component fill:#D6EAF8,stroke:#5DADE2,stroke-width:2px;
    classDef appComp fill:#E8F8F5,stroke:#76D7C4,stroke-width:1px;
    class EBS_State, CEB_State, CEB_Queues, CEB_History, CEB_Subscriptions stateNode;
    class EventBusSystem_Facade, CoreEventBus_Engine component;
    class AppModuleA, HandlerB, LogicB, ErrorSystemGlobal appComp;
```

---
## 6. Usage Examples & Best Practices

### 6.1. Emitting an Event
(From a `CoreModule` or component with access to `CoreEventBus`)
**CoreEventBus**: Emitting an Event Example
```javascript
// Assuming 'eventBus' is an instance of CoreEventBus obtained via eventBusSystem.getEventBus()
// import { ErrorCodes } from '../core/errors/ErrorCodes.js'; // For example errors
// import { EventError } from '../core/errors/index.js'; // For example errors

// async function publishUserCreation(userData) {
//   try {
//     const eventName = 'user.created'; // Consistent event name
//     const data = {
//       userId: userData.id,
//       username: userData.username,
//       email: userData.email,
//       registrationDate: new Date().toISOString()
//     };
//     const options = {
//       metadata: {
//         source: 'UserModule', // Or specific service name
//         correlationId: 'some-request-id-123' // For tracing
//       }
//       // To queue this event:
//       // queue: true,
//       // immediate: false, // Process queue later via processQueue('user.created')
//     };
//     const wasEmittedOrQueued = await eventBus.emit(eventName, data, options);
//     if (wasEmittedOrQueued) {
//       console.log(`Event '${eventName}' emitted/queued successfully.`);
//     } else {
//       // This might indicate no direct listeners if not queued.
//       console.warn(`Event '${eventName}' had no direct listeners (if not queued).`);
//     }
//   } catch (error) {
//     // This catch block is for errors from the eventBus.emit() process itself
//     // (e.g., invalid eventName, internal history/queueing error),
//     // NOT for errors thrown by event listeners.
//     // error.code here would be a prefixed code like 'EVENT_INVALID_EVENT_NAME'
//     console.error(`Failed to emit event: [${error.code}] ${error.message}`, error);
//     // Example: if (error.code === `EVENT_${ErrorCodes.EVENT.INVALID_EVENT_NAME}`) { /* ... */ }
//     // Potentially report this critical failure to ErrorSystem
//     // await errorSystem.handleError(error, { operation: 'publishUserCreationEvent' });
//   }
// }

// // Example usage:
// // publishUserCreation({ id: 'usr_456', username: 'bob_the_builder', email: 'bob@example.com' });
```

### 6.2. Subscribing to Events (Exact, Pattern, Wildcard)
(Typically in `CoreModule.setupEventHandlers`)
**CoreEventBus**: Subscription Examples
```javascript
// Assuming 'eventBus' is an instance of CoreEventBus
// Assuming INVENTORY_EVENTS and USER_EVENTS are imported objects with event name constants
// e.g., const USER_EVENTS = { CREATED: 'user.created' };
// e.g., const INVENTORY_EVENTS = { ITEM_ADDED: 'inventory.item.added', STOCK_UPDATED: 'inventory.item.stock_updated' };
// import { EventError } from '../core/errors/index.js';
// import { ErrorCodes } from '../core/errors/ErrorCodes.js';

// // --- Example 1: Subscribing to an exact event name ---
// const userCreatedSubId = eventBus.subscribe(
//   USER_EVENTS.CREATED, // e.g., 'user.created'
//   async (event) => { // Handler receives the full standard event object
//     console.log(`[UserCreationHandler] Received event: ${event.name} (ID: ${event.id})`);
//     console.log('User Data:', event.data);
//     console.log('Metadata:', event.metadata);
//     try {
//       // await welcomeEmailService.sendWelcomeEmail(event.data.email);
//     } catch (error) {
//       // Report errors from within the handler
//       // Example of creating a new EventError if needed, or passing the caught error directly
//       const handlerError = error instanceof EventError ? error : new EventError(
//           ErrorCodes.EVENT.HANDLER_ERROR, // Using unprefixed code from ErrorCodes.EVENT
//           `Handler UserCreationHandler failed: ${error.message}`,
//           { originalErrorName: error.name },
//           { cause: error }
//       );
//       await eventBus.handleError(handlerError, {
//         handler: 'UserCreationHandler',
//         eventId: event.id,
//         eventName: event.name
//       });
//     }
//   }
// );
// // To unsubscribe later (e.g., in a module's onShutdown):
// // eventBus.unsubscribe(userCreatedSubId);


// // --- Example 2: Subscribing to a pattern (e.g., all item events in inventory) ---
// const inventoryItemSubId = eventBus.subscribe(
//   'inventory.item.*', // Matches inventory.item.added, inventory.item.updated, etc.
//   async (event) => { // Handler receives the full standard event object
//     console.log(`[InventoryItemEventHandler] Received event: ${event.name} (ID: ${event.id})`);
//     // event.name will be the specific event like 'inventory.item.added'
//     switch (event.name) {
//       case INVENTORY_EVENTS.ITEM_ADDED:
//         // console.log('Item Added:', event.data);
//         break;
//       case INVENTORY_EVENTS.STOCK_UPDATED:
//         // console.log('Stock Updated:', event.data);
//         break;
//       // default:
//         // console.log('Unhandled inventory item event:', event.name);
//     }
//   }
// );

// // --- Example 3: Subscribing to all events (global wildcard) ---
// const allEventsSubId = eventBus.subscribe(
//   '*', // Global wildcard
//   async (event) => { // Handler receives the full standard event object
//     console.log(`[GlobalAuditLogger] Event Received - Name: ${event.name}, ID: ${event.id}, Timestamp: ${event.timestamp}`);
//   }
// );
```

### 6.3. Using Event Queuing
**CoreEventBus**: Event Queuing Example
```javascript
// Assuming 'eventBus' is an instance of CoreEventBus
// Assuming 'logger' is available
// import { ErrorCodes } from '../core/errors/ErrorCodes.js'; // For example errors
// import { EventError } from '../core/errors/index.js'; // For example errors


// async function sendBatchNotifications(notifications) {
//   for (const notification of notifications) {
//     try {
//       await eventBus.emit(
//         'notification.send', // Event name, also serves as queue name
//         notification,        // e.g., { userId, message, type: 'email' }
//         {
//           queue: true,       // Enable queuing for this event
//           immediate: false,  // Don't process immediately
//           metadata: { priority: 'low' }
//         }
//       );
//       // logger.info(`Notification queued for user: ${notification.userId}`);
//     } catch (error) {
//       // Handle error from the emit/queueing process itself
//       // error.code would be prefixed, e.g., EVENT_QUEUE_OPERATION_FAILED
//       logger.error(`Failed to queue notification for user ${notification.userId}: [${error.code}] ${error.message}`);
//       // Example: if (error.code === `EVENT_${ErrorCodes.EVENT.QUEUE_OPERATION_FAILED}`) { /* ... */ }
//       // await errorSystem.handleError(error, { operation: 'queueNotification' });
//     }
//   }
// }

// // --- Later, in a separate worker or a scheduled task ---
// async function processNotificationQueue() {
//   // logger.info('Starting to process notification queue...');
//   try {
//     const processedCount = await eventBus.processQueue('notification.send');
//     // if (processedCount > 0) {
//     //   logger.info(`Processed ${processedCount} notifications from the queue.`);
//     // } else {
//     //   logger.info('Notification queue was empty or no new items processed in this batch.');
//     // }
//   } catch (error) {
//     // Handle error from the processQueue operation itself (not handler errors)
//     // error.code would be prefixed, e.g., EVENT_QUEUE_PROCESSING_FAILED
//     logger.error(`Error during notification queue processing: [${error.code}] ${error.message}`);
//     // await errorSystem.handleError(error, { operation: 'processNotificationQueue' });
//   }
// }

// // --- Handler for 'notification.send' (subscribed elsewhere) ---
// // eventBus.subscribe('notification.send', async (event) => {
// //   const notificationData = event.data;
// //   logger.info(`Handler invoked for 'notification.send': Sending to ${notificationData.userId}`);
// //   try {
// //     // await actualEmailOrPushNotificationService.send(notificationData);
// //     // logger.info(`Notification successfully sent to ${notificationData.userId}`);
// //   } catch (handlerError) {
// //     logger.error(`Handler for 'notification.send' failed for user ${notificationData.userId}: ${handlerError.message}`);
// //     // Report error from within the handler using CoreEventBus's public handleError
// //     // The handlerError might be a generic Error, or a specific CoreError subclass.
// //     // handleError will ensure it's reported to ErrorSystem.
// //     await eventBus.handleError(handlerError, {
// //       handler: 'NotificationSendHandler',
// //       eventId: event.id,
// //       notificationData
// //     });
// //   }
// // });
```

### 6.4. Accessing Event History
**CoreEventBus**: Accessing Event History Example
```javascript
// Assuming 'eventBus' is an instance of CoreEventBus
// Assuming 'logger' is available

// async function inspectRecentUserEvents() {
//   const eventName = 'user.created';
//   try {
//     // Get the last 5 'user.created' events
//     const recentUserCreations = eventBus.getHistory(eventName, { limit: 5 });
//     if (recentUserCreations.length > 0) {
//       logger.info(`Last ${recentUserCreations.length} '${eventName}' events:`);
//       recentUserCreations.forEach(event => {
//         logger.info(`  ID: ${event.id}, Timestamp: ${event.timestamp}, Data: ${JSON.stringify(event.data)}`);
//       });
//     } else {
//       logger.info(`No recent history found for event '${eventName}'.`);
//     }
//   } catch (error) {
//     // Handle error from getHistory or getAllHistory methods themselves
//     // (These methods themselves don't typically throw unless there's an unexpected internal state corruption)
//     logger.error(`Failed to retrieve event history: ${error.message}`);
//     // await errorSystem.handleError(error, { operation: 'inspectRecentUserEvents' });
//   }
// }
```
### 6.5. Error Handling in Event Listeners
**CoreEventBus**: Error Handling within Event Listeners
```javascript
// Assuming 'eventBus' is an instance of CoreEventBus
// Assuming 'logger' and 'ErrorSystem' (or a way to report to it) are available
// import { ErrorCodes } from '../core/errors/ErrorCodes.js';
// import { ValidationError } from '../core/errors/types/ValidationError.js'; // If throwing specific types

// // Example event listener (subscriber handler)
// const orderProcessingSubId = eventBus.subscribe(
//   'order.created',
//   async (event) => { // Handler receives the full standard event object
//     logger.info(`[OrderProcessor] Processing order ID: ${event.data.orderId}, Event ID: ${event.id}`);
//     try {
//       const orderData = event.data;
//       if (orderData.totalAmount <= 0) {
//         // For business rule violations, throw a specific CoreError subclass
//         // ErrorCodes.VALIDATION.INVALID_INPUT is 'INVALID_INPUT'
//         throw new ValidationError(
//           ErrorCodes.VALIDATION.INVALID_INPUT, 
//           'Order total amount must be greater than zero.',
//           { 
//             validationErrors: [{ field: 'totalAmount', message: 'Must be positive' }],
//             orderId: orderData.orderId, 
//             totalAmount: orderData.totalAmount 
//           }
//         );
//         // The error.code on this instance will be 'VALIDATION_INVALID_INPUT'
//       }

//       if (orderData.isFraudulent) { // Simulate another potential error
//         throw new Error("Simulated critical processing error for fraudulent order.");
//       }
//       // ... successful processing logic ...
//       logger.info(`[OrderProcessor] Successfully processed order ID: ${event.data.orderId}`);
//     } catch (error) {
//       logger.error(`[OrderProcessor] Error handling event '${event.name}' (ID: ${event.id}): ${error.message}`);
//       // Report the error using CoreEventBus's public handleError method.
//       // This ensures the error is processed by the central ErrorSystem.
//       // If 'error' is not already a CoreError, handleError will wrap it.
//       await eventBus.handleError(error, {
//         handlerName: 'OrderCreatedHandler',
//         eventName: event.name,
//         eventId: event.id,
//         eventDataSummary: { orderId: event.data.orderId, customerId: event.data.customerId }
//       });
//     }
//   }
// );
```
**Best Practices:**
* Obtain `CoreEventBus` via `EventBusSystem`.
* Clear event naming (e.g., `domain.entity.action`).
* Treat event data as immutable in handlers.
* Idempotent handlers.
* Focused handlers; delegate complex logic.
* Unsubscribe in component shutdown to prevent memory leaks.
* Provide rich context when reporting listener errors via `coreEventBus.handleError()`.
* Use queuing strategically.

---
## 7. Testing Strategy Notes
* **`CoreEventBus`**:
    * Test `emit` (with/without listeners/queuing), `subscribe` (exact, pattern, wildcard, handler signature), `unsubscribe`.
    * Test queuing (`queueEvent`, `processQueue` batching & listener error handling), `processAllQueues`.
    * Test history (`trackEvent`, `getHistory`, `getAllHistory`, `maxHistorySize`).
    * Test `reset()`, `shutdown()`.
    * Test `handleError` forwarding. Test internal error handling. Verify metrics & health.
* **`EventBusSystem`**:
    * Test `initialize` creates/inits `CoreEventBus`. Test `getEventBus()`. Test `shutdown()`.
    * Test event forwarding logic if maintained. Verify own lifecycle, health, metrics, errors.

---
## 8. Future Considerations & Potential Enhancements
(Drawn from `event-bus-docs.md` and broader EDA patterns)
* **Advanced Event Routing**: Topic/content-based routing, message broker integration.
* **Event Schema Validation**: Using JSON Schema for payloads.
* **Event Versioning**: Managing schema changes.
* **Dead Letter Queues (DLQ)**: For consistently failing events.
* **Event Persistence & Sourcing**: Durable storage, replay, event sourcing.
* **Distributed Event Bus**: For microservices (Kafka, RabbitMQ, NATS).
* **Enhanced Observability**: Integration with distributed tracing.
* **Transactional Outbox Pattern**: Atomicity for DB changes and event emissions.


// src/core/event/index.js

/**
 * @file src/core/event/index.js
 * @description Barrel file for exporting event system components.
 */

import { CoreEventBus, createEventBus } from './CoreEventBus.js';
import { EventBusSystem, createEventBusSystem } from './EventBusSystem.js';

export {
  CoreEventBus,
  createEventBus,
  EventBusSystem,
  createEventBusSystem,
};

// Optional default export:
// export default {
//   CoreEventBus,
//   createEventBus,
//   EventBusSystem,
//   createEventBusSystem,
// };


// src/core/module/CoreModule.js

/**
 * @file CoreModule.js
 * @description Base class for all business logic modules in the TSMIS.
 * Provides standardized lifecycle, dependency management, error handling, eventing,
 * health monitoring, and metrics tracking.
 */

import { EventEmitter } from 'events';
import { CoreEventBus } from '../event/CoreEventBus.js';
import { ModuleError, ValidationError, CoreError } from '../errors/index.js';
import { ErrorCodes } from '../errors/ErrorCodes.js';
import { SYSTEM_STATUS, LIFECYCLE_EVENTS, DEFAULT_CONFIG } from '../common/SystemConstants.js';
import { safeHandleError, createStandardHealthCheckResult } from '../common/ErrorUtils.js';

export class CoreModule extends EventEmitter {
  /**
   * @property {Array<string|object>} dependencies - Declares dependencies for the module.
   * Entries can be strings (for required dependency names) or objects
   * for more complex declarations like optional dependencies.
   * Example:
   * static dependencies = [
   * ...CoreModule.dependencies, // Inherits base dependencies
   * 'anotherRequiredModule',
   * { name: 'optionalAnalyticsModule', optional: true },
   * 'paymentService' // A non-module service to be injected by ModuleSystem
   * ];
   */
  static dependencies = ['errorSystem', 'eventBusSystem', 'config', 'containerSystem']; // Added containerSystem
  static version = '2.0.0';

  /**
   * Creates a new CoreModule instance.
   * @param {object} [deps={}] - Dependencies injected by ModuleSystem. This will include:
   * - Core systems like `errorSystem`, `eventBusSystem`.
   * - The `containerSystem` instance for dynamic resolution if needed.
   * - The module's specific `config` object.
   * - Other modules and services declared in `static dependencies`, resolved and injected by ModuleSystem.
   * - Missing optional dependencies will be injected as `null` or `undefined`.
   */
  constructor(deps = {}) {
    super();
    this.deps = {
      errorSystem: deps.errorSystem,
      eventBusSystem: deps.eventBusSystem,
      config: deps.config || {},
      containerSystem: deps.containerSystem, // Store containerSystem
      ...deps
    };
    this.config = this.deps.config;

    try {
        this.eventBus = this.deps.eventBusSystem?.getEventBus();
    } catch (e) {
        this.eventBus = null;
    }

    this.healthCheckInterval = null;
    this.healthCheckIntervalMs = this.config?.healthCheckIntervalMs || DEFAULT_CONFIG.DEFAULT_HEALTH_CHECK_INTERVAL;
    this.state = {
      status: SYSTEM_STATUS.CREATED,
      startTime: null,
      errors: [],
      metrics: new Map(),
      healthChecks: new Map(),
      lastHealthCheck: null,
    };

    this.registerHealthCheck(`${this.constructor.name.toLowerCase()}.state`, this.checkModuleState.bind(this));
  }

  /**
   * Validates that required dependencies (as per static dependencies array) are provided and are valid.
   * Optional dependencies are not required to be present in this.deps.
   * @private
   */
  _validateDependencies() {
    const declaredDependencies = this.constructor.dependencies || CoreModule.dependencies;
    const missingRequired = [];

    for (const depDecl of declaredDependencies) {
      const depName = typeof depDecl === 'string' ? depDecl : depDecl.name;
      const isOptional = typeof depDecl === 'object' && depDecl.optional === true;

      if (!this.deps[depName] && !isOptional) {
        missingRequired.push(depName);
      }
    }

    if (missingRequired.length > 0) {
      throw new ModuleError(
        ErrorCodes.MODULE.MISSING_DEPENDENCIES, // Uses unprefixed
        `${this.constructor.name}: Missing required dependencies: ${missingRequired.join(', ')}`,
        { moduleName: this.constructor.name, missingDeps: missingRequired }
      );
    }

    // Validate core dependencies types if they are present (they should be if required)
    if (this.deps.eventBusSystem && typeof this.deps.eventBusSystem.getEventBus !== 'function') {
      throw new ModuleError(
        ErrorCodes.MODULE.INVALID_DEPENDENCY, // Uses unprefixed
        `${this.constructor.name}: EventBusSystem dependency is invalid.`,
        { moduleName: this.constructor.name, dependency: 'eventBusSystem' }
      );
    }
    if (this.deps.errorSystem && typeof this.deps.errorSystem.handleError !== 'function') {
      throw new ModuleError(
        ErrorCodes.MODULE.INVALID_DEPENDENCY, // Uses unprefixed
        `${this.constructor.name}: ErrorSystem dependency is invalid.`,
        { moduleName: this.constructor.name, dependency: 'errorSystem' }
      );
    }
    if (this.deps.containerSystem && typeof this.deps.containerSystem.resolve !== 'function') {
        // If containerSystem becomes a mandatory part of deps for all modules (passed by ModuleSystem)
        throw new ModuleError(
            ErrorCodes.MODULE.INVALID_DEPENDENCY, // Uses unprefixed
            `${this.constructor.name}: ContainerSystem dependency is invalid.`,
            { moduleName: this.constructor.name, dependency: 'containerSystem' }
        );
    }
  }

  async _handleInternalError(error, context = {}) {
    const errorToLog = !(error instanceof ModuleError || error instanceof ValidationError || error instanceof CoreError)
      ? new ModuleError(ErrorCodes.MODULE.INTERNAL_ERROR, error.message, context, { cause: error })
      : error;
    this.state.errors.push({ error: errorToLog, timestamp: new Date().toISOString(), context });
    if (this.state.errors.length > (this.config?.maxErrorHistory || DEFAULT_CONFIG.MAX_ERROR_HISTORY)) {
      this.state.errors.shift();
    }
    this.recordMetric(`${this.constructor.name.toLowerCase()}.errors.internal`, 1, { errorName: errorToLog.name, errorCode: errorToLog.code });
    await safeHandleError(this.deps.errorSystem, errorToLog, { source: this.constructor.name, ...context });
  }

  async validateConfig() {
    try {
      if (this.config === null || typeof this.config !== 'object') {
        throw new ValidationError(
          ErrorCodes.VALIDATION.INVALID_INPUT,
          `${this.constructor.name}: Configuration must be an object.`,
           { moduleName: this.constructor.name, receivedType: typeof this.config }
        );
      }
      await this.onValidateConfig();
      this.recordMetric(`${this.constructor.name.toLowerCase()}.config.validation.success`, 1);
      return true;
    } catch (error) {
      this.recordMetric(`${this.constructor.name.toLowerCase()}.config.validation.failure`, 1, { error: error.code });
      const configError = error instanceof ModuleError || error instanceof ValidationError ? error : new ModuleError(
        ErrorCodes.MODULE.CONFIG_VALIDATION_FAILED, // Uses unprefixed
        `${this.constructor.name}: Failed to validate configuration.`,
        { moduleName: this.constructor.name, originalMessage: error.message },
        { cause: error }
      );
      await this._handleInternalError(configError, { phase: 'validateConfig' });
      throw configError;
    }
  }

  async initialize() {
    if (this.state.status === SYSTEM_STATUS.RUNNING || this.state.status === SYSTEM_STATUS.INITIALIZING) {
      const err = new ModuleError(ErrorCodes.MODULE.ALREADY_INITIALIZED, `${this.constructor.name} is already initialized or initializing.`);
      await this._handleInternalError(err);
      return this;
    }

    super.emit(`${LIFECYCLE_EVENTS.INITIALIZING}:${this.constructor.name.toLowerCase()}`);
    this.state.status = SYSTEM_STATUS.INITIALIZING;
    this.state.startTime = Date.now();

    try {
      this._validateDependencies();

      if (this.deps.eventBusSystem && typeof this.deps.eventBusSystem.getEventBus === 'function') {
          try {
            this.eventBus = this.deps.eventBusSystem.getEventBus();
          } catch (e) {
             throw new ModuleError(
                ErrorCodes.MODULE.DEPENDENCY_NOT_READY, // Uses unprefixed
                `${this.constructor.name}: EventBusSystem is not ready.`,
                { moduleName: this.constructor.name, dependency: 'eventBusSystem' },
                { cause: e }
            );
          }
      } else if (!this.eventBus && (this.constructor.dependencies || CoreModule.dependencies).includes('eventBusSystem')) {
          throw new ModuleError(ErrorCodes.MODULE.INVALID_DEPENDENCY, `${this.constructor.name}: EventBus could not be obtained from EventBusSystem.`);
      }

      await this.validateConfig();
      await this.onConfigure();
      await this.setupEventHandlers();
      await this.setupHealthChecks();
      await this.onInitialize();

      this.startHealthChecks();

      this.state.status = SYSTEM_STATUS.RUNNING;
      this.recordMetric(`${this.constructor.name.toLowerCase()}.initialized.success`, 1);
      await this.emit(`module:initialized`, {
        name: this.constructor.name,
        timestamp: new Date().toISOString(),
      });
      super.emit(`${LIFECYCLE_EVENTS.INITIALIZED}:${this.constructor.name.toLowerCase()}`, { timestamp: new Date().toISOString() });
      super.emit(`${LIFECYCLE_EVENTS.RUNNING}:${this.constructor.name.toLowerCase()}`, { timestamp: new Date().toISOString() });

    } catch (error) {
      this.state.status = SYSTEM_STATUS.ERROR;
      this.recordMetric(`${this.constructor.name.toLowerCase()}.initialized.failure`, 1, { error: error.code });
      await this._handleInternalError(error, { phase: 'initialization' });
      const initFailedError = error instanceof ModuleError || error instanceof ValidationError ? error : new ModuleError(
        ErrorCodes.MODULE.INITIALIZATION_FAILED, // Uses unprefixed
        `${this.constructor.name}: Failed to initialize.`,
        { moduleName: this.constructor.name, originalMessage: error.message },
        { cause: error }
      );
      await this.emit('module:error', { module: this.constructor.name, error: initFailedError, context: { phase: 'initialization' }});
      throw initFailedError;
    }
    return this;
  }

  async setupHealthChecks() {
    await this.onSetupHealthChecks();
  }

  registerHealthCheck(name, checkFn) {
    if (typeof checkFn !== 'function') {
      const err = new ModuleError(ErrorCodes.MODULE.INVALID_HEALTH_CHECK, `${this.constructor.name}: Health check '${name}' must be a function.`);
      this._handleInternalError(err);
      throw err;
    }
    this.state.healthChecks.set(name, checkFn);
  }

  startHealthChecks() {
    if (this.healthCheckInterval) {
      clearInterval(this.healthCheckInterval);
    }
    if (Object.keys(this.state.healthChecks).length === 0 && !this.state.healthChecks.size === 0) { // Don't start if no checks registered
        return;
    }
    this.healthCheckInterval = setInterval(async () => {
      try {
        const health = await this.checkHealth();
        this.state.lastHealthCheck = health;
        if (health.status !== SYSTEM_STATUS.HEALTHY) {
          const healthError = new ModuleError(
            ErrorCodes.MODULE.UNHEALTHY, // Uses unprefixed
            `${this.constructor.name} health check reported: ${health.status}`,
            { moduleName: this.constructor.name, healthDetails: health }
          );
          await this.handleError(healthError, { phase: 'periodic-health-check' });
        }
      } catch (error) {
        await this._handleInternalError(error, { phase: 'execute-periodic-health-check' });
      }
    }, this.healthCheckIntervalMs);
  }

  async checkHealth() {
    const results = {};
    let overallStatus = SYSTEM_STATUS.HEALTHY;

    for (const [name, checkFn] of this.state.healthChecks) {
      try {
        const checkResult = await checkFn();
        results[name] = checkResult;
        if (checkResult.status !== SYSTEM_STATUS.HEALTHY) {
          overallStatus = (overallStatus === SYSTEM_STATUS.HEALTHY && checkResult.status === SYSTEM_STATUS.DEGRADED)
            ? SYSTEM_STATUS.DEGRADED
            : SYSTEM_STATUS.UNHEALTHY;
        }
      } catch (error) {
        results[name] = createStandardHealthCheckResult(SYSTEM_STATUS.UNHEALTHY, { error: 'Health check threw an exception' }, [error]);
        overallStatus = SYSTEM_STATUS.UNHEALTHY;
      }
    }
    return {
      name: this.constructor.name,
      version: this.constructor.version,
      status: overallStatus,
      timestamp: new Date().toISOString(),
      uptime: this.state.startTime ? Date.now() - this.state.startTime : 0,
      errorCount: this.state.errors.length,
      checks: results,
    };
  }

  async handleError(error, context = {}) {
    const errorToHandle = !(error instanceof CoreError)
        ? new ModuleError(ErrorCodes.MODULE.OPERATION_FAILED, error.message, context, { cause: error })
        : error;
    this.state.errors.push({ error: errorToHandle, timestamp: new Date().toISOString(), context: context || {} });
    if (this.state.errors.length > (this.config?.maxErrorHistory || DEFAULT_CONFIG.MAX_ERROR_HISTORY)) {
      this.state.errors.shift();
    }
    this.recordMetric(`${this.constructor.name.toLowerCase()}.errors.operational`, 1, { errorName: errorToHandle.name, errorCode: errorToHandle.code });
    await safeHandleError(this.deps.errorSystem, errorToHandle, {
      module: this.constructor.name,
      ...(context || {})
    });
    super.emit('module:error', {
      module: this.constructor.name,
      error: errorToHandle,
      context: context || {}
    });
    return this;
  }

  async emit(eventName, ...args) {
    const localEmitResult = super.emit(eventName, ...args);

    if (this.eventBus && typeof this.eventBus.emit === 'function' && this.state.status === SYSTEM_STATUS.RUNNING) {
      try {
        await this.eventBus.emit(eventName, args[0], args[1] || {});
      } catch (busError) {
        await this.handleError(busError, {
          phase: 'event-bus-emit',
          event: eventName,
          argsSummary: args.map(arg => typeof arg).join(', ')
        });
      }
    }
    return localEmitResult;
  }

  async shutdown() {
    if (this.state.status === SYSTEM_STATUS.SHUTDOWN || this.state.status === SYSTEM_STATUS.SHUTTING_DOWN) {
      return this;
    }
    super.emit(`${LIFECYCLE_EVENTS.SHUTTING_DOWN}:${this.constructor.name.toLowerCase()}`);
    this.state.status = SYSTEM_STATUS.SHUTTING_DOWN;
    const shutdownStartTime = Date.now();
    if (this.healthCheckInterval) {
      clearInterval(this.healthCheckInterval);
      this.healthCheckInterval = null;
    }

    try {
      await this.onShutdown();

      this.state.status = SYSTEM_STATUS.SHUTDOWN;
      this.state.startTime = null;
      const shutdownTime = Date.now() - shutdownStartTime;
      this.recordMetric(`${this.constructor.name.toLowerCase()}.shutdown.time`, shutdownTime);
      this.recordMetric(`${this.constructor.name.toLowerCase()}.shutdown.success`, 1);
      await this.emit('module:shutdown', {
        name: this.constructor.name,
        timestamp: new Date().toISOString(),
      });
      super.emit(`${LIFECYCLE_EVENTS.SHUTDOWN}:${this.constructor.name.toLowerCase()}`, { timestamp: new Date().toISOString(), durationMs: shutdownTime });
    } catch (error) {
      this.state.status = SYSTEM_STATUS.ERROR;
      this.recordMetric(`${this.constructor.name.toLowerCase()}.shutdown.failure`, 1, { error: error.code });
      await this._handleInternalError(error, { phase: 'shutdown' });
      const shutdownFailedError = error instanceof ModuleError || error instanceof ValidationError ?
      error : new ModuleError(
        ErrorCodes.MODULE.SHUTDOWN_FAILED, // Uses unprefixed
        `${this.constructor.name}: Failed to shutdown.`,
        { moduleName: this.constructor.name, originalMessage: error.message },
        { cause: error }
      );
      await this.emit('module:error', { module: this.constructor.name, error: shutdownFailedError, context: { phase: 'shutdown' }});
      throw shutdownFailedError;
    }
    return this;
  }

  // --- Lifecycle Hooks for subclasses to override ---
  async onValidateConfig() { return true; }
  async onConfigure() { /* Default: no-op */ }
  async setupEventHandlers() { /* Default: no-op */ }
  async onSetupHealthChecks() { /* Default: no-op */ }
  async onInitialize() { /* Default: no-op */ }
  async onShutdown() { /* Default: no-op */ }

  // --- Metrics ---
  recordMetric(name, value, tags = {}) {
    this.state.metrics.set(name, { value, timestamp: Date.now(), tags });
  }

  getMetrics() {
    const metrics = {};
    for (const [name, data] of this.state.metrics) {
      metrics[name] = data;
    }
    return metrics;
  }

  // --- Health Check State & Status ---
  async checkModuleState() {
    return createStandardHealthCheckResult(
      this.state.status === SYSTEM_STATUS.RUNNING ? SYSTEM_STATUS.HEALTHY : SYSTEM_STATUS.UNHEALTHY,
      {
        currentStatus: this.state.status,
        uptime: this.state.startTime ? Date.now() - this.state.startTime : 0,
        internalErrorCount: this.state.errors.length,
        lastHealthCheckStatus: this.state.lastHealthCheck?.status || 'N/A'
      }
    );
  }

  getSystemStatus() {
    return {
        name: this.constructor.name,
        version: this.constructor.version || CoreModule.version,
        status: this.state.status,
        uptime: this.state.startTime ? Date.now() - this.state.startTime : 0,
        initialized: this.state.status === SYSTEM_STATUS.RUNNING,
        errorCount: this.state.errors.length,
        timestamp: new Date().toISOString(),
        lastHealthCheck: this.state.lastHealthCheck ? {
            status: this.state.lastHealthCheck.status,
            timestamp: this.state.lastHealthCheck.timestamp
        } : null
    };
  }
}

/**
 * Factory function for creating a CoreModule instance.
 * Provides default no-op dependencies if not supplied, useful for testing or basic modules.
 * @param {object} [deps={}] - Dependencies for the CoreModule.
 * @returns {CoreModule}
 */
export function createModule(deps = {}) {
  const defaultDeps = {
    errorSystem: {
      handleError: async (error, context) => { console.error("Default No-Op ErrorSystem:", error, context); }
    },
    eventBusSystem: {
      getEventBus: () => {
        // CHANGED: Return a simple EventEmitter for default/testing scenarios
        // This avoids instantiating a full CoreEventBus with its own dependencies.
        // console.warn("[CoreModule Factory] Using default simple EventEmitter for eventBusSystem.getEventBus().");
        return new EventEmitter();
      }
    },
    config: {},
    containerSystem: {
        resolve: async (name) => {
            const errMsg = `[CoreModule Factory] Default No-Op ContainerSystem: Attempted to resolve '${name}' but no services are registered in this mock.`;
            console.warn(errMsg);
            // To better simulate ContainerSystem's behavior of throwing if a service is not found (unless optional handling is added there)
            const error = new Error(`Service ${name} not found in default container.`);
            // Mimic a ServiceError structure if possible for consistency in tests that might check error.code
            // Assuming SERVICE_UNKNOWN_COMPONENT is 'UNKNOWN_COMPONENT' in ErrorCodes.SERVICE
            error.code = `SERVICE_${ErrorCodes.SERVICE.UNKNOWN_COMPONENT}`; 
            throw error;
        }
    }
  };
  const mergedDeps = {
    ...defaultDeps,
    ...deps,
    // Ensure specific config for the module is under the 'config' key passed to constructor
    config: deps.config || defaultDeps.config,
    // If errorSystem or eventBusSystem or containerSystem are provided in deps, they will override defaults
    errorSystem: deps.errorSystem || defaultDeps.errorSystem,
    eventBusSystem: deps.eventBusSystem || defaultDeps.eventBusSystem,
    containerSystem: deps.containerSystem || defaultDeps.containerSystem,
  };
  return new CoreModule(mergedDeps);
}


// src/core/module/ModuleSystem.js

/**
 * @file ModuleSystem.js
 * @description Manages the lifecycle, registration, and dependencies of CoreModules.
 */

import { EventEmitter } from 'events';
import { CoreModule } from './CoreModule.js';
import { ModuleError, ValidationError, CoreError } from '../errors/index.js';
import { ErrorCodes } from '../errors/ErrorCodes.js';
import { SYSTEM_STATUS, LIFECYCLE_EVENTS, DEFAULT_CONFIG } from '../common/SystemConstants.js';
import { safeHandleError, createStandardHealthCheckResult } from '../common/ErrorUtils.js';

export class ModuleSystem extends EventEmitter {
  static dependencies = ['errorSystem', 'eventBusSystem', 'config', 'containerSystem']; // Added containerSystem
  static version = '2.0.0';

  /**
   * Creates a new ModuleSystem instance.
   * @param {object} [deps={}] - Dependencies for the ModuleSystem.
   * @param {object} deps.errorSystem - The ErrorSystem instance.
   * @param {object} deps.eventBusSystem - The EventBusSystem instance.
   * @param {object} [deps.config={}] - Global configuration.
   * @param {object} deps.containerSystem - The main ContainerSystem instance.
   */
  constructor(deps = {}) {
    super();
    this.deps = {
      errorSystem: deps.errorSystem,
      eventBusSystem: deps.eventBusSystem,
      config: deps.config || {},
      containerSystem: deps.containerSystem, // Store containerSystem
      ...deps
    };

    this.modules = new Map();
    this.eventBus = null;

    this.state = {
      status: SYSTEM_STATUS.CREATED,
      startTime: null,
      errors: [],
      metrics: new Map(),
      moduleHealth: new Map(),
      healthCheckIntervals: new Map(),
      healthChecks: new Map(),
    };

    this._validateDependencies();
    this.setupDefaultHealthChecks();
  }

  /**
   * Validates that required dependencies are provided and are valid.
   * @private
   */
  _validateDependencies() {
    const missing = ModuleSystem.dependencies.filter(dep => !this.deps[dep]);
    if (missing.length > 0) {
      throw new ModuleError(
        ErrorCodes.MODULE.MISSING_DEPENDENCIES, // Uses unprefixed
        `ModuleSystem: Missing required dependencies: ${missing.join(', ')}`,
        { missingDeps: missing }
      );
    }
    if (!this.deps.eventBusSystem || typeof this.deps.eventBusSystem.getEventBus !== 'function') {
      throw new ModuleError(ErrorCodes.MODULE.INVALID_DEPENDENCY, 'ModuleSystem: EventBusSystem is invalid.'); // Uses unprefixed
    }
    if (!this.deps.errorSystem || typeof this.deps.errorSystem.handleError !== 'function') {
      throw new ModuleError(ErrorCodes.MODULE.INVALID_DEPENDENCY, 'ModuleSystem: ErrorSystem is invalid.'); // Uses unprefixed
    }
    if (!this.deps.containerSystem || typeof this.deps.containerSystem.resolve !== 'function') {
      throw new ModuleError(ErrorCodes.MODULE.INVALID_DEPENDENCY, 'ModuleSystem: ContainerSystem is invalid or missing.'); // Uses unprefixed
    }
  }

  async _handleInternalError(error, context = {}) {
    const errorToLog = !(error instanceof ModuleError || error instanceof ValidationError || error instanceof CoreError)
      ? new ModuleError(ErrorCodes.MODULE.SYSTEM_ERROR, error.message, context, { cause: error })
      : error;
    this.state.errors.push({ error: errorToLog, timestamp: new Date().toISOString(), context });
    if (this.state.errors.length > (this.deps.config?.moduleSystem?.maxErrorHistory || DEFAULT_CONFIG.MAX_ERROR_HISTORY)) {
      this.state.errors.shift();
    }
    this.recordMetric('modulesystem.errors.internal', 1, { errorName: errorToLog.name, errorCode: errorToLog.code });
    await safeHandleError(this.deps.errorSystem, errorToLog, { source: 'ModuleSystem', ...context });
  }

  async handleModuleError(moduleName, error, moduleContext = {}) {
    this.state.errors.push({
      error,
      timestamp: new Date().toISOString(),
      context: { moduleName, ...moduleContext, type: 'moduleReported' }
    });
    if (this.state.errors.length > (this.deps.config?.moduleSystem?.maxErrorHistory || DEFAULT_CONFIG.MAX_ERROR_HISTORY)) {
      this.state.errors.shift();
    }
    this.recordMetric('modulesystem.errors.module_reported', 1, { moduleName, errorName: error.name, errorCode: error.code });
    await safeHandleError(this.deps.errorSystem, error, {
      source: 'ModuleSystemRelay',
      module: moduleName,
      originalContext: moduleContext,
      timestamp: new Date().toISOString()
    });
    super.emit('module:error', {
      module: moduleName,
      error,
      context: moduleContext,
      timestamp: new Date().toISOString()
    });
  }

  async emit(eventName, ...args) {
    const localEmitResult = super.emit(eventName, ...args);
    if (this.eventBus && typeof this.eventBus.emit === 'function' && this.state.status === SYSTEM_STATUS.RUNNING) {
      try {
        await this.eventBus.emit(eventName, args[0], args[1] || {});
      } catch (busError) {
        await this._handleInternalError(busError, {
          phase: 'event-bus-emit', eventName,
          argsSummary: args.map(arg => typeof arg).join(', ')
        });
      }
    }
    return localEmitResult;
  }

  /**
   * Registers a module with the system, resolving and injecting its dependencies.
   * @param {string} name - The unique name for the module.
   * @param {typeof CoreModule} ModuleClass - The class of the module to register.
   * @param {object} [moduleUserConfig={}] - Module-specific configuration provided at registration.
   * @returns {Promise<CoreModule>} The registered and configured module instance.
   */
  async register(name, ModuleClass, moduleUserConfig = {}) {
    if (!(ModuleClass && ModuleClass.prototype instanceof CoreModule)) {
      throw new ModuleError(
        ErrorCodes.MODULE.INVALID_MODULE, // Uses unprefixed
        `${name}: ModuleClass must extend CoreModule.`
      );
    }
    if (this.modules.has(name)) {
      throw new ModuleError(
        ErrorCodes.MODULE.DUPLICATE_MODULE, // Uses unprefixed
        `${name}: Module is already registered.`
      );
    }

    try {
      const moduleSpecificGlobalConfig = this.deps.config?.[name] || {};
      const finalModuleConfig = { ...moduleSpecificGlobalConfig, ...moduleUserConfig };

      const depsForModuleConstructor = {
        errorSystem: this.deps.errorSystem,
        eventBusSystem: this.deps.eventBusSystem,
        config: finalModuleConfig,
        containerSystem: this.deps.containerSystem, // Provide containerSystem
      };

      const declaredDependencies = ModuleClass.dependencies || [];
      for (const depDecl of declaredDependencies) {
        const depName = typeof depDecl === 'string' ? depDecl : depDecl.name;
        const isOptional = typeof depDecl === 'object' && depDecl.optional === true;

        // Skip if already a core dependency provided by ModuleSystem directly or 'containerSystem'
        if (['errorSystem', 'eventBusSystem', 'config', 'containerSystem'].includes(depName)) {
          continue;
        }

        if (this.modules.has(depName)) { // It's another module managed by this ModuleSystem
          depsForModuleConstructor[depName] = this.modules.get(depName);
        } else if (!ModuleSystem.dependencies.includes(depName) && !CoreModule.dependencies.includes(depName)) {
          // Not a core system dep of ModuleSystem/CoreModule, not another ModuleSystem module
          // Assume it's a non-module service to be resolved from ContainerSystem
          try {
            // Check if it's already resolved (e.g. if containerSystem passed it to ModuleSystem's deps)
            if (this.deps[depName]) {
                 depsForModuleConstructor[depName] = this.deps[depName];
            } else {
                 depsForModuleConstructor[depName] = await this.deps.containerSystem.resolve(depName);
            }
          } catch (e) {
            // Check if the error from containerSystem.resolve is because the component is not registered
            // The exact error code for "not found" from ContainerSystem might be SERVICE_UNKNOWN_COMPONENT
            // ErrorSystem wraps it as SERVICE_UNKNOWN_COMPONENT
            // CoreError subclasses prefix their codes. ServiceError uses SERVICE_ + specific code.
            const expectedNotFoundCode = `SERVICE_${ErrorCodes.SERVICE.UNKNOWN_COMPONENT}`;
            if (isOptional && e.code === expectedNotFoundCode) {
              this.deps.logger.warn(`[ModuleSystem] Optional non-module service dependency '${depName}' for module '${name}' not found in ContainerSystem. Injecting null.`);
              depsForModuleConstructor[depName] = null;
            } else if (!isOptional) {
              // Required service not found, or other resolution error
              const depError = new ModuleError(
                ErrorCodes.MODULE.DEPENDENCY_RESOLUTION_FAILED, // Uses unprefixed
                `Module '${name}': Failed to resolve required non-module service dependency '${depName}' from ContainerSystem.`,
                { moduleName: name, depName, originalError: e.message },
                { cause: e }
              );
              await this._handleInternalError(depError, { phase: 'register-dependency-resolution', failingModule: name, failingDependency: depName });
              throw depError; // Halt registration for this module
            } else { // Optional but resolution failed for another reason
                 this.deps.logger.warn(`[ModuleSystem] Error resolving optional non-module service dependency '${depName}' for module '${name}': ${e.message}. Injecting null.`);
                 depsForModuleConstructor[depName] = null;
            }
          }
        }
        // If it's an optional inter-module dependency that's not registered, it will be undefined here,
        // and the module constructor should handle deps[depName] being undefined or null.
        // Let's ensure optional missing modules are explicitly null.
        else if (isOptional && !this.modules.has(depName) && !ModuleSystem.dependencies.includes(depName) && !CoreModule.dependencies.includes(depName)) {
            this.deps.logger.info(`[ModuleSystem] Optional inter-module dependency '${depName}' for module '${name}' not found. Injecting null.`);
            depsForModuleConstructor[depName] = null;
        }
      }

      const moduleInstance = new ModuleClass(depsForModuleConstructor);
      this.modules.set(name, moduleInstance);

      moduleInstance.on('module:error', async ({ error, context }) => {
        await this.handleModuleError(name, error, context);
      });
      this.recordMetric('modulesystem.modules.registered', 1, { moduleName: name });
      await this.emit('module:registered', { name, timestamp: new Date().toISOString() });
      return moduleInstance;
    } catch (error) {
      // Catch errors from instantiation or dependency resolution step
      const regError = error instanceof ModuleError || error instanceof ValidationError ? error : new ModuleError(
        ErrorCodes.MODULE.REGISTRATION_FAILED, // Uses unprefixed
        `Failed to register module ${name}.`,
        { moduleName: name, originalMessage: error.message },
        { cause: error }
      );
      // Avoid double logging if error originated from _handleInternalError path during dep resolution
      if (!(error.context && error.context.phase === 'register-dependency-resolution' && error.context.failingModule === name) ) {
         await this._handleInternalError(regError, { phase: 'register-module-main-catch', failingModule: name });
      }
      throw regError;
    }
  }

  async unregister(name) {
    const moduleInstance = this.modules.get(name);
    if (!moduleInstance) return false;
    try {
      if (moduleInstance.state.status === SYSTEM_STATUS.RUNNING || moduleInstance.state.status === SYSTEM_STATUS.INITIALIZING) {
        await moduleInstance.shutdown();
      }
      this.stopModuleHealthMonitoring(name);
      this.modules.delete(name);
      this.state.moduleHealth.delete(name);
      this.recordMetric('modulesystem.modules.unregistered', 1, { moduleName: name });
      await this.emit('module:unregistered', { name, timestamp: new Date().toISOString() });
      return true;
    } catch (error) {
      const unregError = new ModuleError(
        ErrorCodes.MODULE.UNREGISTER_FAILED, // Uses unprefixed
        `Failed to unregister module ${name}.`,
        { moduleName: name, originalMessage: error.message },
        { cause: error }
      );
      await this._handleInternalError(unregError);
      throw unregError;
    }
  }

  async resolve(name) {
    const moduleInstance = this.modules.get(name);
    if (!moduleInstance) {
      throw new ModuleError(ErrorCodes.MODULE.NOT_FOUND, `Module ${name} is not registered.`); // Uses unprefixed
    }
    return moduleInstance;
  }

  async initialize() {
    if (this.state.status === SYSTEM_STATUS.RUNNING || this.state.status === SYSTEM_STATUS.INITIALIZING) {
      const err = new ModuleError(ErrorCodes.MODULE.ALREADY_INITIALIZED, 'ModuleSystem is already initialized or initializing.');
      await this._handleInternalError(err);
      return;
    }

    super.emit(LIFECYCLE_EVENTS.INITIALIZING, { system: 'ModuleSystem' });
    this.state.status = SYSTEM_STATUS.INITIALIZING;
    this.state.startTime = Date.now();

     if (this.deps.eventBusSystem && typeof this.deps.eventBusSystem.getEventBus === 'function') {
          try {
            this.eventBus = this.deps.eventBusSystem.getEventBus();
          } catch (e) {
             throw new ModuleError(
                ErrorCodes.MODULE.DEPENDENCY_NOT_READY, // Uses unprefixed
                `ModuleSystem: EventBusSystem is not ready during initialization.`,
                { dependency: 'eventBusSystem' },
                { cause: e }
            );
          }
      } else if (!this.eventBus) {
          throw new ModuleError(ErrorCodes.MODULE.INVALID_DEPENDENCY, `ModuleSystem: EventBus could not be obtained.`);
      }

    try {
      const initOrder = this.resolveDependencyOrder();
      for (const name of initOrder) {
        const moduleInstance = this.modules.get(name);
        if(moduleInstance) { // Module might be optional and not present if initOrder doesn't filter them
            await moduleInstance.initialize();
            await this.startModuleHealthMonitoring(name);
        }
      }

      this.state.status = SYSTEM_STATUS.RUNNING;
      this.recordMetric('modulesystem.initialized.success', 1);
      await this.emit('system:initialized', {
        timestamp: new Date().toISOString(),
        modules: Array.from(this.modules.keys()),
      });
      super.emit(LIFECYCLE_EVENTS.INITIALIZED, { system: 'ModuleSystem', timestamp: new Date().toISOString() });
      super.emit(LIFECYCLE_EVENTS.RUNNING, { system: 'ModuleSystem', timestamp: new Date().toISOString() });
    } catch (error) {
      this.state.status = SYSTEM_STATUS.ERROR;
      this.recordMetric('modulesystem.initialized.failure', 1, { error: error.code });
      await this._handleInternalError(error, { phase: 'initialization' });
      const initError = error instanceof ModuleError || error instanceof ValidationError ? error : new ModuleError(
        ErrorCodes.MODULE.INITIALIZATION_FAILED, // Uses unprefixed
        'ModuleSystem failed to initialize.',
        { originalMessage: error.message },
        { cause: error }
      );
      super.emit('system:error', { system: 'ModuleSystem', error: initError, context: {phase: 'initialization'}});
      throw initError;
    }
  }

  resolveDependencyOrder() {
    const visited = new Set();
    const visiting = new Set();
    const order = [];

    const visit = (name) => {
      if (!this.modules.has(name)) { // If an optional module was declared but not registered, don't try to visit
          const isOptionalModule = Array.from(this.modules.values()).some(modInst => 
              (modInst.constructor.dependencies || []).some(dep => typeof dep === 'object' && dep.name === name && dep.optional)
          );
          if (isOptionalModule) {
              this.deps.logger.info(`[ModuleSystem] Optional module '${name}' not registered, skipping in dependency order.`);
              return;
          }
          // If it's not an optional module and not registered, this is an issue that should ideally be caught earlier
          // or indicates an internal inconsistency.
          throw new ModuleError(ErrorCodes.MODULE.NOT_FOUND, `Module '${name}' referenced in dependency graph but not registered.`);
      }
      if (visited.has(name)) return;
      if (visiting.has(name)) {
        throw new ModuleError(
          ErrorCodes.MODULE.CIRCULAR_DEPENDENCY, // Uses unprefixed
          `Circular dependency detected for module: ${name}. Path: ${Array.from(visiting).join(' -> ')} -> ${name}`
        );
      }
      visiting.add(name);

      const moduleInstance = this.modules.get(name); // Should exist due to check above
      
      const depsDeclarations = moduleInstance.constructor.dependencies || [];
      for (const depDecl of depsDeclarations) {
        const depName = typeof depDecl === 'string' ? depDecl : depDecl.name;
        const isOptional = typeof depDecl === 'object' && depDecl.optional === true;

        // Only try to visit if 'depName' refers to another module *registered in this ModuleSystem*
        if (this.modules.has(depName)) {
          visit(depName);
        } else if (!ModuleSystem.dependencies.includes(depName) && !CoreModule.dependencies.includes(depName) && 
                   !this.deps.containerSystem.components?.has(depName) && // Check if it's a known service in container
                   !isOptional) {
          // If it's not a known core/system dep, not a registered ModuleSystem module, not known by container, AND it's required
          throw new ModuleError(
            ErrorCodes.MODULE.MISSING_DEPENDENCY, // Uses unprefixed
            `Module '${name}' requires missing dependency: '${depName}', which is not a registered module or known service.`,
            { requiringModule: name, missingModule: depName }
          );
        } else if (isOptional && !this.modules.has(depName) && 
                   !ModuleSystem.dependencies.includes(depName) && 
                   !CoreModule.dependencies.includes(depName) &&
                   !this.deps.containerSystem.components?.has(depName)
                   ) {
            // It's an optional dependency (module or service) and it's not found anywhere. Log and continue.
            this.deps.logger.warn(`[ModuleSystem] Optional dependency '${depName}' for module '${name}' not found. It will be injected as null/undefined.`);
        }
        // If it's a service to be resolved by ContainerSystem, ModuleSystem doesn't order it, ContainerSystem does.
      }
      visiting.delete(name);
      visited.add(name);
      order.push(name);
    };

    // Ensure all modules are visited, even if not depended upon by others (for their own service deps)
    for (const name of this.modules.keys()) {
      if (!visited.has(name)) {
          visit(name);
      }
    }
    return order;
  }

  async startModuleHealthMonitoring(name) {
    const moduleInstance = this.modules.get(name);
    if (!moduleInstance || typeof moduleInstance.checkHealth !== 'function') return;

    this.stopModuleHealthMonitoring(name);

    const intervalMs = moduleInstance.config?.healthCheckIntervalMs ||
                       this.deps.config?.moduleSystem?.defaultHealthCheckIntervalMs ||
                       DEFAULT_CONFIG.DEFAULT_HEALTH_CHECK_INTERVAL;
    if (moduleInstance.state.healthChecks.size === 0) { // Don't monitor if module has no health checks
        this.deps.logger.info(`[ModuleSystem] Module '${name}' has no health checks registered. Skipping periodic monitoring.`);
        return;
    }
    const intervalId = setInterval(async () => {
      try {
        const health = await moduleInstance.checkHealth();
        this.state.moduleHealth.set(name, health);
        this.recordMetric(`modulesystem.module.${name}.health.status`, health.status === SYSTEM_STATUS.HEALTHY ? 1 : 0, { status: health.status });

        if (health.status !== SYSTEM_STATUS.HEALTHY) {
          super.emit('module:unhealthy', { moduleName: name, healthStatus: health.status, healthDetails: health });
        }
      } catch (error) {
        const healthCheckError = new ModuleError(
            ErrorCodes.MODULE.HEALTH_CHECK_FAILED, // Uses unprefixed
            `Error executing health check for module ${name}.`,
            { moduleName: name, originalMessage: error.message },
            { cause: error }
        );
        this.state.moduleHealth.set(name, createStandardHealthCheckResult(SYSTEM_STATUS.UNHEALTHY, { error: 'checkHealth execution failed' }, [healthCheckError]));
        await this.handleModuleError(name, healthCheckError, { phase: 'health-monitoring' });
      }
    }, intervalMs);
    this.state.healthCheckIntervals.set(name, intervalId);
  }

  stopModuleHealthMonitoring(name) {
    if (this.state.healthCheckIntervals.has(name)) {
      clearInterval(this.state.healthCheckIntervals.get(name));
      this.state.healthCheckIntervals.delete(name);
    }
  }

  async shutdown() {
    if (this.state.status === SYSTEM_STATUS.SHUTDOWN || this.state.status === SYSTEM_STATUS.SHUTTING_DOWN) {
      return;
    }
    super.emit(LIFECYCLE_EVENTS.SHUTTING_DOWN, { system: 'ModuleSystem' });
    this.state.status = SYSTEM_STATUS.SHUTTING_DOWN;
    const shutdownStartTime = Date.now();
    for (const intervalId of this.state.healthCheckIntervals.values()) {
      clearInterval(intervalId);
    }
    this.state.healthCheckIntervals.clear();

    try {
      // Resolve order can still fail if modules were dynamically added/removed without proper checks,
      // but typically this should be stable if register/unregister are the only modifiers.
      let shutdownOrder = [];
      try {
        shutdownOrder = this.resolveDependencyOrder().reverse();
      } catch (e) {
          this.deps.logger.error(`[ModuleSystem] Could not resolve dependency order for shutdown, shutting down in registration order: ${e.message}`);
          // Fallback: shutdown in reverse registration order or just iterate this.modules
          shutdownOrder = Array.from(this.modules.keys()).reverse();
      }

      for (const name of shutdownOrder) {
        const moduleInstance = this.modules.get(name);
        if (moduleInstance) {
            try {
                await moduleInstance.shutdown();
            } catch(moduleShutdownError) {
                // Log error for this specific module, but continue shutting down others
                await this.handleModuleError(name, moduleShutdownError, { phase: 'module-shutdown' });
            }
        }
      }

      this.modules.clear();
      this.state.moduleHealth.clear();
      this.state.status = SYSTEM_STATUS.SHUTDOWN;
      this.state.startTime = null;
      const shutdownTime = Date.now() - shutdownStartTime;
      this.recordMetric('modulesystem.shutdown.time', shutdownTime);
      this.recordMetric('modulesystem.shutdown.success', 1);
      await this.emit('system:shutdown', { timestamp: new Date().toISOString() });
      super.emit(LIFECYCLE_EVENTS.SHUTDOWN, { system: 'ModuleSystem', durationMs: shutdownTime, timestamp: new Date().toISOString() });
    } catch (error) { // Catch errors from resolveDependencyOrder if it wasn't caught above, or other logic here
      this.state.status = SYSTEM_STATUS.ERROR;
      this.recordMetric('modulesystem.shutdown.failure', 1, { error: error.code });
      await this._handleInternalError(error, { phase: 'shutdown' });
      const shutdownError = error instanceof ModuleError || error instanceof ValidationError ? error : new ModuleError(
        ErrorCodes.MODULE.SHUTDOWN_FAILED, // Uses unprefixed
        'ModuleSystem failed to shutdown.',
        { originalMessage: error.message },
        { cause: error }
      );
      super.emit('system:error', { system: 'ModuleSystem', error: shutdownError, context: { phase: 'shutdown' }});
      throw shutdownError;
    }
  }

  setupDefaultHealthChecks() {
    this.registerHealthCheck('modulesystem.state', this.checkSystemState.bind(this));
    this.registerHealthCheck('modulesystem.module_overview', this.checkModuleOverviewStatus.bind(this));
    this.registerHealthCheck('modulesystem.all_modules_health', this.getSystemModulesHealth.bind(this));
  }

  recordMetric(name, value, tags = {}) {
    this.state.metrics.set(name, { value, timestamp: Date.now(), tags });
  }

  getMetrics() {
    const metrics = {};
    for (const [name, data] of this.state.metrics) {
      metrics[name] = data;
    }
    return metrics;
  }

  registerHealthCheck(name, checkFn) {
    if (typeof checkFn !== 'function') {
        const err = new ModuleError(ErrorCodes.MODULE.INVALID_HEALTH_CHECK, `ModuleSystem Health check '${name}' must be a function.`);
        this._handleInternalError(err);
        throw err;
    }
    this.state.healthChecks.set(name, checkFn);
  }

  async checkHealth() {
    const results = {};
    let overallStatus = SYSTEM_STATUS.HEALTHY;

    for (const [name, checkFn] of this.state.healthChecks) {
      try {
        const checkResult = await checkFn();
        results[name] = checkResult;
        if (checkResult.status !== SYSTEM_STATUS.HEALTHY) {
          overallStatus = (overallStatus === SYSTEM_STATUS.HEALTHY && checkResult.status === SYSTEM_STATUS.DEGRADED)
            ? SYSTEM_STATUS.DEGRADED
            : SYSTEM_STATUS.UNHEALTHY;
        }
      } catch (error) {
        results[name] = createStandardHealthCheckResult(SYSTEM_STATUS.UNHEALTHY, { error: 'Health check threw an exception' }, [error]);
        overallStatus = SYSTEM_STATUS.UNHEALTHY;
      }
    }
    return {
      name: this.constructor.name,
      version: ModuleSystem.version,
      status: overallStatus,
      timestamp: new Date().toISOString(),
      uptime: this.state.startTime ? Date.now() - this.state.startTime : 0,
      errorCount: this.state.errors.length,
      checks: results,
    };
  }

  async checkSystemState() {
    return createStandardHealthCheckResult(
      this.state.status === SYSTEM_STATUS.RUNNING ? SYSTEM_STATUS.HEALTHY : SYSTEM_STATUS.UNHEALTHY,
      {
        currentStatus: this.state.status,
        uptime: this.state.startTime ? Date.now() - this.state.startTime : 0,
        internalErrorCount: this.state.errors.length
      }
    );
  }

  async checkModuleOverviewStatus() {
    const moduleStatuses = {};
    let degradedCount = 0;
    let unhealthyCount = 0;
    for(const [name, health] of this.state.moduleHealth) {
        if (health && health.status) {
            moduleStatuses[name] = health.status;
            if(health.status === SYSTEM_STATUS.DEGRADED) degradedCount++;
            if(health.status === SYSTEM_STATUS.UNHEALTHY) unhealthyCount++;
        } else {
            moduleStatuses[name] = SYSTEM_STATUS.UNAVAILABLE || 'unavailable';
        }
    }
    const status = unhealthyCount > 0 ? SYSTEM_STATUS.UNHEALTHY : (degradedCount > 0 ? SYSTEM_STATUS.DEGRADED : SYSTEM_STATUS.HEALTHY);
    return createStandardHealthCheckResult(status, {
        registeredModuleCount: this.modules.size,
        monitoredModuleCount: this.state.moduleHealth.size,
        unhealthyModuleCount: unhealthyCount,
        degradedModuleCount: degradedCount,
        moduleStatuses
    });
  }

  async getSystemModulesHealth() {
    const moduleHealthDetails = {};
    let overallSystemStatus = SYSTEM_STATUS.HEALTHY;

    for (const [name, moduleInstance] of this.modules) {
      try {
        const health = await moduleInstance.checkHealth();
        moduleHealthDetails[name] = health;
        if (health.status !== SYSTEM_STATUS.HEALTHY) {
          overallSystemStatus = (overallSystemStatus === SYSTEM_STATUS.HEALTHY && health.status === SYSTEM_STATUS.DEGRADED)
            ? SYSTEM_STATUS.DEGRADED
            : SYSTEM_STATUS.UNHEALTHY;
        }
      } catch (error) {
        const moduleCheckError = error instanceof CoreError ? error : new ModuleError(ErrorCodes.MODULE.HEALTH_CHECK_FAILED, `Failed to check health for module ${name}`, {moduleName: name}, {cause: error});
        moduleHealthDetails[name] = createStandardHealthCheckResult(SYSTEM_STATUS.UNHEALTHY, {error: `Failed to check health for module ${name}`}, [moduleCheckError]);
        overallSystemStatus = SYSTEM_STATUS.UNHEALTHY;
      }
    }
    return createStandardHealthCheckResult(overallSystemStatus, {
        uptime: this.state.startTime ? Date.now() - this.state.startTime : 0,
        modules: moduleHealthDetails,
        moduleErrorCount: this.state.errors.filter(e => e.context?.type === 'moduleReported').length
    });
  }

  getSystemStatus() {
    return {
        name: this.constructor.name,
        version: ModuleSystem.version,
        status: this.state.status,
        uptime: this.state.startTime ? Date.now() - this.state.startTime : 0,
        initialized: this.state.status === SYSTEM_STATUS.RUNNING,
        errorCount: this.state.errors.length,
        registeredModules: this.modules.size,
        timestamp: new Date().toISOString()
    };
  }
}

/**
 * Factory function for creating a ModuleSystem instance.
 * @param {object} [deps={}] - Dependencies for the ModuleSystem.
 * @returns {ModuleSystem}
 */
export function createModuleSystem(deps = {}) {
 return new ModuleSystem(deps);
}


// src/core/module/index.js

/**
 * @file src/core/module/index.js
 * @description Barrel file for exporting module system components.
 */

import { CoreModule, createModule } from './CoreModule.js';
import { ModuleSystem, createModuleSystem } from './ModuleSystem.js';

export {
  CoreModule,
  createModule,
  ModuleSystem,
  createModuleSystem,
};

// Optional default export:
// export default {
//   CoreModule,
//   createModule,
//   ModuleSystem,
//   createModuleSystem,
// };


// src/core/module/module-system.md

# TSMIS ModuleSystem & CoreModule Documentation
Version: 2.1.0 (Refactored Core)

## Table of Contents

1.  [Introduction to the Module Architecture](#1-introduction-to-the-module-architecture)
    * [1.1. Purpose & Philosophy](#11-purpose--philosophy)
    * [1.2. Key Components: `ModuleSystem` and `CoreModule`](#12-key-components-modulesystem-and-coremodule)
2.  [Component: `CoreModule.js` - The Business Module Foundation](#2-component-coremodulejs---the-business-module-foundation)
    * [2.1. Overview & Primary Responsibility](#21-overview--primary-responsibility)
    * [2.2. Key Features Provided to Subclasses](#22-key-features-provided-to-subclasses)
    * [2.3. API Reference (`CoreModule` - for Subclass Implementation)](#23-api-reference-coremodule---for-subclass-implementation)
        * [2.3.1. Constructor & Dependencies](#231-constructor--dependencies)
        * [2.3.2. Configuration (`this.config` & `validateConfig`)](#232-configuration-thisconfig--validateconfig)
        * [2.3.3. Lifecycle Hooks (to be Overridden)](#233-lifecycle-hooks-to-be-overridden)
        * [2.3.4. Error Handling (`handleError`)](#234-error-handling-handleerror)
        * [2.3.5. Event Emission (`emit`)](#235-event-emission-emit)
        * [2.3.6. Health Monitoring (`registerHealthCheck`, `checkHealth`, `startHealthChecks`)](#236-health-monitoring-registerhealthcheck-checkhealth-starthealthchecks)
        * [2.3.7. Metrics Tracking (`recordMetric`, `getMetrics`)](#237-metrics-tracking-recordmetric-getmetrics)
        * [2.3.8. Status Reporting (`getSystemStatus`)](#238-status-reporting-getsystemstatus)
    * [2.4. State Management (`CoreModule` Specifics)](#24-state-management-coremodule-specifics)
    * [2.5. Lifecycle Management (`CoreModule` Process)](#25-lifecycle-management-coremodule-process)
    * [2.6. Static Factory (`createModule`)](#26-static-factory-createmodule)
3.  [Component: `ModuleSystem.js` - The Module Orchestrator](#3-component-modulesystemjs---the-module-orchestrator)
    * [3.1. Overview & Primary Responsibility](#31-overview--primary-responsibility)
    * [3.2. Key Functionalities & API (`ModuleSystem`)](#32-key-functionalities--api-modulesystem)
        * [3.2.1. `initialize()` & `shutdown()`](#321-initialize--shutdown)
        * [3.2.2. Module Registration & Management (`register`, `unregister`, `resolve`)](#322-module-registration--management-register-unregister-resolve)
        * [3.2.3. Dependency Resolution (`resolveDependencyOrder`)](#323-dependency-resolution-resolvedependencyorder)
        * [3.2.4. Module Error Handling (`handleModuleError`)](#324-module-error-handling-handlemoduleerror)
        * [3.2.5. Module Health Monitoring (`startModuleHealthMonitoring`, `getSystemModulesHealth`)](#325-module-health-monitoring-startmodulehealthmonitoring-getsystemmoduleshealth)
    * [3.3. Adherence to Standardization Pillars (Recap for `ModuleSystem`)](#33-adherence-to-standardization-pillars-recap-for-modulesystem)
    * [3.4. State Management (`ModuleSystem` Specifics)](#34-state-management-modulesystem-specifics)
    * [3.5. Lifecycle Management (`ModuleSystem` Process)](#35-lifecycle-management-modulesystem-process)
    * [3.6. Error Handling within `ModuleSystem`](#36-error-handling-within-modulesystem)
    * [3.7. Event Integration (`ModuleSystem` Specifics)](#37-event-integration-modulesystem-specifics)
    * [3.8. Health Monitoring (`ModuleSystem` Specifics)](#38-health-monitoring-modulesystem-specifics)
    * [3.9. Metrics Tracking (`ModuleSystem` Specifics)](#39-metrics-tracking-modulesystem-specifics)
    * [3.10. Static Factory (`createModuleSystem`)](#310-static-factory-createmodulesystem)
4.  [Integrations (Module Architecture Level)](#4-integrations-module-architecture-level)
5.  [Module Lifecycle & Management Flow Diagrams](#5-module-lifecycle--management-flow-diagrams)
6.  [Developing a New Business Module (Best Practices & Example Reference)](#6-developing-a-new-business-module-best-practices--example-reference)
7.  [Testing Strategies for Modules and ModuleSystem](#7-testing-strategies-for-modules-and-modulesystem)
8.  [Future Considerations & Potential Enhancements](#8-future-considerations--potential-enhancements)

---

## 1. Introduction to the Module Architecture

### 1.1. Purpose & Philosophy
The TSMIS Module Architecture, centered around `CoreModule` and orchestrated by `ModuleSystem`, is designed to provide a structured, consistent, and manageable way to build and integrate distinct units of business functionality. The philosophy is to promote modular design, where each module encapsulates a specific domain, can be developed somewhat independently, and integrates smoothly through standardized interfaces and lifecycle management. This aims to:
* Encapsulate Business Logic.
* Promote Reusability.
* Simplify Maintenance.
* Standardize Development by providing `CoreModule` which handles cross-cutting concerns.

### 1.2. Key Components: `ModuleSystem` and `CoreModule`
* **`CoreModule.js`**: An abstract base class that all business modules *must* extend (or its derivative `RoutableModule`). It provides standardized structure, lifecycle hooks, and utilities for errors, events, health, metrics, and configuration.
* **`ModuleSystem.js`**: The orchestrator of all `CoreModule` instances. It handles registration, instantiation with dependency injection (including core systems like `ErrorSystem`, `EventBusSystem`, `config`, `containerSystem`, and other services/modules resolved from `ContainerSystem`), ordered lifecycle management, and health monitoring aggregation.

---
## 2. Component: `CoreModule.js` - The Business Module Foundation

### 2.1. Overview & Primary Responsibility
`CoreModule` is an abstract base class for all TSMIS business logic modules. It provides a standardized framework, ensuring modules adhere to common patterns for lifecycle, configuration, error handling, communication, and observability.

### 2.2. Key Features Provided to Subclasses
Modules extending `CoreModule` gain:
* **Standardized Lifecycle Hooks**: `onValidateConfig`, `onConfigure`, `setupEventHandlers`, `onSetupHealthChecks`, `onInitialize`, `onShutdown`.
* **Dependency Injection**: Constructor `constructor(deps = {})` where `deps` are injected by `ModuleSystem`. These `deps` include core systems (`errorSystem`, `eventBusSystem`, `containerSystem`), module-specific `config`, and other services or modules listed in `static dependencies`.
* **Configuration Handling**: Access to module-specific configuration via `this.config`; `onValidateConfig` hook for validation.
* **Integrated Error Handling**: `this.handleError(error, context)` for consistent error processing (logs locally, reports to global `ErrorSystem`, emits `module:error`). Errors are instantiated using unprefixed codes from `ErrorCodes.js` with `CoreError` subclasses handling prefixing.
* **Event Communication**: Access to global `CoreEventBus` via `this.eventBus`; `async this.emit(eventName, ...args)` for local and global event emission.
* **Health Monitoring**: `registerHealthCheck()`, `checkHealth()`, `startHealthChecks()`, default state check.
* **Metrics Tracking**: `recordMetric()`, `getMetrics()`.
* **Standardized State**: `this.state` object (`status`, `startTime`, `errors`, etc.) plus `lastHealthCheck`.

### 2.3. API Reference (`CoreModule` - for Subclass Implementation)

#### 2.3.1. Constructor & Dependencies
* **`constructor(deps = {})`**: Subclasses call `super(deps)`. The `deps` object is passed by `ModuleSystem` and now directly contains resolved instances of all declared dependencies (core systems, other modules, non-module services from `ContainerSystem`), plus the module-specific `config` and `containerSystem` itself. Missing optional dependencies are injected as `null` or `undefined`.
* **`static dependencies: Array<string|object>`**: Subclasses MUST define this array. Entries list names of other components.
    * Core systems (`errorSystem`, `eventBusSystem`, `config`, `containerSystem`) are inherited from `CoreModule.dependencies`.
    * Other modules or non-module services should be listed.
    * To declare an optional dependency: `{ name: 'dependencyName', optional: true }`.
    `ModuleSystem` uses this to resolve and inject all listed dependencies.

#### 2.3.2. Configuration (`this.config` & `validateConfig`)
* **`this.config`**: Module-specific configuration object.
* **`async validateConfig(): Promise<boolean>`**: Called by `CoreModule.initialize()`. Calls `onValidateConfig`. Throws `ValidationError` (e.g., using `ErrorCodes.VALIDATION.INVALID_INPUT`) or `ModuleError` (e.g., using `ErrorCodes.MODULE.CONFIG_VALIDATION_FAILED`) on failure.

#### 2.3.3. Lifecycle Hooks (to be Overridden)
Async methods for subclasses to implement specific logic:
* `async onValidateConfig()`: Validate `this.config`.
* `async onConfigure()`: Apply validated config.
* `async setupEventHandlers()`: Subscribe to `CoreEventBus`.
* `async onSetupHealthChecks()`: Register custom health checks.
* `async onInitialize()`: Final initialization tasks.
* `async onShutdown()`: Clean up resources.

#### 2.3.4. Error Handling (`handleError`)
* **`async handleError(error: Error, context = {}): Promise<CoreModule>`**: For operational errors. Uses `safeHandleError` to report to `ErrorSystem`. When wrapping non-`CoreError`s, it uses `new ModuleError(ErrorCodes.MODULE.OPERATION_FAILED, ...)` with an unprefixed code.

#### 2.3.5. Event Emission (`emit`)
* **`async emit(eventName: string, ...args: any[]): Promise<boolean>`**: Emits locally and broadcasts via global `CoreEventBus`.

#### 2.3.6. Health Monitoring (`registerHealthCheck`, `checkHealth`, `startHealthChecks`)
* `registerHealthCheck()`: Adds custom health checks. Throws `ModuleError` with unprefixed code `ErrorCodes.MODULE.INVALID_HEALTH_CHECK` on failure.
* `checkHealth()`: Aggregates checks.
* `startHealthChecks()`: Initiates periodic self-monitoring. Reports unhealthy status using `ModuleError` with unprefixed code `ErrorCodes.MODULE.UNHEALTHY` via `this.handleError()`.

#### 2.3.7. Metrics Tracking (`recordMetric`, `getMetrics`)
Standard methods for custom and standardized metric collection.

#### 2.3.8. Status Reporting (`getSystemStatus`)
Returns a summary object of the module's current status.

### 2.4. State Management (`CoreModule` Specifics)
Implements standard `this.state`, plus `lastHealthCheck: object | null`.

### 2.5. Lifecycle Management (`CoreModule` Process)
`CoreModule.initialize()` orchestrates: `_validateDependencies`, ensuring `this.eventBus` is available, `validateConfig()` (calls `onValidateConfig`), `onConfigure()`, `setupEventHandlers()`, `setupHealthChecks()` (calls `onSetupHealthChecks`), `onInitialize()`, `startHealthChecks()`, and emits lifecycle events.
`CoreModule.shutdown()` orchestrates: clearing health interval, calling `onShutdown()`, and emitting lifecycle events.

### 2.6. Static Factory (`createModule`)
**`createModule(deps = {}): CoreModule`**: Factory for base `CoreModule`. Provides default no-op/simple mock dependencies (including a simple `EventEmitter` for `eventBusSystem.getEventBus()` and a mock `containerSystem`) primarily for testing.

---
## 3. Component: `ModuleSystem.js` - The Module Orchestrator

### 3.1. Overview & Primary Responsibility
`ModuleSystem.js` defines the `ModuleSystem` class, the central component for managing the lifecycle of all `CoreModule` instances. It handles registration, resolves inter-module dependencies, injects all declared dependencies (core systems, other modules, and non-module services from `ContainerSystem`), ensures correct initialization/shutdown order, and provides aggregated health monitoring.

### 3.2. Key Functionalities & API (`ModuleSystem`)

#### 3.2.1. `initialize()` & `shutdown()`
* **`async initialize(): Promise<void>`**: Initializes registered modules in dependency order, calling `module.initialize()` and `this.startModuleHealthMonitoring()`.
* **`async shutdown(): Promise<void>`**: Shuts down modules in reverse dependency order.

#### 3.2.2. Module Registration & Management (`register`, `unregister`, `resolve`)
* **`async register(name: string, ModuleClass: typeof CoreModule, config = {}): Promise<CoreModule>`**:
    * Instantiates `ModuleClass`.
    * **Dependency Injection**: Injects a `deps` object containing:
        * Core systems (`errorSystem`, `eventBusSystem`, `containerSystem`) inherited from `ModuleSystem`'s dependencies.
        * The module-specific `config`.
        * Other modules registered with `ModuleSystem`, based on `ModuleClass.static dependencies` (handles optional inter-module dependencies by injecting `null` if an optional module is not found).
        * Non-module services listed in `ModuleClass.static dependencies`, resolved from the injected `containerSystem` (handles optional non-module services by injecting `null` if resolution fails for an optional unknown component).
    * Throws `ModuleError` (using unprefixed codes like `INVALID_MODULE`, `DUPLICATE_MODULE`, `REGISTRATION_FAILED`, or `DEPENDENCY_RESOLUTION_FAILED`) on issues.
* **`async unregister(name: string): Promise<boolean>`**: Shuts down and removes a module. Throws `ModuleError` with unprefixed code `UNREGISTER_FAILED` on issues.
* **`async resolve(name: string): Promise<CoreModule>`**: Retrieves a registered module. Throws `ModuleError` with unprefixed code `NOT_FOUND` if not found.

#### 3.2.3. Dependency Resolution (`resolveDependencyOrder`)
* **`resolveDependencyOrder(): string[]`**: Calculates module initialization/shutdown order using topological sort based on `static dependencies` (which can declare optional inter-module dependencies). Detects and throws `ModuleError` for circular dependencies using unprefixed code `CIRCULAR_DEPENDENCY`. For missing *required* inter-module dependencies, it throws `ModuleError` with unprefixed code `MISSING_DEPENDENCY`.

#### 3.2.4. Module Error Handling (`handleModuleError`)
* **`async handleModuleError(moduleName: string, error: Error, moduleContext = {}): Promise<void>`**: Central method for processing errors reported by modules (e.g., via `module:error` event). Reports to global `ErrorSystem`.

#### 3.2.5. Module Health Monitoring (`startModuleHealthMonitoring`, `getSystemModulesHealth`)
* **`async startModuleHealthMonitoring(moduleName: string)`**: Initiates periodic health checks for a module by calling its `checkHealth()` method. Skips if module has no health checks registered.
* **`async getSystemModulesHealth(): Promise<object>`**: Aggregates health status from all managed modules by calling their `checkHealth()` on demand. (This is one of the checks for `ModuleSystem.checkHealth()`).

### 3.3. Adherence to Standardization Pillars (Recap for `ModuleSystem`)
* **State Management**: Standard `this.state`; adds `modules`, `moduleHealth`, `healthCheckIntervals` maps.
* **Lifecycle Management**: Standard `initialize`/`shutdown` orchestrating modules. Emits `LIFECYCLE_EVENTS`.
* **Error Handling**: `_handleInternalError` for own errors (throws `ModuleError` with unprefixed code `SYSTEM_ERROR`); `handleModuleError` for module issues. Reports via `safeHandleError`.
* **Health Monitoring**: `checkHealth()` for own status; aggregates module health. Default checks: `modulesystem.state`, `modulesystem.module_overview`, `modulesystem.all_modules_health`.
* **Metrics Tracking**: For lifecycle, module management, errors, health.
* **Factory Function**: `createModuleSystem(deps = {})`.

### 3.4. State Management (`ModuleSystem` Specifics)
Manages `this.modules: Map<string, CoreModule>`, `this.state.moduleHealth: Map<string, object>`, and `this.state.healthCheckIntervals: Map<string, NodeJS.Timeout>`.

### 3.5. Lifecycle Management (`ModuleSystem` Process)
* **`initialize()`**: Validates dependencies (including `containerSystem`), fetches `this.eventBus`, calls `resolveDependencyOrder()`. Initializes modules in order and starts their health monitoring.
* **`shutdown()`**: Stops health monitoring, calls `resolveDependencyOrder().reverse()`. Shuts down modules in reverse order. Clears registries.

### 3.6. Error Handling within `ModuleSystem`
* **Internal Errors**: `_handleInternalError` for orchestration issues. Throws `ModuleError` with unprefixed `SYSTEM_ERROR`.
* **Module-Related Errors**: `handleModuleError` for errors from modules.

### 3.7. Event Integration (`ModuleSystem` Specifics)
* **Emits Events**: Standard lifecycle events, plus `module:registered`, `module:unregistered`, `module:error`, `module:unhealthy` (via `this.emit`, also broadcasts to `CoreEventBus`).
* **Listens for Events**: Subscribes to each registered module instance's `module:error` event.

### 3.8. Health Monitoring (`ModuleSystem` Specifics)
`checkHealth()` for its own status. Key checks:
* **`modulesystem.state`**: Own lifecycle status, uptime, errors.
* **`modulesystem.module_overview`**: Summary of managed modules based on cached health.
* **`modulesystem.all_modules_health`**: On-demand `checkHealth()` for every module, returns detailed report.

### 3.9. Metrics Tracking (`ModuleSystem` Specifics)
Records metrics for its lifecycle, internal errors, module registrations/unregistrations, reported module errors, module health statuses.

### 3.10. Static Factory (`createModuleSystem`)
**`createModuleSystem(deps = {}): ModuleSystem`** for instantiation.

---
## 4. Integrations (Module Architecture Level)

The Module Architecture integrates with:
* **`ContainerSystem`**:
    * Manages `ModuleSystem` instance.
    * Injects core dependencies (including `ContainerSystem` itself) into `ModuleSystem`.
    * `ModuleSystem` now uses its injected `ContainerSystem` to resolve declared non-module service dependencies for `CoreModule` instances during their registration.
* **`EventBusSystem` / `CoreEventBus`**:
    * `ModuleSystem` provides `CoreEventBus` to modules for inter-communication.
    * `ModuleSystem` emits its own operational events.
* **`ErrorSystem`**:
    * Both `ModuleSystem` and `CoreModule`s report errors to `ErrorSystem`.
* **`RouterSystem` (Indirectly via `RoutableModule`)**:
    * `ModuleSystem` manages `RoutableModule`s, which emit route events consumed by `CoreRouter`.

---
## 5. Module Lifecycle & Management Flow Diagrams

**`ModuleSystem`: Module Management & High-Level Interaction**
```mermaid
graph TD
    Container["ContainerSystem"] -- "Injects self & core deps (ErrorSys, EventBusSys, Config)" --> ModSys["ModuleSystem"];
    
    ModSys -- "1. register('ModA', ModuleAClass, modAConfig)" --> ModSys;
    ModSys -- "2. register('ModB', ModuleBClass, modBConfig)" --> ModSys;

    subgraph During_Register_ModA ["ModuleSystem.register(ModuleA)"]
        direction LR
        ModSys -- "Resolves 'nonModSvcA' via ContainerSystem" --> Container;
        ModSys -- "Resolves 'ModB' (if dependency)" --> ModSysRegModules["Registered Modules (ModB)"];
        ModSys -- "Injects {errorSys, eventBusSys, config, containerSystem, nonModSvcA, ModB}" --> NewModAInst["new ModuleAClass(deps)"];
    end
    
    NewModAInst --> ModAInstance["ModuleA Instance"];
    ModSys -- "Stores instance" --> ModCache["Module Cache (this.modules)"];
    ModAInstance -- Added to --> ModCache;

    ModSys -- "Calls initialize() in order" --> ModAInstance;
    ModSys -- "Calls initialize() in order" --> ModBInstance["ModuleB Instance"];
    
    ModSys -- "Periodically calls module.checkHealth()" --> ModAInstance;
    ModSys -- "Periodically calls module.checkHealth()" --> ModBInstance;
    ModAInstance -- "Health status" --> ModHealthAgg["Aggregated Module Health (in ModSys.state)"];
    ModBInstance -- "Health status" --> ModHealthAgg;

    ModAInstance -- "Emits 'module:error' (e.g., new ModuleError(ErrorCodes.MODULE.CODE, ...))" --> ModSys;
    ModSys -- "handleModuleError()" --> ErrorSys["ErrorSystem"];
    
    ModAInstance -- "Uses this.eventBus" --> EventBus["CoreEventBus (via EventBusSystem)"];
    ModBInstance -- "Uses this.eventBus" --> EventBus;
    EventBus -- "Enables communication" --> ModAInstance;
    EventBus -- "Enables communication" --> ModBInstance;

    classDef system fill:#D6EAF8,stroke:#5DADE2,stroke-width:2px;
    classDef module fill:#E8F8F5,stroke:#76D7C4,stroke-width:2px;
    classDef process fill:#FEF9E7,stroke:#F7DC6F,stroke-width:1px;
    class ModSys, Container, ErrorSys, EventBus system;
    class ModAInstance, ModBInstance module;
    class During_Register_ModA, NewModAInst, ModCache, ModHealthAgg process;
```
**`CoreModule`: Internal Initialization Sequence (Called by ModuleSystem)**
```mermaid
sequenceDiagram
    participant ModSys as ModuleSystem
    participant MyMod as MyModule (extends CoreModule)
    participant EvBus as CoreEventBus (via MyMod.eventBus)
    participant ErrSys as ErrorSystem (via MyMod.deps.errorSystem & safeHandleError)
    participant Container as ContainerSystem (via MyMod.deps.containerSystem)

    ModSys->>MyMod: initialize()
    MyMod->>MyMod: _validateDependencies()<br>(Checks core deps like errorSystem, eventBusSystem, containerSystem, and injected modules/services)
    MyMod->>MyMod: (Re-fetch this.eventBus from this.deps.eventBusSystem.getEventBus())
    MyMod->>MyMod: validateConfig() --> calls onValidateConfig()<br>(May throw ValidationError using ErrorCodes.VALIDATION.CODE)
    MyMod->>MyMod: onConfigure()
    MyMod->>MyMod: setupEventHandlers()<br>(Subscribes to events on EvBus)
    MyMod->>MyMod: setupHealthChecks() --> calls onSetupHealthChecks()<br>(Registers health checks)
    MyMod->>MyMod: onInitialize()<br>(Module-specific init logic, may resolve further dynamic services via Container)
    MyMod->>MyMod: startHealthChecks()<br>(Starts periodic self-health check)
    Note over MyMod: Emits `module:initialized` (to global bus) and <br/>`system:initialized:mymodule` (local to module)
    MyMod-->>ModSys: Initialization Complete / Error (e.g., ModuleError using ErrorCodes.MODULE.CODE)
```

---
## 6. Developing a New Business Module (Best Practices & Example Reference)

This section provides guidance for creating new business logic modules. Modules extend `CoreModule` or `RoutableModule`.

* **Guiding Principles**: Single Responsibility, Loose Coupling, Clear Interfaces, Configuration Driven, Leverage `CoreModule` Features, Service Layer Separation, Testability.
* **Extending `CoreModule` or `RoutableModule`**: Choose based on whether HTTP endpoints are needed.
* **Example Module (`InventoryModule`)**: Detailed in the main "TSMIS Core Architecture Guide". Key aspects include:
    * **Dependency Declaration**: In `InventoryModule.js`, `static dependencies` should list `'inventoryService'` (a non-module service) and any other module or service dependencies. `ModuleSystem` will inject `inventoryService` after resolving it from `ContainerSystem`.
    * **Error Handling**: Use `new InventoryError(ErrorCodes.INVENTORY.ITEM_NOT_FOUND, ...)` where `ErrorCodes.INVENTORY.ITEM_NOT_FOUND` provides an unprefixed code like `'ITEM_NOT_FOUND'`.
    * **Service Access**: Access injected services like `this.inventoryService` directly.

---
## 7. Testing Strategies for Modules and ModuleSystem

* **`CoreModule` Subclasses**:
    * Mock all dependencies (core systems, other modules, non-module services) that `ModuleSystem` would inject.
    * Test lifecycle hooks, business methods, event emissions, error reporting (ensure `this.handleError` is called with errors using correct codes).
* **`ModuleSystem`**:
    * Test `register`/`unregister` with valid/invalid inputs.
    * Test `resolveDependencyOrder` (including optional and circular inter-module dependencies).
    * Test DI logic: ensure correct injection of core deps, inter-module deps (including `null` for missing optional), and non-module services resolved from a mock `ContainerSystem`.
    * Test `initialize`/`shutdown` by spying on module lifecycle methods.
    * Test health monitoring and error handling.

---
## 8. Future Considerations & Potential Enhancements
(Adapted from original Module System docs)
* **Dynamic Module Loading/Unloading/Hot-Reloading**.
* **Module Versioning**.
* **Module Composition Patterns**.
* **Inter-Module Contracts/Interfaces**.
* **Module Federation**.
* **Advanced Health Monitoring Aggregation**.


// src/core/router/CoreRouter.js

/**
 * @file CoreRouter.js
 * @description Core router for managing HTTP routes, adapters, and middleware.
 * It listens for route registration events and applies them via framework-specific adapters.
 */

import { EventEmitter } from 'events';
import { RouterError } from '../errors/index.js';
import { ErrorCodes } from '../errors/ErrorCodes.js';
import { SYSTEM_STATUS, LIFECYCLE_EVENTS, DEFAULT_CONFIG } from '../common/SystemConstants.js';
import { safeHandleError, createStandardHealthCheckResult } from '../common/ErrorUtils.js';

export class CoreRouter extends EventEmitter {
  static dependencies = ['errorSystem', 'eventBusSystem', 'config'];
  static version = '2.0.0';

  /**
   * Creates a new CoreRouter instance.
   * @param {object} [deps={}] - Dependencies for the CoreRouter.
   * @param {object} deps.errorSystem - The ErrorSystem instance.
   * @param {object} deps.eventBusSystem - The EventBusSystem instance for subscribing to route events.
   * @param {object} [deps.config={}] - Configuration object.
   */
  constructor(deps = {}) {
    super();
    this.deps = {
      errorSystem: deps.errorSystem,
      eventBusSystem: deps.eventBusSystem,
      config: deps.config || {},
    };

    this.routes = new Map();
    this.adapters = new Map();
    this.middleware = new Map();
    this.subscriptions = [];
    this._routesAppliedOnce = false; // Flag to track if routes have been applied to a framework

    this.state = {
      status: SYSTEM_STATUS.CREATED,
      startTime: null,
      errors: [],
      metrics: new Map(),
      healthChecks: new Map(),
    };
    this.setupDefaultHealthChecks();
  }

  /**
   * Emits a 'router:routes:changed' event if the router is running and routes have been applied once.
   * @private
   * @param {object} [details={}] - Optional details about the change (e.g., action: 'added', routeKey).
   */
  _signalRoutesChanged(details = {}) {
    if (this.state.status === SYSTEM_STATUS.RUNNING && this._routesAppliedOnce) {
      super.emit('router:routes:changed', { timestamp: new Date().toISOString(), ...details });
      this.recordMetric('corerouter.routes.changed.emitted', 1, details);
    }
  }

  async _handleInternalError(error, context = {}) {
    const errorToLog = !(error instanceof RouterError)
      ? new RouterError(ErrorCodes.ROUTER.INTERNAL_SYSTEM_ERROR, error.message, context, { cause: error })
      : error;
    this.state.errors.push({ error: errorToLog, timestamp: new Date().toISOString(), context });
    if (this.state.errors.length > (this.deps.config?.router?.maxErrorHistory || DEFAULT_CONFIG.MAX_ERROR_HISTORY)) {
      this.state.errors.shift();
    }
    this.recordMetric('corerouter.errors.internal', 1, { errorName: errorToLog.name, errorCode: errorToLog.code });
    await safeHandleError(this.deps.errorSystem, errorToLog, { source: 'CoreRouter', ...context });
  }

  async initialize() {
    if (this.state.status === SYSTEM_STATUS.RUNNING || this.state.status === SYSTEM_STATUS.INITIALIZING) {
      const err = new RouterError(ErrorCodes.ROUTER.ALREADY_INITIALIZED, 'CoreRouter is already initialized or initializing.');
      await this._handleInternalError(err, { currentStatus: this.state.status });
      return this;
    }

    super.emit(LIFECYCLE_EVENTS.INITIALIZING, { system: 'CoreRouter' });
    this.state.status = SYSTEM_STATUS.INITIALIZING;
    this.state.startTime = Date.now();

    try {
      if (!this.deps.eventBusSystem || !this.deps.eventBusSystem.getEventBus) {
        throw new RouterError(ErrorCodes.ROUTER.INVALID_DEPENDENCY, 'CoreRouter: EventBusSystem is not available or invalid for event subscriptions.');
      }
      const eventBus = this.deps.eventBusSystem.getEventBus();
      if (!eventBus || typeof eventBus.subscribe !== 'function') {
          throw new RouterError(ErrorCodes.ROUTER.INVALID_DEPENDENCY, 'CoreRouter: CoreEventBus instance is not available for event subscriptions.');
      }

      this.subscriptions.push(
        eventBus.subscribe('router.route.register', this.handleRouteRegistration.bind(this)),
        eventBus.subscribe('router.route.unregister', this.handleRouteUnregistration.bind(this)),
        eventBus.subscribe('router.routes.clear', this.handleRoutesClear.bind(this)),
        eventBus.subscribe('router.module.unregister', this.handleModuleUnregister.bind(this))
      );
      this.state.status = SYSTEM_STATUS.RUNNING;
      this.recordMetric('corerouter.initialized.success', 1, { timestamp: Date.now() });
      super.emit(LIFECYCLE_EVENTS.INITIALIZED, { system: 'CoreRouter', timestamp: new Date().toISOString() });
      super.emit(LIFECYCLE_EVENTS.RUNNING, { system: 'CoreRouter', timestamp: new Date().toISOString() });
    } catch (error) {
      this.state.status = SYSTEM_STATUS.ERROR;
      this.recordMetric('corerouter.initialized.failure', 1, { error: error.code, timestamp: Date.now() });
      await this._handleInternalError(error, { phase: 'initialization' });
      throw error instanceof RouterError ?
      error : new RouterError(
        ErrorCodes.ROUTER.INITIALIZATION_FAILED,
        'CoreRouter failed to initialize.',
        { originalMessage: error.message },
        { cause: error }
      );
    }
    return this;
  }

  registerRoute(moduleId, method, path, handler, options = {}) {
    // Not checking status === RUNNING here, as routes can be defined before router is fully live & applied.
    // The event handlers (handleRouteRegistration) will call this.
    // If called directly after init, it's okay. applyRoutes checks RUNNING state.
    if (!moduleId || typeof moduleId !== 'string') throw new RouterError(ErrorCodes.ROUTER.INVALID_MODULE_ID, 'Module ID is required for route registration.');
    if (!method || typeof method !== 'string') throw new RouterError(ErrorCodes.ROUTER.INVALID_METHOD, 'HTTP method must be a non-empty string.');
    if (!path || typeof path !== 'string') throw new RouterError(ErrorCodes.ROUTER.INVALID_PATH, 'Route path must be a non-empty string.');
    if (typeof handler !== 'function') throw new RouterError(ErrorCodes.ROUTER.INVALID_HANDLER, 'Route handler must be a function.');

    const upperMethod = method.toUpperCase();
    const routeKey = `${upperMethod}:${path}`;
    if (this.routes.has(routeKey)) {
      const existing = this.routes.get(routeKey);
      // For dynamic updates, we might want to allow overwriting or provide an updateRoute method
      // For now, maintaining conflict error for simple registerRoute
      // If allowing overwrite for dynamic updates, this should be handled differently,
      // perhaps by emitting a specific 'route:updated' event.
      // Let's assume for now registerRoute during dynamic updates should ideally be for new routes,
      // or unregister then register.
      // To enable HMR-like behavior where a route definition changes, we might need an `updateRoute`
      // or make `registerRoute` overwrite if an `allowOverwrite` option is passed or if `_routesAppliedOnce` is true.
      // For now, we'll emit 'changed' and the adapter has to deal with the full new list.
      this.deps.logger.warn(`[CoreRouter] Route conflict: ${routeKey} already registered by module '${existing.moduleId}'. Overwriting with registration from '${moduleId}'.`);
      // To allow updates, we remove the conflict throw if routes have been applied.
      // Or, better, require an unregister first or an explicit update.
      // Let's assume for now, if _routesAppliedOnce, we allow re-registration to mean update.
      // The adapter's refreshRoutes will get the full new list.
    }

    this.routes.set(routeKey, { moduleId, method: upperMethod, path, handler, options: options || {} });
    this.recordMetric('corerouter.routes.registered', 1, { moduleId, method: upperMethod });
    super.emit('route:registered', { moduleId, method: upperMethod, path, timestamp: new Date().toISOString() });
    this._signalRoutesChanged({ action: 'registered', routeKey });
    return this;
  }

  registerAdapter(name, adapter) {
    if (!name || typeof name !== 'string') throw new RouterError(ErrorCodes.ROUTER.INVALID_ADAPTER_NAME, 'Adapter name must be a non-empty string.');
    if (!adapter || typeof adapter.applyRoutes !== 'function' || typeof adapter.refreshRoutes !== 'function') { // Added check for refreshRoutes
        throw new RouterError(ErrorCodes.ROUTER.INVALID_ADAPTER, `Adapter '${name}' must implement applyRoutes and refreshRoutes methods.`);
    }
    this.adapters.set(name, adapter);
    this.recordMetric('corerouter.adapters.registered', 1, { adapterName: name });
    super.emit('adapter:registered', { name, timestamp: new Date().toISOString() });
    return this;
  }

  registerMiddleware(name, handler, options = {}) {
    if (!name || typeof name !== 'string') throw new RouterError(ErrorCodes.ROUTER.INVALID_MIDDLEWARE_NAME, 'Middleware name must be a non-empty string.');
    if (typeof handler !== 'function') throw new RouterError(ErrorCodes.ROUTER.INVALID_MIDDLEWARE, `Middleware handler for '${name}' must be a function.`);
    this.middleware.set(name, { handler, options: options || {}, order: options?.order || 100 });
    this.recordMetric('corerouter.middleware.registered', 1, { middlewareName: name });
    super.emit('middleware:registered', { name, timestamp: new Date().toISOString() });
    // Note: Changes to middleware might also require routes to be refreshed if middleware is resolved at apply/refresh time.
    // For simplicity, we assume middleware changes also trigger a manual refresh request or occur before applyRoutes.
    // Or, _signalRoutesChanged could be called here too if dynamic middleware updates are desired.
    return this;
  }

  getMiddlewareForRoute(route) {
    const routeSpecificMiddlewareNames = route.options?.middleware || [];
    const applicableMiddleware = [];
    for (const [name, midDef] of this.middleware) {
      if (this._shouldApplyMiddleware(name, midDef, route)) {
        applicableMiddleware.push({ name, handler: midDef.handler, order: midDef.order });
      }
    }
    for (const name of routeSpecificMiddlewareNames) {
      if (this.middleware.has(name)) {
        const midDef = this.middleware.get(name);
        if (!applicableMiddleware.some(m => m.name === name)) {
            applicableMiddleware.push({ name, handler: midDef.handler, order: midDef.order });
        }
      } else {
        this.deps.logger?.warn(`[CoreRouter] Middleware '${name}' requested by route ${route.method} ${route.path} not found.`);
      }
    }
    return applicableMiddleware.sort((a, b) => a.order - b.order);
  }

  _shouldApplyMiddleware(middlewareName, middlewareDef, route) {
    const { paths, methods } = middlewareDef.options || {};
    if (!paths && !methods) return true;
    let matchesPath = !paths;
    if (paths) {
      matchesPath = paths.some(pattern => this._pathMatchesPattern(route.path, pattern));
    }
    if (!matchesPath) return false;
    let matchesMethod = !methods;
    if (methods) {
      matchesMethod = methods.map(m => m.toUpperCase()).includes(route.method.toUpperCase());
    }
    return matchesMethod;
  }

  _pathMatchesPattern(path, pattern) {
    if (pattern.endsWith('*')) {
      const prefix = pattern.slice(0, -1);
      return path.startsWith(prefix);
    }
    return path === pattern;
  }

  async applyRoutes(framework, adapterName) {
    if (this.state.status !== SYSTEM_STATUS.RUNNING) throw new RouterError(ErrorCodes.ROUTER.NOT_INITIALIZED, 'CoreRouter is not running.');
    if (!framework) throw new RouterError(ErrorCodes.ROUTER.INVALID_FRAMEWORK, 'Framework instance is required to apply routes.');
    if (!adapterName || !this.adapters.has(adapterName)) throw new RouterError(ErrorCodes.ROUTER.ADAPTER_NOT_FOUND, `Adapter '${adapterName}' not found.`);

    try {
      const adapter = this.adapters.get(adapterName);
      const routesWithMiddleware = Array.from(this.routes.values()).map(route => ({
          ...route,
          resolvedMiddleware: this.getMiddlewareForRoute(route).map(m => m.handler)
      }));
      const result = await adapter.applyRoutes(framework, routesWithMiddleware);
      this._routesAppliedOnce = true; // Set flag after successful first application
      this.recordMetric('corerouter.routes.applied', routesWithMiddleware.length, { adapter: adapterName });
      super.emit('routes:applied', { adapter: adapterName, count: routesWithMiddleware.length, timestamp: new Date().toISOString() });
      return result;
    } catch (error) {
      const applyError = new RouterError(
        ErrorCodes.ROUTER.ROUTES_APPLICATION_FAILED,
        `Failed to apply routes using adapter '${adapterName}'.`,
        { adapter: adapterName, originalMessage: error.message },
        { cause: error }
      );
      await this._handleInternalError(applyError, { phase: 'applyRoutes', adapterName });
      throw applyError;
    }
  }

  getRoutes() { return Array.from(this.routes.values()); }
  getRoute(method, path) { return this.routes.get(`${method.toUpperCase()}:${path}`) || null; }
  getModuleRoutes(moduleId) { return Array.from(this.routes.values()).filter(r => r.moduleId === moduleId); }

  unregisterRoute(method, path) {
    const routeKey = `${method.toUpperCase()}:${path}`;
    const route = this.routes.get(routeKey);
    if (!route) return false;

    const unregistered = this.routes.delete(routeKey);
    if (unregistered) {
      this.recordMetric('corerouter.routes.unregistered', 1, { moduleId: route.moduleId, method: route.method });
      super.emit('route:unregistered', { moduleId: route.moduleId, method: route.method, path, timestamp: new Date().toISOString() });
      this._signalRoutesChanged({ action: 'unregistered', routeKey });
    }
    return unregistered;
  }

  unregisterModuleRoutes(moduleId) {
    const moduleRoutes = this.getModuleRoutes(moduleId);
    if (moduleRoutes.length === 0) return 0;

    let count = 0;
    for (const route of moduleRoutes) {
      if (this.unregisterRoute(route.method, route.path)) { // unregisterRoute will signal change for each
        count++;
      }
    }
    if (count > 0) {
        this.recordMetric('corerouter.module.routes.unregistered', count, { moduleId });
        // _signalRoutesChanged is called by individual unregisterRoute calls
    }
    return count;
  }

  clearRoutes() {
    const count = this.routes.size;
    if (count === 0) return this;

    this.routes.clear();
    this.recordMetric('corerouter.routes.cleared', count);
    super.emit('routes:cleared', { count, timestamp: new Date().toISOString() });
    this._signalRoutesChanged({ action: 'cleared_all' });
    return this;
  }

  registerVersionedRoute(moduleId, version, method, path, handler, options = {}) {
    const basePath = path.startsWith('/') ? path : `/${path}`;
    const versionedPath = `/api/v${version}${basePath}`;
    return this.registerRoute(moduleId, method, versionedPath, handler, { ...options, apiVersion: version });
  }

  generateOpenApiDoc(info = {}) {
    // ... (generateOpenApiDoc implementation remains the same) ...
    const paths = {};
    const tags = new Set();
    for (const route of this.getRoutes()) {
      const { method, path: routePath, options } = route;
      if (options.tags && Array.isArray(options.tags)) options.tags.forEach(tag => tags.add(tag));
      const pathParams = [];
      const openApiPath = routePath.replace(/:([^/]+)/g, (_, paramName) => {
        pathParams.push({ name: paramName, in: 'path', required: true, schema: { type: 'string' } });
        return `{${paramName}}`;
      });
      if (!paths[openApiPath]) paths[openApiPath] = {};
      paths[openApiPath][method.toLowerCase()] = {
        tags: options.tags || [],
        summary: options.summary || '',
        description: options.description || '',
        parameters: [
          ...pathParams,
          ...(options.schema?.parameters || []),
        ],
        requestBody: options.schema?.body ? { content: { 'application/json': { schema: options.schema.body } } } : undefined,
        responses: options.schema?.responses || { '200': { description: 'Success' } },
        security: options.auth ? [{ bearerAuth: [] }] : [],
      };
    }
    return {
      openapi: '3.0.0',
      info: {
        title: info.title || 'API Documentation',
        version: info.version || CoreRouter.version,
        description: info.description || '',
      },
      tags: Array.from(tags).map(tag => ({ name: tag, description: '' })),
      paths,
      components: {
        securitySchemes: {
          bearerAuth: { type: 'http', scheme: 'bearer', bearerFormat: 'JWT' },
        },
        schemas: info.components?.schemas || {}
      },
    };
  }


  // --- Event Handlers ---
  async handleRouteRegistration(event) {
    const routeData = event.data || event;
    try {
      const { moduleId, method, path, handler, options } = routeData;
      // registerRoute will call _signalRoutesChanged if applicable
      this.registerRoute(moduleId, method, path, handler, options || {});
    } catch (error) {
      // error from registerRoute is already a RouterError and logged by _handleInternalError if it's an internal issue
      // If registerRoute throws due to conflict before _routesAppliedOnce, it's a setup error
      // If it's after, and we change registerRoute to allow overwrite, this path might change.
      // For now, _handleInternalError in registerRoute handles its own direct errors.
      // This handler is for errors *during the event processing itself*, not from registerRoute's logic.
      await this._handleInternalError(error, { eventName: event.name, receivedData: routeData, comment: "Error during handleRouteRegistration's call to registerRoute" });
    }
  }

  async handleRouteUnregistration(event) {
    const routeData = event.data || event;
    try {
        const { method, path } = routeData;
        // unregisterRoute will call _signalRoutesChanged
        this.unregisterRoute(method, path);
    } catch (error) {
        await this._handleInternalError(error, { eventName: event.name, receivedData: routeData });
    }
  }

  async handleRoutesClear(event) {
    try {
      // clearRoutes will call _signalRoutesChanged
      this.clearRoutes();
    } catch (error) {
      await this._handleInternalError(error, { eventName: event.name });
    }
  }

  async handleModuleUnregister(event) {
    const eventData = event.data || event;
    try {
      const { moduleId } = eventData;
      if (moduleId) {
        // unregisterModuleRoutes calls unregisterRoute, which calls _signalRoutesChanged
        this.unregisterModuleRoutes(moduleId);
      } else {
          throw new RouterError(ErrorCodes.ROUTER.INVALID_PAYLOAD, "moduleId missing in router.module.unregister event payload.");
      }
    } catch (error) {
      await this._handleInternalError(error, { eventName: event.name, receivedData: eventData });
    }
  }

  async shutdown() {
    if (this.state.status === SYSTEM_STATUS.SHUTDOWN || this.state.status === SYSTEM_STATUS.SHUTTING_DOWN) {
      return;
    }
    super.emit(LIFECYCLE_EVENTS.SHUTTING_DOWN, { system: 'CoreRouter' });
    this.state.status = SYSTEM_STATUS.SHUTTING_DOWN;
    const shutdownStartTime = Date.now();
    this._routesAppliedOnce = false; // Reset this flag
    try {
      if (this.deps.eventBusSystem && this.deps.eventBusSystem.getEventBus) {
        const eventBus = this.deps.eventBusSystem.getEventBus();
        if (eventBus && typeof eventBus.unsubscribe === 'function') {
          for (const subId of this.subscriptions) {
            eventBus.unsubscribe(subId);
          }
        }
      }
      this.subscriptions = [];
      this.routes.clear();
      this.adapters.clear();
      this.middleware.clear();

      this.state.status = SYSTEM_STATUS.SHUTDOWN;
      this.state.startTime = null;
      const shutdownTime = Date.now() - shutdownStartTime;
      this.recordMetric('corerouter.shutdown.time', shutdownTime);
      this.recordMetric('corerouter.shutdown.success', 1, { timestamp: Date.now() });
      super.emit(LIFECYCLE_EVENTS.SHUTDOWN, { system: 'CoreRouter', durationMs: shutdownTime, timestamp: new Date().toISOString() });

    } catch (error) {
      this.state.status = SYSTEM_STATUS.ERROR;
      this.recordMetric('corerouter.shutdown.failure', 1, { error: error.code, timestamp: Date.now() });
      await this._handleInternalError(error, { phase: 'shutdown' });
    }
  }

  // ... (Health Checks & Metrics methods remain the same as previously verified) ...
  setupDefaultHealthChecks() {
    this.registerHealthCheck('corerouter.state', this.checkSystemState.bind(this));
    this.registerHealthCheck('corerouter.routes', this.checkRouteStatus.bind(this));
    this.registerHealthCheck('corerouter.adapters', this.checkAdapterStatus.bind(this));
    this.registerHealthCheck('corerouter.middleware', this.checkMiddlewareStatus.bind(this));
  }

  recordMetric(name, value, tags = {}) {
    this.state.metrics.set(name, { value, timestamp: Date.now(), tags });
  }

  getMetrics() {
    const metrics = {};
    for (const [name, data] of this.state.metrics) {
      metrics[name] = data;
    }
    return metrics;
  }

  registerHealthCheck(name, checkFn) {
    if (typeof checkFn !== 'function') {
        const err = new RouterError(ErrorCodes.ROUTER.INVALID_HANDLER, `CoreRouter Health check '${name}' must be a function.`);
        this._handleInternalError(err);
        throw err;
    }
    this.state.healthChecks.set(name, checkFn);
  }

  async checkHealth() {
    const results = {};
    let overallStatus = SYSTEM_STATUS.HEALTHY;
    for (const [name, checkFn] of this.state.healthChecks) {
      try {
        const checkResult = await checkFn();
        results[name] = checkResult;
        if (checkResult.status !== SYSTEM_STATUS.HEALTHY) {
          overallStatus = (overallStatus === SYSTEM_STATUS.HEALTHY && checkResult.status === SYSTEM_STATUS.DEGRADED)
            ? SYSTEM_STATUS.DEGRADED
            : SYSTEM_STATUS.UNHEALTHY;
        }
      } catch (error) {
        results[name] = createStandardHealthCheckResult(SYSTEM_STATUS.UNHEALTHY, { error: 'Health check threw an exception' }, [error]);
        overallStatus = SYSTEM_STATUS.UNHEALTHY;
      }
    }
    return {
      name: this.constructor.name,
      version: CoreRouter.version,
      status: overallStatus,
      timestamp: new Date().toISOString(),
      uptime: this.state.startTime ? Date.now() - this.state.startTime : 0,
      errorCount: this.state.errors.length,
      checks: results,
    };
  }

  async checkSystemState() {
    return createStandardHealthCheckResult(
      this.state.status === SYSTEM_STATUS.RUNNING ? SYSTEM_STATUS.HEALTHY : SYSTEM_STATUS.UNHEALTHY,
      {
        currentStatus: this.state.status,
        uptime: this.state.startTime ? Date.now() - this.state.startTime : 0,
        internalErrorCount: this.state.errors.length
      }
    );
  }

  async checkRouteStatus() {
    const routes = Array.from(this.routes.values());
    const routesByMethod = {};
    for (const route of routes) {
      routesByMethod[route.method] = (routesByMethod[route.method] || 0) + 1;
    }
    return createStandardHealthCheckResult(SYSTEM_STATUS.HEALTHY, {
      count: routes.length,
      byMethod: routesByMethod,
    });
  }

  async checkAdapterStatus() {
    return createStandardHealthCheckResult(SYSTEM_STATUS.HEALTHY, {
      count: this.adapters.size,
      adapterNames: Array.from(this.adapters.keys()),
    });
  }

  async checkMiddlewareStatus() {
    return createStandardHealthCheckResult(SYSTEM_STATUS.HEALTHY, {
      count: this.middleware.size,
      middlewareNames: Array.from(this.middleware.keys()),
    });
  }

  getSystemStatus() {
    return {
        name: this.constructor.name,
        version: CoreRouter.version,
        status: this.state.status,
        uptime: this.state.startTime ? Date.now() - this.state.startTime : 0,
        initialized: this.state.status === SYSTEM_STATUS.RUNNING,
        errorCount: this.state.errors.length,
        routeCount: this.routes.size,
        adapterCount: this.adapters.size,
        middlewareCount: this.middleware.size,
        timestamp: new Date().toISOString()
    };
  }
}


// src/core/router/RoutableModule.js

/**
 * @file RoutableModule.js
 * @description Extends CoreModule to provide route registration capabilities for modules.
 * Routes are declared by the module and emitted as events for the RouterSystem to process.
 */

import { CoreModule } from '../module/CoreModule.js';
import { RouterError, ModuleError } from '../errors/index.js'; // Combined import
import { ErrorCodes } from '../errors/ErrorCodes.js';
import { SYSTEM_STATUS } from '../common/SystemConstants.js'; // For checking module state

export class RoutableModule extends CoreModule {
  // Inherits static dependencies and version from CoreModule.
  // If RoutableModule had specific additional dependencies, they'd be added here.
  // static dependencies = [...CoreModule.dependencies, 'anotherDependency'];
  static version = '2.0.0'; // Override CoreModule's version if specific to Routable features

  /**
   * Creates a new RoutableModule instance.
   * @param {object} [deps={}] - Dependencies for the RoutableModule.
   */
  constructor(deps = {}) {
    super(deps); //
    this.routes = []; // Stores route definitions before the module (and router) is initialized
                     // or for immediate registration if already initialized.
    // Health check for routes will be registered in onInitialize or onSetupHealthChecks
  }

  /**
   * Registers an HTTP route.
   * If the module is already initialized and running, it attempts to register immediately
   * by emitting an event.
   * Otherwise, stores the route for batch registration during onInitialize.
   *
   * @param {string} method - HTTP method (e.g., 'GET', 'POST').
   * @param {string} path - Route path (e.g., '/users/:id').
   * @param {Function} handler - The handler function for this route.
   * @param {object} [options={}] - Route-specific options (e.g., schema, middleware, auth requirements).
   * @returns {RoutableModule} This instance for chaining.
   */
  registerRoute(method, path, handler, options = {}) { //
    if (!method || typeof method !== 'string' || !method.trim()) {
      throw new RouterError(ErrorCodes.ROUTER.INVALID_METHOD, `${this.constructor.name}: Route method must be a non-empty string.`); // Uses unprefixed
    }
    if (!path || typeof path !== 'string' || !path.trim()) {
      throw new RouterError(ErrorCodes.ROUTER.INVALID_PATH, `${this.constructor.name}: Route path must be a non-empty string.`); // Uses unprefixed
    }
    if (typeof handler !== 'function') {
      throw new RouterError(ErrorCodes.ROUTER.INVALID_HANDLER, `${this.constructor.name}: Route handler for ${method} ${path} must be a function.`); // Uses unprefixed
    }

    const routeDefinition = {
      method: method.toUpperCase(), //
      path, //
      handler: handler.bind(this), // Ensure 'this' context is the module instance //
      options: options || {}, //
    };

    this.routes.push(routeDefinition); //
    this.recordMetric(`${this.constructor.name.toLowerCase()}.routes.defined`, 1, { method: routeDefinition.method, path }); //
    if (this.state.status === SYSTEM_STATUS.RUNNING && this.eventBus) { //
      this._emitRouteRegistration(routeDefinition)
          .catch(error => {
              this.handleError(new RouterError(
                  ErrorCodes.ROUTER.ROUTE_REGISTRATION_FAILED, // Uses unprefixed
                  `${this.constructor.name}: Failed to emit immediate registration for ${routeDefinition.method} ${routeDefinition.path}.`,
                  { method: routeDefinition.method, path: routeDefinition.path, originalMessage: error.message },
                  { cause: error }
              ), { phase: 'immediate-route-registration' }); //
          });
    }
    return this; //
  }

  /**
   * Helper to emit the route registration event.
   * @private
   */
  async _emitRouteRegistration(routeDefinition) {
    if (!this.eventBus) {
        this.deps.logger.warn(`[${this.constructor.name}] EventBus not available for emitting route: ${routeDefinition.method} ${routeDefinition.path}. It will be registered during batch registration.`); //
        return; //
    }
    await this.eventBus.emit('router.route.register', { //
      moduleId: this.constructor.name, //
      ...routeDefinition, // Spreads method, path, handler, options
    }); //
    this.recordMetric(`${this.constructor.name.toLowerCase()}.routes.emitted_for_registration`, 1, { method: routeDefinition.method, path: routeDefinition.path }); //
  }


  /**
   * Registers a versioned API route. Prepends `/api/v<version>` to the path.
   * @param {string|number} version - The API version number (e.g., 1, '2.1').
   * @param {string} method - HTTP method.
   * @param {string} path - Route path (e.g., '/users').
   * @param {Function} handler - Route handler.
   * @param {object} [options={}] - Route options.
   * @returns {RoutableModule} This instance.
   */
  registerVersionedRoute(version, method, path, handler, options = {}) { //
    if (!version || (typeof version !== 'string' && typeof version !== 'number')) {
        throw new RouterError(ErrorCodes.ROUTER.INVALID_API_VERSION, `${this.constructor.name}: API version must be a non-empty string or number.`); // Uses unprefixed
    }
    const basePath = path.startsWith('/') ? path : `/${path}`; //
    const versionedPath = `/api/v${version}${basePath}`; //
    return this.registerRoute(method, versionedPath, handler, { //
      ...options, //
      apiVersion: version, // Add version to options for RouterSystem/Adapter use
    }); //
  }

  /**
   * Emits events for all defined routes to be registered by the RouterSystem.
   * Typically called during the module's `onInitialize` lifecycle hook.
   * @returns {Promise<void>}
   */
  async registerAllRoutes() { //
    if (!this.eventBus) {
      await this.handleError(new ModuleError(
          ErrorCodes.MODULE.DEPENDENCY_NOT_READY, // Uses unprefixed
          `${this.constructor.name}: EventBus is not available for registering routes. Ensure EventBusSystem is initialized.`,
          { moduleName: this.constructor.name }
      ), { phase: 'registerAllRoutes' }); //
      return; //
    }

    let successfulEmissions = 0; //
    for (const route of this.routes) { //
      try {
        await this._emitRouteRegistration(route); //
        successfulEmissions++; //
      } catch (error) {
        await this.handleError(new RouterError(
            ErrorCodes.ROUTER.ROUTE_REGISTRATION_FAILED, // Uses unprefixed
            `${this.constructor.name}: Failed to emit registration for ${route.method} ${route.path} during batch.`,
            { method: route.method, path: route.path, originalMessage: error.message },
            { cause: error }
        ), { phase: 'batch-route-registration' }); //
      }
    }
    this.recordMetric(`${this.constructor.name.toLowerCase()}.routes.batch_emitted`, successfulEmissions, { totalDefined: this.routes.length }); //
  }

  /**
   * Unregisters a previously registered route by emitting an event.
   * @param {string} method - HTTP method.
   * @param {string} path - Route path.
   * @returns {Promise<boolean>} True if the unregistration event was emitted, false if route not found locally or emit failed.
   */
  async unregisterRoute(method, path) { //
    const upperMethod = method.toUpperCase(); //
    const index = this.routes.findIndex(r => r.method === upperMethod && r.path === path); //

    if (index === -1) { //
      this.deps.logger?.warn(`[${this.constructor.name}] Route ${upperMethod} ${path} not found locally for unregistration.`); //
      return false; //
    }

    this.routes.splice(index, 1); //
    this.recordMetric(`${this.constructor.name.toLowerCase()}.routes.removed_local`, 1, { method: upperMethod, path }); //
    if (this.state.status === SYSTEM_STATUS.RUNNING && this.eventBus) { //
      try {
        await this.eventBus.emit('router.route.unregister', { //
          moduleId: this.constructor.name, //
          method: upperMethod, //
          path, //
        }); //
        this.recordMetric(`${this.constructor.name.toLowerCase()}.routes.emitted_for_unregistration`, 1, { method: upperMethod, path }); //
        return true; //
      } catch (error) {
         await this.handleError(new RouterError(
            ErrorCodes.ROUTER.ROUTE_UNREGISTRATION_FAILED, // Uses unprefixed
            `${this.constructor.name}: Failed to emit unregistration for ${upperMethod} ${path}.`,
            { method: upperMethod, path: path, originalMessage: error.message },
            { cause: error }
        ), { phase: 'route-unregistration' }); //
        return false; // Emission failed //
      }
    }
    return true; // Removed locally, but not emitted if module not running or no eventBus //
  }

  // --- CoreModule Lifecycle Overrides ---

  /**
   * Registers a health check for the routes defined by this module.
   * This is called by CoreModule's `setupHealthChecks`.
   */
  async onSetupHealthChecks() { //
    await super.onSetupHealthChecks(); //
    this.registerHealthCheck(`${this.constructor.name.toLowerCase()}.routes`, async () => { //
      return createStandardHealthCheckResult(SYSTEM_STATUS.HEALTHY, { //
        count: this.routes.length, //
        paths: this.routes.map(r => `${r.method} ${r.path}`), //
      });
    });
  }

  /**
   * Hook into CoreModule's initialization to register all defined routes.
   */
  async onInitialize() { //
    await super.onInitialize(); //
    await this.registerAllRoutes(); //
  }

  /**
   * Hook into CoreModule's shutdown to signal unregistration of all this module's routes.
   */
  async onShutdown() { //
    if (this.state.status === SYSTEM_STATUS.RUNNING && this.eventBus) { // Check if it was running
      try {
        await this.eventBus.emit('router.module.unregister', { //
          moduleId: this.constructor.name, //
        }); //
        this.recordMetric(`${this.constructor.name.toLowerCase()}.routes.all_emitted_for_unregistration`, 1); //
      } catch (error) {
        await this.handleError(new RouterError(
            ErrorCodes.ROUTER.MODULE_UNREGISTRATION_FAILED, // Uses unprefixed
            `${this.constructor.name}: Failed to emit module route unregistration event.`,
            { moduleId: this.constructor.name, originalMessage: error.message },
            { cause: error }
        ), { phase: 'module-routes-unregistration' }); //
      }
    }
    this.routes = []; //
    await super.onShutdown(); //
  }
}

/**
 * Factory function for creating a RoutableModule instance.
 * @param {object} [deps={}] - Dependencies for the RoutableModule.
 * @returns {RoutableModule}
 */
export function createRoutableModule(deps = {}) { //
  return new RoutableModule(deps); //
}


// src/core/router/RouterSystem.js

/**
 * @file RouterSystem.js
 * @description System for centralized route management, managing CoreRouter and its integrations.
 */

import { EventEmitter } from "events";
import { CoreRouter } from "./CoreRouter.js";
import { RouterError } from "../errors/index.js";
import { ErrorCodes } from "../errors/ErrorCodes.js";
import { SYSTEM_STATUS, LIFECYCLE_EVENTS, DEFAULT_CONFIG } from '../common/SystemConstants.js';
import { safeHandleError, createStandardHealthCheckResult } from '../common/ErrorUtils.js';

export class RouterSystem extends EventEmitter {
  static dependencies = ["errorSystem", "eventBusSystem", "config"];
  static version = "2.0.0";

  /**
   * Creates a new RouterSystem instance.
   * @param {object} [deps={}] - Dependencies for the RouterSystem.
   * @param {object} deps.errorSystem - The ErrorSystem instance.
   * @param {object} deps.eventBusSystem - The EventBusSystem instance.
   * @param {object} [deps.config={}] - Global application configuration.
   */
  constructor(deps = {}) {
    super();
    this.deps = {
      errorSystem: deps.errorSystem,
      eventBusSystem: deps.eventBusSystem,
      config: deps.config || {},
    };

    this.router = null; // Will be an instance of CoreRouter
    this._activeAdapterName = null; // Stores the name of the adapter used in the last applyRoutes call
    this._activeFrameworkInstance = null; // Stores the framework instance from the last applyRoutes call

    this.state = {
      status: SYSTEM_STATUS.CREATED,
      startTime: null,
      errors: [],
      metrics: new Map(),
      healthChecks: new Map(),
    };

    this._validateDependencies();
    this.setupDefaultHealthChecks();
  }

  /** @private */
  _validateDependencies() {
    const missing = RouterSystem.dependencies.filter(dep => !this.deps[dep]);
    if (missing.length > 0) {
      throw new RouterError(ErrorCodes.ROUTER.MISSING_DEPENDENCIES, `RouterSystem: Missing required dependencies: ${missing.join(", ")}`, { missingDeps: missing });
    }
    if (!this.deps.eventBusSystem || typeof this.deps.eventBusSystem.getEventBus !== "function") {
      throw new RouterError(ErrorCodes.ROUTER.INVALID_DEPENDENCY, "RouterSystem: EventBusSystem is invalid.", { dependency: "eventBusSystem" });
    }
    if (!this.deps.errorSystem || typeof this.deps.errorSystem.handleError !== "function") {
      throw new RouterError(ErrorCodes.ROUTER.INVALID_DEPENDENCY, "RouterSystem: ErrorSystem is invalid.", { dependency: "errorSystem" });
    }
  }

  /** @private */
  async _handleInternalError(error, context = {}) {
    const errorToLog = !(error instanceof RouterError)
      ? new RouterError(ErrorCodes.ROUTER.SYSTEM_INTERNAL_ERROR, error.message, context, { cause: error })
      : error;
    this.state.errors.push({ error: errorToLog, timestamp: new Date().toISOString(), context });
    if (this.state.errors.length > (this.deps.config?.routerSystem?.maxErrorHistory || DEFAULT_CONFIG.MAX_ERROR_HISTORY)) {
      this.state.errors.shift();
    }
    this.recordMetric('routersystem.errors.internal', 1, { errorName: errorToLog.name, errorCode: errorToLog.code });
    await safeHandleError(this.deps.errorSystem, errorToLog, { source: 'RouterSystem', ...context });
  }

  /**
   * Initializes the RouterSystem and the underlying CoreRouter.
   * @returns {Promise<RouterSystem>} This instance.
   */
  async initialize() {
    if (this.state.status === SYSTEM_STATUS.RUNNING || this.state.status === SYSTEM_STATUS.INITIALIZING) {
      const err = new RouterError(ErrorCodes.ROUTER.ALREADY_INITIALIZED, "RouterSystem is already initialized or initializing.", { state: this.state.status });
      await this._handleInternalError(err);
      return this;
    }

    super.emit(LIFECYCLE_EVENTS.INITIALIZING, { system: 'RouterSystem' });
    this.state.status = SYSTEM_STATUS.INITIALIZING;
    this.state.startTime = Date.now();

    try {
      this.router = new CoreRouter(this.deps);
      this._setupEventForwardingAndDynamicRefresh(); // UPDATED method name
      await this.router.initialize();

      this.state.status = SYSTEM_STATUS.RUNNING;
      this.recordMetric('routersystem.initialized.success', 1);
      super.emit(LIFECYCLE_EVENTS.INITIALIZED, { system: 'RouterSystem', timestamp: new Date().toISOString() });
      super.emit(LIFECYCLE_EVENTS.RUNNING, { system: 'RouterSystem', timestamp: new Date().toISOString() });

    } catch (error) {
      this.state.status = SYSTEM_STATUS.ERROR;
      this.recordMetric('routersystem.initialized.failure', 1, { error: error.code });
      await this._handleInternalError(error, { phase: 'initialization' });
      throw error instanceof RouterError ?
      error : new RouterError(
        ErrorCodes.ROUTER.INITIALIZATION_FAILED,
        "RouterSystem failed to initialize.",
        { originalMessage: error.message },
        { cause: error }
      );
    }
    return this;
  }

  /** * Sets up event forwarding from CoreRouter to RouterSystem and
   * listens for route changes to trigger dynamic refresh.
   * @private 
   */
  _setupEventForwardingAndDynamicRefresh() {
    if (!this.router) return;

    const forward = (eventName, systemEventName) => {
      this.router.on(eventName, (eventData) => {
        this.emit(systemEventName, eventData);
        this.emit(eventName, eventData);
      });
    };

    forward('route:registered', 'system:route:registered');
    forward('route:unregistered', 'system:route:unregistered');
    forward('routes:applied', 'system:routes:applied');
    forward('routes:cleared', 'system:routes:cleared');
    forward('adapter:registered', 'system:adapter:registered');
    forward('middleware:registered', 'system:middleware:registered');

    this.router.on('router:error', (eventData) => {
      const { error: crError, context: crContext } = eventData;
      this._handleInternalError(crError, { ...crContext, sourceDetail: 'CoreRouterEvent' });
      this.emit('system:error', eventData);
    });

    // Listen for route changes from CoreRouter to trigger dynamic refresh
    this.router.on('router:routes:changed', this._handleCoreRoutesChanged.bind(this));
  }

  /**
   * Handles the 'router:routes:changed' event from CoreRouter.
   * Instructs the active adapter to refresh its routes.
   * @private
   * @param {object} eventData - Data from the 'router:routes:changed' event.
   */
  async _handleCoreRoutesChanged(eventData) {
    this.deps.logger.info(`[RouterSystem] Detected route changes, attempting to refresh adapter. Details: ${JSON.stringify(eventData)}`);
    if (this.state.status !== SYSTEM_STATUS.RUNNING || !this.router || !this.router._routesAppliedOnce) {
      this.deps.logger.info('[RouterSystem] Router not running or routes not initially applied. Skipping dynamic refresh.');
      return;
    }

    if (!this._activeAdapterName) {
      this.deps.logger.warn('[RouterSystem] No active adapter set from applyRoutes. Cannot perform dynamic refresh.');
      return;
    }

    const adapter = this.router.adapters.get(this._activeAdapterName);
    if (!adapter) {
      await this.handleError(new RouterError(
        ErrorCodes.ROUTER.ADAPTER_NOT_FOUND,
        `Active adapter '${this._activeAdapterName}' not found in CoreRouter during dynamic refresh.`
      ), { phase: 'dynamic-route-refresh' });
      return;
    }

    if (typeof adapter.refreshRoutes !== 'function') {
      await this.handleError(new RouterError(
        ErrorCodes.ROUTER.INVALID_ADAPTER, // Or a more specific code like 'REFRESH_NOT_SUPPORTED'
        `Active adapter '${this._activeAdapterName}' does not support refreshRoutes.`
      ), { phase: 'dynamic-route-refresh' });
      return;
    }

    try {
      this.deps.logger.info(`[RouterSystem] Refreshing routes for adapter '${this._activeAdapterName}'.`);
      // The adapter's refreshRoutes method should use the framework instance it was initialized with or has access to.
      // It receives the full new list of routes.
      await adapter.refreshRoutes(this.router.getRoutes());
      this.recordMetric('routersystem.routes.refreshed', 1, { adapter: this._activeAdapterName, changeDetails: eventData?.action });
      this.emit('system:routes:refreshed', { adapter: this._activeAdapterName, timestamp: new Date().toISOString() });
    } catch (error) {
      await this.handleError(error, { // Error is likely already RouterError from adapter or CoreRouter
        phase: 'dynamic-route-refresh-execution',
        adapter: this._activeAdapterName,
        originalMessage: error.message
      });
      // Depending on severity, we might want to set RouterSystem state to ERROR or DEGRADED.
    }
  }

  async handleError(error, context = {}) {
    this.state.errors.push({ error, timestamp: new Date().toISOString(), context: context || {} });
    if (this.state.errors.length > (this.deps.config?.routerSystem?.maxErrorHistory || DEFAULT_CONFIG.MAX_ERROR_HISTORY)) {
      this.state.errors.shift();
    }
    this.recordMetric('routersystem.errors.operational', 1, { errorName: error.name, errorCode: error.code });
    await safeHandleError(this.deps.errorSystem, error, { source: 'RouterSystem', ...context });
    super.emit('system:error', { error, context, timestamp: new Date().toISOString() });
  }

  getRouter() {
    if (this.state.status !== SYSTEM_STATUS.RUNNING) {
      throw new RouterError(ErrorCodes.ROUTER.NOT_INITIALIZED, "RouterSystem is not running, cannot get router.", { state: this.state.status });
    }
    return this.router;
  }

  // --- Delegated CoreRouter Methods ---
  async registerRoute(moduleId, method, path, handler, options = {}) {
    if (!this.router) throw new RouterError(ErrorCodes.ROUTER.NOT_INITIALIZED, "Router not available in RouterSystem.");
    try {
      this.router.registerRoute(moduleId, method, path, handler, options);
      this.recordMetric('routersystem.routes.registered', 1, { moduleId, method: method.toUpperCase() });
      return this;
    } catch (error) {
      await this.handleError(error, { phase: 'registerRoute', moduleId, method, path });
      throw error;
    }
  }

  async registerVersionedRoute(moduleId, version, method, path, handler, options = {}) {
    if (!this.router) throw new RouterError(ErrorCodes.ROUTER.NOT_INITIALIZED, "Router not available in RouterSystem.");
    try {
      this.router.registerVersionedRoute(moduleId, version, method, path, handler, options);
      this.recordMetric('routersystem.routes.versioned.registered', 1, { moduleId, version, method: method.toUpperCase() });
      return this;
    } catch (error) {
      await this.handleError(error, { phase: 'registerVersionedRoute', moduleId, version, method, path });
      throw error;
    }
  }

  registerAdapter(name, adapter) {
    if (!this.router) throw new RouterError(ErrorCodes.ROUTER.NOT_INITIALIZED, "Router not available in RouterSystem.");
    try {
      this.router.registerAdapter(name, adapter);
      this.recordMetric('routersystem.adapters.registered', 1, { adapterName: name });
      return this;
    } catch (error) {
      this.handleError(error, { phase: 'registerAdapter', adapterName: name });
      throw error;
    }
  }

  registerMiddleware(name, handler, options = {}) {
    if (!this.router) throw new RouterError(ErrorCodes.ROUTER.NOT_INITIALIZED, "Router not available in RouterSystem.");
    try {
      this.router.registerMiddleware(name, handler, options);
      this.recordMetric('routersystem.middleware.registered', 1, { middlewareName: name });
      return this;
    } catch (error) {
      this.handleError(error, { phase: 'registerMiddleware', middlewareName: name });
      throw error;
    }
  }

  async applyRoutes(framework, adapterName) {
    if (!this.router) throw new RouterError(ErrorCodes.ROUTER.NOT_INITIALIZED, "Router not available in RouterSystem.");
    try {
      const result = await this.router.applyRoutes(framework, adapterName);
      this._activeAdapterName = adapterName; // Store active adapter
      this._activeFrameworkInstance = framework; // Store active framework
      this.recordMetric('routersystem.routes.applied', 1, { adapterName, count: this.router.getRoutes().length });
      return result;
    } catch (error) {
      await this.handleError(error, { phase: 'applyRoutes', adapterName });
      throw error;
    }
  }

  getRoutes() {
    if (!this.router) throw new RouterError(ErrorCodes.ROUTER.NOT_INITIALIZED, "Router not available in RouterSystem.");
    try { return this.router.getRoutes(); }
    catch (error) { this.handleError(error, { phase: 'getRoutes' }); throw error; }
  }
  getRoute(method, path) {
    if (!this.router) throw new RouterError(ErrorCodes.ROUTER.NOT_INITIALIZED, "Router not available in RouterSystem.");
    try { return this.router.getRoute(method, path); }
    catch (error) { this.handleError(error, { phase: 'getRoute', method, path }); throw error; }
  }
  getModuleRoutes(moduleId) {
    if (!this.router) throw new RouterError(ErrorCodes.ROUTER.NOT_INITIALIZED, "Router not available in RouterSystem.");
    try { return this.router.getModuleRoutes(moduleId); }
    catch (error) { this.handleError(error, { phase: 'getModuleRoutes', moduleId }); throw error; }
  }
  unregisterRoute(method, path) {
    if (!this.router) throw new RouterError(ErrorCodes.ROUTER.NOT_INITIALIZED, "Router not available in RouterSystem.");
    try {
      const result = this.router.unregisterRoute(method, path);
      if (result) this.recordMetric('routersystem.routes.unregistered', 1, { method: method.toUpperCase(), path });
      return result;
    } catch (error) { this.handleError(error, { phase: 'unregisterRoute', method, path }); throw error; }
  }
  unregisterModuleRoutes(moduleId) {
    if (!this.router) throw new RouterError(ErrorCodes.ROUTER.NOT_INITIALIZED, "Router not available in RouterSystem.");
    try {
      const count = this.router.unregisterModuleRoutes(moduleId);
      if (count > 0) this.recordMetric('routersystem.module.routes.unregistered', count, { moduleId });
      return count;
    } catch (error) { this.handleError(error, { phase: 'unregisterModuleRoutes', moduleId }); throw error; }
  }
  clearRoutes() {
    if (!this.router) throw new RouterError(ErrorCodes.ROUTER.NOT_INITIALIZED, "Router not available in RouterSystem.");
    try {
      const count = this.router.getRoutes().length;
      this.router.clearRoutes();
      if (count > 0) this.recordMetric('routersystem.routes.cleared', count);
      return this;
    } catch (error) { this.handleError(error, { phase: 'clearRoutes' }); throw error; }
  }
  generateOpenApiDoc(info = {}) {
    if (!this.router) throw new RouterError(ErrorCodes.ROUTER.NOT_INITIALIZED, "Router not available in RouterSystem.");
    try { return this.router.generateOpenApiDoc(info); }
    catch (error) { this.handleError(error, { phase: 'generateOpenApiDoc' }); throw error; }
  }

  async shutdown() {
    if (this.state.status === SYSTEM_STATUS.SHUTDOWN || this.state.status === SYSTEM_STATUS.SHUTTING_DOWN) {
      return;
    }
    super.emit(LIFECYCLE_EVENTS.SHUTTING_DOWN, { system: 'RouterSystem' });
    this.state.status = SYSTEM_STATUS.SHUTTING_DOWN;
    const shutdownStartTime = Date.now();
    this._activeAdapterName = null; // Reset active adapter info
    this._activeFrameworkInstance = null;

    try {
      if (this.router) {
        this.router.removeAllListeners('router:routes:changed'); // Clean up specific listener
        await this.router.shutdown();
      }
      super.removeAllListeners();

      this.router = null;
      this.state.status = SYSTEM_STATUS.SHUTDOWN;
      this.state.startTime = null;
      const shutdownTime = Date.now() - shutdownStartTime;
      this.recordMetric('routersystem.shutdown.time', shutdownTime);
      this.recordMetric('routersystem.shutdown.success', 1);
      this.deps.logger?.info('[RouterSystem] Shutdown complete.');

    } catch (error) {
      this.state.status = SYSTEM_STATUS.ERROR;
      this.recordMetric('routersystem.shutdown.failure', 1, { error: error.code });
      await this._handleInternalError(error, { phase: 'shutdown' });
      throw error instanceof RouterError ?
      error : new RouterError(
        ErrorCodes.ROUTER.SHUTDOWN_FAILED,
        "RouterSystem failed to shutdown.",
        { originalMessage: error.message },
        { cause: error }
      );
    }
  }

  // --- State, Health, Metrics ---
  // ... (Health Checks & Metrics methods remain the same as previously verified) ...
  setupDefaultHealthChecks() {
    this.registerHealthCheck('routersystem.state', this.checkSystemState.bind(this));
    this.registerHealthCheck('routersystem.corerouter', this.checkCoreRouterHealth.bind(this));
  }

  recordMetric(name, value, tags = {}) {
    this.state.metrics.set(name, { value, timestamp: Date.now(), tags });
  }

  getMetrics() {
    const metrics = {};
    for (const [name, data] of this.state.metrics) {
      metrics[name] = data;
    }
    return metrics;
  }

  registerHealthCheck(name, checkFn) {
    if (typeof checkFn !== 'function') {
        const err = new RouterError(ErrorCodes.ROUTER.INVALID_HEALTH_CHECK, `RouterSystem Health check '${name}' must be a function.`);
        this._handleInternalError(err);
        throw err;
    }
    this.state.healthChecks.set(name, checkFn);
  }

  async checkHealth() {
    const results = {};
    let overallStatus = SYSTEM_STATUS.HEALTHY;

    for (const [name, checkFn] of this.state.healthChecks) {
      try {
        const checkResult = await checkFn();
        results[name] = checkResult;
        if (checkResult.status !== SYSTEM_STATUS.HEALTHY) {
          overallStatus = (overallStatus === SYSTEM_STATUS.HEALTHY && checkResult.status === SYSTEM_STATUS.DEGRADED)
            ? SYSTEM_STATUS.DEGRADED
            : SYSTEM_STATUS.UNHEALTHY;
        }
      } catch (error) {
        results[name] = createStandardHealthCheckResult(SYSTEM_STATUS.UNHEALTHY, { error: 'Health check threw an exception' }, [error]);
        overallStatus = SYSTEM_STATUS.UNHEALTHY;
      }
    }
    return {
      name: this.constructor.name,
      version: RouterSystem.version,
      status: overallStatus,
      timestamp: new Date().toISOString(),
      uptime: this.state.startTime ? Date.now() - this.state.startTime : 0,
      errorCount: this.state.errors.length,
      checks: results,
    };
  }

  async checkSystemState() {
    return createStandardHealthCheckResult(
      this.state.status === SYSTEM_STATUS.RUNNING ? SYSTEM_STATUS.HEALTHY : SYSTEM_STATUS.UNHEALTHY,
      {
        currentStatus: this.state.status,
        uptime: this.state.startTime ? Date.now() - this.state.startTime : 0,
        internalErrorCount: this.state.errors.length
      }
    );
  }

  async checkCoreRouterHealth() {
    if (!this.router || typeof this.router.checkHealth !== 'function') {
      return createStandardHealthCheckResult(
        SYSTEM_STATUS.UNHEALTHY,
        { reason: 'CoreRouter not available or does not support health checks.' }
      );
    }
    try {
      return await this.router.checkHealth();
    } catch (error) {
      return createStandardHealthCheckResult(SYSTEM_STATUS.UNHEALTHY, { error: 'CoreRouter health check failed.' }, [error]);
    }
  }

  getSystemStatus() {
    return {
        name: this.constructor.name,
        version: RouterSystem.version,
        status: this.state.status,
        uptime: this.state.startTime ? Date.now() - this.state.startTime : 0,
        initialized: this.state.status === SYSTEM_STATUS.RUNNING,
        errorCount: this.state.errors.length,
        timestamp: new Date().toISOString(),
        coreRouterStatus: this.router ? this.router.getSystemStatus().status : (SYSTEM_STATUS.UNAVAILABLE || 'unavailable')
    };
  }
}

/**
 * Factory function for creating a RouterSystem instance.
 * @param {object} [deps={}] - Dependencies for the RouterSystem.
 * @returns {RouterSystem}
 */
export function createRouterSystem(deps = {}) {
  try {
    const defaultDeps = {
      errorSystem: deps.errorSystem || { handleError: async () => { console.error("Default No-Op ErrorSystem used in RouterSystem factory"); } },
      eventBusSystem: deps.eventBusSystem || { getEventBus: () => new EventEmitter() },
      config: deps.config || {},
    };
    return new RouterSystem({ ...defaultDeps, ...deps });
  } catch (error) {
    console.error("[RouterSystem Factory] Failed to create RouterSystem:", error);
    throw error instanceof RouterError ? error : new RouterError(
      ErrorCodes.ROUTER.CREATION_FAILED,
      "Failed to create RouterSystem instance.",
      { originalMessage: error.message },
      { cause: error }
    );
  }
}


// src/core/router/index.js

/**
 * @file src/core/router/index.js
 * @description Main public interface for the TSMIS Router System.
 * Exports CoreRouter, RouterSystem, RoutableModule, their factory functions,
 * and available framework integration adapters.
 */

import { CoreRouter } from './CoreRouter.js';
import { RouterSystem, createRouterSystem } from './RouterSystem.js';
import { RoutableModule, createRoutableModule } from './RoutableModule.js';

// Import integration components from ./integrations/index.js
// which now exports IRouterAdapter and FastifyAdapter
import {
  IRouterAdapter,
  FastifyAdapter
} from './integrations/index.js';

// Export all core router classes and their factory functions
export {
  CoreRouter,         // The core routing engine
  RouterSystem,       // The managing facade for CoreRouter
  createRouterSystem, // Factory for RouterSystem
  RoutableModule,     // Base class for modules that define routes
  createRoutableModule, // Factory for RoutableModule
};

// Export adapter interface and specific adapters
export {
  IRouterAdapter,     // Interface for all router adapters
  FastifyAdapter,     // Specific adapter for Fastify
  // ExpressAdapter, // Omitted as per user request
};

// Optional: A default export grouping the most common components,
// similar to the original structure, but adapted.
export default {
  CoreRouter,
  RouterSystem,
  createRouterSystem,
  RoutableModule,
  createRoutableModule,
  integrations: {
    IRouterAdapter,
    FastifyAdapter,
    // ExpressAdapter, // Omitted
  },
};


// src/core/router/integrations/IRouterAdapter.js

/**
 * @file src/core/router/integrations/IRouterAdapter.js
 * @description Defines the interface for framework-specific router adapters
 * that integrate with the CoreRouter.
 */

/**
 * @interface IRouterAdapter
 * @description Interface that framework-specific router adapters must implement.
 * These adapters are responsible for taking a list of standardized route definitions
 * from CoreRouter and applying them to a specific HTTP web framework instance.
 */
export class IRouterAdapter {
  /**
   * Applies an array of route definitions to the given web framework instance
   * for the initial setup.
   * Each route object in the array will typically include:
   * - `method`: (string) The HTTP method (e.g., 'GET', 'POST').
   * - `path`: (string) The route path.
   * - `handler`: (Function) The request handler function.
   * - `options`: (object) An object containing any framework-specific options,
   * schema definitions, middleware references, etc.
   * - `resolvedMiddleware`: (Array<Function>) An array of actual middleware handler
   * functions to be applied to this route, pre-resolved by CoreRouter.
   *
   * @param {object} framework - The instance of the web framework (e.g., Fastify app, Express app).
   * @param {Array<object>} routes - An array of route definition objects.
   * @returns {Promise<object|void>|object|void} The framework instance with routes applied, or nothing.
   * Return type can be Promise if adapter's operations are async.
   * @throws {Error} If the framework instance is invalid or if applying routes fails.
   */
  async applyRoutes(framework, routes) {
    if (this.constructor === IRouterAdapter) {
        throw new Error('IRouterAdapter.applyRoutes() is an abstract method and must be implemented by a subclass.');
    }
    throw new Error('IRouterAdapter.applyRoutes() must be implemented by subclass.');
  }

  /**
   * Dynamically refreshes the routes being served by the adapter.
   * This method is called when CoreRouter's route table has changed and the
   * live routes need to be updated without a full application restart.
   * The implementation will vary by adapter (e.g., updating an internal router,
   * re-registering a scoped plugin if the framework supports it).
   *
   * @param {Array<object>} routes - The new, complete list of route definition objects
   * from CoreRouter. Each object has the same structure as in `applyRoutes`.
   * @returns {Promise<void>|void}
   * @throws {Error} If refreshing routes fails.
   */
  async refreshRoutes(routes) {
    if (this.constructor === IRouterAdapter) {
        throw new Error('IRouterAdapter.refreshRoutes() is an abstract method and must be implemented by a subclass.');
    }
    throw new Error('IRouterAdapter.refreshRoutes() must be implemented by subclass.');
  }

  /**
   * Optional method for adapters to perform any necessary cleanup during shutdown.
   * For example, an adapter might need to release resources or unregister global handlers.
   *
   * @returns {Promise<void>|void}
   */
  async shutdown() {
    // Subclasses can override this if they have specific shutdown logic.
  }
}


// src/core/router/integrations/fastify/FastifyAdapter.js

/**
 * @file src/core/router/integrations/fastify/FastifyAdapter.js
 * @description Implements IRouterAdapter for the Fastify web framework,
 * supporting dynamic route updates.
 */

import { IRouterAdapter } from '../IRouterAdapter.js';
import { CoreError } from '../../../errors/CoreError.js';
import { ErrorCodes } from '../../../errors/ErrorCodes.js';
import findMyWay from 'find-my-way'; // Fastify's router

export class FastifyAdapter extends IRouterAdapter {
  /** @type {object|null} */
  logger = null;
  /** @type {object|null} */
  fastify = null; // Store the fastify instance
  /** @type {object|null} */
  internalRouter = null; // Instance of find-my-way
  /** @type {string} */
  gatewayPrefix = '/api'; // Configurable prefix for all dynamic routes. Can be empty string for root.
  /** @type {boolean} */
  gatewayInitialized = false;

  /**
   * Creates an instance of FastifyAdapter.
   * @param {object} [options={}] - Optional adapter configuration.
   * @param {object} [options.logger=console] - A logger instance.
   * @param {string} [options.gatewayPrefix='/api'] - A prefix for all routes handled by this adapter.
   */
  constructor(options = {}) {
    super();
    this.logger = options.logger || console;
    if (options.gatewayPrefix !== undefined) { // Allow empty string prefix
        this.gatewayPrefix = options.gatewayPrefix;
    }
    // Internal router will be initialized on first applyRoutes or explicit initialize
  }

  /**
   * Initializes the gateway route on the Fastify instance.
   * This should be called once.
   * @param {object} fastifyInstance - The Fastify framework instance.
   */
  _initializeGateway(fastifyInstance) {
    if (this.gatewayInitialized) return;

    this.fastify = fastifyInstance;
    this.internalRouter = findMyWay({
      defaultRoute: (req, res) => {
        // This is the 404 handler for routes *within* the gatewayPrefix
        // Fastify's own 404 will handle requests outside the gatewayPrefix
        this.logger.warn(`[FastifyAdapter] Internal 404: Route ${req.method} ${req.url} not found within gateway.`);
        // Fastify's `res` is actually a `Reply` object.
        const reply = res; // For clarity if `res` is used by find-my-way's handler signature
        reply.code(404).send({
          error: 'Not Found',
          message: `Route ${req.method} ${req.url} not found.`,
          statusCode: 404
        });
      },
      // find-my-way can also take a caseSensitive option, Fastify defaults to case-sensitive
    });

    const gatewayPath = this.gatewayPrefix ? `${this.gatewayPrefix}/*` : '/*';

    this.fastify.all(gatewayPath, this._gatewayHandler.bind(this));
    this.logger.info(`[FastifyAdapter] Gateway initialized. Listening for all methods on: ${gatewayPath}`);
    this.gatewayInitialized = true;
  }

  /**
   * Handles incoming requests to the gateway route and dispatches them
   * using the internal router.
   * @private
   * @param {object} request - Fastify request object.
   * @param {object} reply - Fastify reply object.
   */
  async _gatewayHandler(request, reply) {
    // find-my-way expects the path without the prefix if the prefix is part of the gateway.
    let searchPath = request.raw.url; // Use raw.url to get the full path with query string
    if (this.gatewayPrefix && searchPath.startsWith(this.gatewayPrefix)) {
        searchPath = searchPath.substring(this.gatewayPrefix.length);
        if (!searchPath.startsWith('/')) {
            searchPath = '/' + searchPath;
        }
    }
    // Remove query string for matching, find-my-way handles it separately if needed by route constraints
    const queryIndex = searchPath.indexOf('?');
    if (queryIndex !== -1) {
        searchPath = searchPath.substring(0, queryIndex);
    }


    const found = this.internalRouter.find(request.raw.method, searchPath);

    if (found && found.handler) {
      request.params = found.params; // Attach URL params from find-my-way
      const routeStore = found.store || {}; // TSMIS route options and middleware
      const tsmisHandler = found.handler;
      const resolvedMiddleware = routeStore.resolvedMiddleware || [];

      try {
        // Execute middleware
        for (const mw of resolvedMiddleware) {
          // Fastify preHandlers can be async and can send a response to terminate early
          // We need to await them and check if response has been sent.
          await mw(request, reply);
          if (reply.sent) return;
        }
        // Execute main handler
        await tsmisHandler(request, reply);
      } catch (error) {
        // Errors from middleware or handler will be caught by Fastify's global error handler
        // which should be set up by FastifyErrorHandler integration.
        this.logger.error(`[FastifyAdapter] Error in TSMIS handler/middleware for ${request.raw.method} ${request.raw.url}:`, error);
        reply.send(error); // Forward to Fastify's error handler
      }
    } else {
      // Let find-my-way's defaultRoute (our internal 404) handle it
      this.internalRouter.defaultRoute(request.raw, reply, {});
    }
  }


  /**
   * Applies an array of route definitions to the internal router.
   * Initializes the gateway on the first call.
   * @override
   */
  async applyRoutes(fastifyInstance, routes) {
    if (!fastifyInstance || typeof fastifyInstance.all !== 'function') {
      throw new CoreError(
        ErrorCodes.ROUTER.INVALID_FRAMEWORK,
        'Invalid Fastify instance provided to FastifyAdapter.'
      );
    }

    if (!this.gatewayInitialized) {
      this._initializeGateway(fastifyInstance);
    } else if (this.fastify !== fastifyInstance) {
        this.logger.warn('[FastifyAdapter] applyRoutes called with a new Fastify instance after initial setup. Re-initializing gateway. This might lead to multiple gateway routes if not managed carefully.');
        this._initializeGateway(fastifyInstance); // Re-initialize if fastify instance changed (e.g. testing)
    }
    
    // Clear existing routes from internal router and repopulate
    // This makes applyRoutes effectively a refresh as well.
    this.internalRouter = findMyWay({ defaultRoute: this.internalRouter.defaultRoute }); // Re-init with same 404
    
    this.logger.info(`[FastifyAdapter] Applying/Updating ${routes.length} routes to internal router.`);

    for (const route of routes) {
      const { method, path, handler, options = {}, resolvedMiddleware = [] } = route;
      
      // Path for find-my-way should be relative to the gatewayPrefix
      let internalPath = path;
      if (this.gatewayPrefix && path.startsWith(this.gatewayPrefix)) {
          internalPath = path.substring(this.gatewayPrefix.length);
          if (!internalPath.startsWith('/')) {
              internalPath = '/' + internalPath;
          }
      }
      if (internalPath === '') internalPath = '/'; // Root of the prefix

      // Store TSMIS options and middleware in the 'store' argument of find-my-way
      const routeStore = {
        tsmisOptions: options,
        resolvedMiddleware: resolvedMiddleware || []
      };

      try {
        this.internalRouter.on(method.toUpperCase(), internalPath, handler, routeStore);
        this.logger.debug(`[FastifyAdapter] Internal route added: ${method.toUpperCase()} ${internalPath}`);
      } catch (error) {
        const routeApplicationError = new CoreError(
          ErrorCodes.ROUTER.ROUTE_REGISTRATION_FAILED, // Using a ROUTER code
          `Failed to add route ${method} ${internalPath} to internal router.`,
          { routePath: internalPath, routeMethod: method, originalMessage: error.message },
          { cause: error }
        );
        this.logger.error(routeApplicationError.message, routeApplicationError.toJSON());
        throw routeApplicationError;
      }
    }
    this.logger.info(`[FastifyAdapter] Internal router updated with ${routes.length} routes.`);
    return fastifyInstance;
  }

  /**
   * Dynamically refreshes the routes in the internal router.
   * @override
   */
  async refreshRoutes(routes) {
    if (!this.gatewayInitialized || !this.internalRouter) {
      this.logger.warn('[FastifyAdapter] Gateway not initialized. Cannot refresh routes. Call applyRoutes first.');
      // Optionally, could call applyRoutes here if fastify instance is known and this is desired behavior.
      // For now, refreshRoutes assumes applyRoutes has run at least once.
      if (this.fastify) { // If we have the fastify instance, we can effectively do an apply.
          this.logger.info('[FastifyAdapter] Calling applyRoutes from refreshRoutes as gateway was not initialized or internal router missing.');
          return this.applyRoutes(this.fastify, routes);
      }
      throw new CoreError(ErrorCodes.ROUTER.NOT_INITIALIZED, "FastifyAdapter gateway not initialized, cannot refresh routes.");
    }

    this.logger.info(`[FastifyAdapter] Refreshing internal router with ${routes.length} routes.`);
    
    // Re-initialize the internal router and add all new routes
    // This is the simplest way to ensure a clean state.
    this.internalRouter = findMyWay({ defaultRoute: this.internalRouter.defaultRoute });

    for (const route of routes) {
      const { method, path, handler, options = {}, resolvedMiddleware = [] } = route;
      let internalPath = path;
      if (this.gatewayPrefix && path.startsWith(this.gatewayPrefix)) {
          internalPath = path.substring(this.gatewayPrefix.length);
           if (!internalPath.startsWith('/')) {
              internalPath = '/' + internalPath;
          }
      }
      if (internalPath === '') internalPath = '/';

      const routeStore = {
        tsmisOptions: options,
        resolvedMiddleware: resolvedMiddleware || []
      };
      try {
        this.internalRouter.on(method.toUpperCase(), internalPath, handler, routeStore);
      } catch (error) {
         // Log error but continue trying to add other routes during a refresh
        this.logger.error(`[FastifyAdapter] Error adding route ${method} ${internalPath} during refresh: ${error.message}`);
      }
    }
    this.logger.info(`[FastifyAdapter] Internal router refreshed successfully.`);
  }

  /**
   * Optional shutdown logic for the FastifyAdapter.
   */
  async shutdown() {
    this.logger.info('[FastifyAdapter] Shutdown.');
    this.internalRouter = null;
    this.fastify = null;
    this.gatewayInitialized = false;
  }
}


// src/core/router/integrations/fastify/index.js

/**
 * @file src/core/router/integrations/fastify/index.js
 * @description Barrel file for exporting Fastify integration components for the RouterSystem.
 */

import { FastifyAdapter } from './FastifyAdapter.js';

export {
  FastifyAdapter,
};

// Optional default export:
// export default FastifyAdapter; // If FastifyAdapter is the sole main export


// src/core/router/integrations/index.js

/**
 * @file src/core/router/integrations/index.js
 * @description Barrel file for exporting router integration interfaces and available adapters.
 */

import { IRouterAdapter } from './IRouterAdapter.js';
import { FastifyAdapter } from './fastify/index.js'; // Imports FastifyAdapter from its own index.js

export {
  IRouterAdapter,
  FastifyAdapter,
};

// Optional default export for grouping, if preferred:
// export default {
//   IRouterAdapter,
//   adapters: {
//     FastifyAdapter, // The only adapter currently
//   }
// };


// src/core/router/router-system.md

# TSMIS Routing System Documentation
Version: 2.1.0 (Refactored Core)

## Table of Contents

1.  [Introduction to the Routing System](#1-introduction-to-the-routing-system)
    * [1.1. Purpose & Philosophy](#11-purpose--philosophy)
    * [1.2. Key Components & Their Roles](#12-key-components--their-roles)
2.  [Component: `RoutableModule.js` - Defining Routes in Modules](#2-component-routablemodulejs---defining-routes-in-modules)
    * [2.1. Overview & Purpose](#21-overview--purpose)
    * [2.2. Key API for Route Definition](#22-key-api-for-route-definition)
        * [`registerRoute(method, path, handler, options)`](#registerroutemethod-path-handler-options)
        * [`registerVersionedRoute(version, method, path, handler, options)`](#registerversionedrouteversion-method-path-handler-options)
    * [2.3. Lifecycle Integration for Route Registration/Unregistration](#23-lifecycle-integration-for-route-registrationunregistration)
    * [2.4. Event Emission for Routes](#24-event-emission-for-routes)
3.  [Component: `CoreRouter.js` - The Routing Engine](#3-component-corerouterjs---the-routing-engine)
    * [3.1. Overview & Primary Responsibility](#31-overview--primary-responsibility)
    * [3.2. Key Functionalities & API (`CoreRouter`)](#32-key-functionalities--api-corerouter)
        * [3.2.1. Event-Driven Route Management](#321-event-driven-route-management)
        * [3.2.2. Route Registry & Conflict Detection](#322-route-registry--conflict-detection)
        * [3.2.3. Adapter Management (`registerAdapter`, `IRouterAdapter`)](#323-adapter-management-registeradapter-irouteradapter)
        * [3.2.4. Middleware Management (`registerMiddleware`, `getMiddlewareForRoute`)](#324-middleware-management-registermiddleware-getmiddlewareforroute)
        * [3.2.5. Applying Routes (`applyRoutes`)](#325-applying-routes-applyroutes)
        * [3.2.6. Dynamic Route Updates](#326-dynamic-route-updates)
        * [3.2.7. OpenAPI Documentation Generation (`generateOpenApiDoc`)](#327-openapi-documentation-generation-generateopenapidoc)
    * [3.3. State Management (`CoreRouter` Specifics)](#33-state-management-corerouter-specifics)
    * [3.4. Lifecycle Management (`CoreRouter` Specifics)](#34-lifecycle-management-corerouter-specifics)
    * [3.5. Error Handling within `CoreRouter`](#35-error-handling-within-corerouter)
    * [3.6. Event Integration (`CoreRouter` Specifics)](#36-event-integration-corerouter-specifics)
    * [3.7. Health Monitoring (`CoreRouter` Specifics)](#37-health-monitoring-corerouter-specifics)
    * [3.8. Metrics Tracking (`CoreRouter` Specifics)](#38-metrics-tracking-corerouter-specifics)
4.  [Component: `RouterSystem.js` - The Managing Facade](#4-component-routersystemjs---the-managing-facade)
    * [4.1. Overview & Primary Responsibility](#41-overview--primary-responsibility)
    * [4.2. Key Functionalities & API (`RouterSystem`)](#42-key-functionalities--api-routersystem)
        * [4.2.1. `initialize()` & `shutdown()`](#421-initialize--shutdown)
        * [4.2.2. `getRouter()`](#422-getrouter)
        * [4.2.3. Delegated `CoreRouter` Methods](#423-delegated-corerouter-methods)
        * [4.2.4. Handling Dynamic Route Updates](#424-handling-dynamic-route-updates)
    * [4.3. Adherence to Standardization Pillars (Recap for `RouterSystem`)](#43-adherence-to-standardization-pillars-recap-for-routersystem)
    * [4.4. State Management (`RouterSystem` Specifics)](#44-state-management-routersystem-specifics)
    * [4.5. Lifecycle Management (`RouterSystem` Specifics)](#45-lifecycle-management-routersystem-specifics)
    * [4.6. Error Handling within `RouterSystem`](#46-error-handling-within-routersystem)
    * [4.7. Event Integration (`RouterSystem` Specifics - Forwarding)](#47-event-integration-routersystem-specifics---forwarding)
    * [4.8. Health Monitoring (`RouterSystem` Specifics)](#48-health-monitoring-routersystem-specifics)
    * [4.9. Metrics Tracking (`RouterSystem` Specifics)](#49-metrics-tracking-routersystem-specifics)
    * [4.10. Static Factory (`createRouterSystem`)](#410-static-factory-createroutersystem)
5.  [Integrations (Routing System Level)](#5-integrations-routing-system-level)
6.  [Overall Routing Flow Diagram (Route Definition to Application)](#6-overall-routing-flow-diagram-route-definition-to-application)
7.  [Usage Examples & Best Practices](#7-usage-examples--best-practices)
    * [7.1. Defining Routes in a `RoutableModule`](#71-defining-routes-in-a-routablemodule)
    * [7.2. Registering a Framework Adapter (e.g., Fastify)](#72-registering-a-framework-adapter-eg-fastify)
    * [7.3. Registering and Using Middleware](#73-registering-and-using-middleware)
    * [7.4. Applying Routes to a Web Framework](#74-applying-routes-to-a-web-framework)
    * [7.5. Triggering Dynamic Route Updates (Development)](#75-triggering-dynamic-route-updates-development)
    * [7.6. Generating OpenAPI Documentation](#76-generating-openapi-documentation)
8.  [Testing Strategy Notes](#8-testing-strategy-notes)
9.  [Future Considerations & Potential Enhancements](#9-future-considerations--potential-enhancements)

---

## 1. Introduction to the Routing System

### 1.1. Purpose & Philosophy
The TSMIS Routing System provides a structured, flexible, and framework-agnostic way to define, manage, and serve HTTP routes. Its core philosophy is to decouple API endpoint definitions (within business modules) from the underlying HTTP web framework. This promotes modularity, testability, and framework interchangeability.
Key goals include:
* **Framework Agnosticism**.
* **Centralized Route Management** (`CoreRouter`).
* **Event-Driven Route Registration** (`RoutableModule` emitting events).
* **Pluggable Adapters** (`IRouterAdapter`).
* **Middleware Support**.
* **Dynamic Route Updates**: Allowing routes to be updated at runtime without a full application restart, especially beneficial during development.
* **API Documentation**: Automated OpenAPI specification generation.
* **Standardization**: Adherence to core TSMIS patterns.

### 1.2. Key Components & Their Roles
* **`RoutableModule.js`**: Extends `CoreModule` for modules defining HTTP routes. Provides `registerRoute()` and emits route events.
* **`CoreRouter.js`**: The routing engine. Listens for route events, maintains route registry, manages adapters and middleware, applies routes, and handles dynamic updates by signaling changes. Can generate OpenAPI docs.
* **`RouterSystem.js`**: High-level facade managing `CoreRouter`. Handles its lifecycle, simplifies common tasks, integrates routing with standard monitoring, and orchestrates dynamic route refreshes via adapters.
* **`IRouterAdapter.js`**: Interface for framework-specific adapters (e.g., `FastifyAdapter.js`). Adapters translate `CoreRouter` definitions to framework-specific calls and now include a `refreshRoutes` method.
* **`FastifyAdapter.js`**: Example `IRouterAdapter` for Fastify, now capable of dynamic route updates using an internal router.

---
## 2. Component: `RoutableModule.js` - Defining Routes in Modules

### 2.1. Overview & Purpose
`RoutableModule` extends `CoreModule`, enabling business modules to define their own HTTP API routes in a standardized way, decoupled from the central routing mechanism and web framework.

### 2.2. Key API for Route Definition
* **`registerRoute(method: string, path: string, handler: Function, options = {}): RoutableModule`**: Defines a route. Throws `RouterError` (using unprefixed codes like `INVALID_METHOD` from `ErrorCodes.ROUTER`) for invalid parameters.
* **`registerVersionedRoute(version: string | number, method: string, path: string, handler: Function, options = {}): RoutableModule`**: Convenience for versioned routes (e.g., `/api/v1`). Throws `RouterError` (using unprefixed code `INVALID_API_VERSION`) for invalid version.

### 2.3. Lifecycle Integration for Route Registration/Unregistration
* **`async onInitialize()`**: Typically calls `this.registerAllRoutes()` which emits `router.route.register` events for all defined routes.
* **`async onShutdown()`**: Emits `router.module.unregister` event to signal `CoreRouter` to remove routes for this module.

### 2.4. Event Emission for Routes
Events are broadcast via `CoreEventBus`:
* **`router.route.register`**: Payload: `{ moduleId, method, path, handler, options }`.
* **`router.route.unregister`**: Payload: `{ moduleId, method, path }`.
* **`router.module.unregister`**: Payload: `{ moduleId }`.

---
## 3. Component: `CoreRouter.js` - The Routing Engine

### 3.1. Overview & Primary Responsibility
`CoreRouter` is the central routing processor. It maintains the route registry, manages framework adapters and middleware, detects conflicts, applies routes to frameworks, and now signals when its route table has changed to support dynamic updates.

### 3.2. Key Functionalities & API (`CoreRouter`)

#### 3.2.1. Event-Driven Route Management
During `initialize()`, subscribes to events from `CoreEventBus`:
* `router.route.register` (`handleRouteRegistration`).
* `router.route.unregister` (`handleRouteUnregistration`).
* `router.routes.clear` (`handleRoutesClear`).
* `router.module.unregister` (`handleModuleUnregister`).

#### 3.2.2. Route Registry & Conflict Detection
Routes stored internally (Map `METHOD:path`). `registerRoute()` checks for conflicts. For dynamic updates, re-registering a route might be treated as an update by the adapter if `_routesAppliedOnce` is true, though direct conflict still logs a warning. Throws `RouterError` with unprefixed code `ROUTE_CONFLICT` for true conflicts before initial application.

#### 3.2.3. Adapter Management (`registerAdapter`, `IRouterAdapter`)
* `registerAdapter(name: string, adapter: IRouterAdapter)`: Registers adapters. `IRouterAdapter` now includes `refreshRoutes(routes)`. `RouterError` with unprefixed codes `INVALID_ADAPTER_NAME` or `INVALID_ADAPTER` is thrown for issues.

#### 3.2.4. Middleware Management (`registerMiddleware`, `getMiddlewareForRoute`)
* `registerMiddleware(name, handler, options)`: Registers named middleware. Throws `RouterError` with unprefixed codes `INVALID_MIDDLEWARE_NAME` or `INVALID_MIDDLEWARE` for issues.
* `getMiddlewareForRoute(route)`: Resolves and sorts applicable middleware.

#### 3.2.5. Applying Routes (`applyRoutes`)
* `async applyRoutes(framework, adapterName)`: Retrieves adapter, calls `adapter.applyRoutes()` with routes and their resolved middleware. Sets an internal flag `_routesAppliedOnce` to true on first successful application. Throws `RouterError` (using unprefixed codes like `NOT_INITIALIZED`, `INVALID_FRAMEWORK`, `ADAPTER_NOT_FOUND`, or `ROUTES_APPLICATION_FAILED`) on issues.

#### 3.2.6. Dynamic Route Updates
* **Event Emission**: When methods like `registerRoute`, `unregisterRoute`, `clearRoutes`, etc., modify the internal route table *after* `_routesAppliedOnce` is true and the router is running, `CoreRouter` emits a `router:routes:changed` event (locally via `super.emit`). This signals `RouterSystem` to trigger an adapter refresh.
* The `registerRoute` method, when `_routesAppliedOnce` is true, might allow overwriting (logging a warning) to facilitate updates, relying on the adapter's `refreshRoutes` to handle the new complete list.

#### 3.2.7. OpenAPI Documentation Generation (`generateOpenApiDoc`)
* `generateOpenApiDoc(info = {})`: Constructs OpenAPI 3.0 spec from the route registry.

### 3.3. State Management (`CoreRouter` Specifics)
Standard `this.state`. Manages maps: `this.routes`, `this.adapters`, `this.middleware`, `this.subscriptions`. Added `this._routesAppliedOnce: boolean`.

### 3.4. Lifecycle Management (`CoreRouter` Specifics)
* **`initialize()`**: Subscribes to route events. Emits lifecycle events.
* **`shutdown()`**: Unsubscribes, clears registries, resets `_routesAppliedOnce`. Emits lifecycle events.

### 3.5. Error Handling within `CoreRouter`
* `_handleInternalError` for operational errors (throws `RouterError` with unprefixed code `INTERNAL_SYSTEM_ERROR`). Reports via `safeHandleError`.
* Throws `RouterError` with specific unprefixed codes from `ErrorCodes.ROUTER` for API misuse or critical failures.

### 3.6. Event Integration (`CoreRouter` Specifics)
* **Subscribes to (on `CoreEventBus`)**: `router.route.*`, `router.module.unregister`.
* **Emits (Locally via `super.emit`)**: `route:registered`, `route:unregistered`, etc., and now `router:routes:changed`.

### 3.7. Health Monitoring (`CoreRouter` Specifics)
Provides `checkHealth()`. Default checks: `corerouter.state`, `corerouter.routes`, `corerouter.adapters`, `corerouter.middleware`.

### 3.8. Metrics Tracking (`CoreRouter` Specifics)
Records metrics for lifecycle, errors, route operations, adapter/middleware registrations, and now `corerouter.routes.changed.emitted`.

---
## 4. Component: `RouterSystem.js` - The Managing Facade

### 4.1. Overview & Primary Responsibility
`RouterSystem` is the high-level facade for routing. It orchestrates `CoreRouter`, handles its lifecycle, and integrates routing with application standards, including now managing dynamic route updates.

### 4.2. Key Functionalities & API (`RouterSystem`)

#### 4.2.1. `initialize()` & `shutdown()`
* **`async initialize(): Promise<RouterSystem>`**: Creates and initializes `CoreRouter`. Sets up event forwarding, including listening for `router:routes:changed` to trigger dynamic refreshes.
* **`async shutdown(): Promise<void>`**: Manages `CoreRouter` shutdown.

#### 4.2.2. `getRouter(): CoreRouter`
Provides access to the managed `CoreRouter` instance. Throws `RouterError` (unprefixed `NOT_INITIALIZED`) if not running.

#### 4.2.3. Delegated `CoreRouter` Methods
Exposes most of `CoreRouter`'s API (e.g., `registerAdapter`, `applyRoutes`). These methods delegate to `CoreRouter`, adding `RouterSystem`-level metrics and error handling. Errors from `CoreRouter` (already `RouterError` with prefixed codes) are caught and re-thrown after processing via `this.handleError()`.
* **`applyRoutes(framework, adapterName)`**: Now also stores the `adapterName` and `framework` instance as `this._activeAdapterName` and `this._activeFrameworkInstance` to be used for dynamic refreshes.

#### 4.2.4. Handling Dynamic Route Updates
* **`_setupEventForwardingAndDynamicRefresh()`**: In addition to forwarding operational events from `CoreRouter`, this method now also makes `RouterSystem` listen for the `router:routes:changed` event from its `CoreRouter` instance.
* **`async _handleCoreRoutesChanged(eventData)`**: This new private method is invoked when `router:routes:changed` is received. It checks if the system is in a valid state to refresh (router running, initial routes applied, active adapter known). If so, it retrieves the active adapter instance (e.g., `FastifyAdapter`) and calls its `adapter.refreshRoutes(this.router.getRoutes())` method. Errors during the refresh process are handled by `this.handleError()`.

### 4.3. Adherence to Standardization Pillars (Recap for `RouterSystem`)
* **State Management**: Standard `this.state`; holds `router` instance, `_activeAdapterName`, `_activeFrameworkInstance`.
* **Lifecycle Management**: Manages its own and `CoreRouter` lifecycle. Emits `LIFECYCLE_EVENTS`.
* **Error Handling**: `_handleInternalError` for own errors (throws `RouterError` with unprefixed code `SYSTEM_INTERNAL_ERROR`); `handleError` for delegated operations. Reports via `safeHandleError`.
* **Health Monitoring**: `checkHealth()` aggregates its state with `CoreRouter`'s health.
* **Metrics Tracking**: For lifecycle, errors, delegated operations, and now `routersystem.routes.refreshed`.
* **Factory Function**: `createRouterSystem(deps = {})`.

### 4.4. State Management (`RouterSystem` Specifics)
Includes `router: CoreRouter | null`, `_activeAdapterName: string | null`, `_activeFrameworkInstance: object | null`.

### 4.5. Lifecycle Management (`RouterSystem` Specifics)
* **`initialize()`**: Creates/inits `CoreRouter`, calls `_setupEventForwardingAndDynamicRefresh()`.
* **`shutdown()`**: Ensures `CoreRouter.shutdown()`, cleans up listeners, resets active adapter info.

### 4.6. Error Handling within `RouterSystem`
* **Internal Errors**: `_handleInternalError` for own issues.
* **Delegated Errors**: Catches errors from `this.router.*` calls, processes via `handleError`, re-throws.

### 4.7. Event Integration (`RouterSystem` Specifics - Forwarding)
`_setupEventForwardingAndDynamicRefresh()` listens to `CoreRouter` operational events and `router:routes:changed`. Re-emits operational events with a `system:` prefix and/or original name. Handles `router:routes:changed` to trigger adapter refresh.

### 4.8. Health Monitoring (`RouterSystem` Specifics)
Default checks:
* **`routersystem.state`**: Own status, uptime, errors.
* **`routersystem.corerouter`**: Calls `this.router.checkHealth()`.

### 4.9. Metrics Tracking (`RouterSystem` Specifics)
Records metrics for lifecycle, errors, high-level delegated operations, and `routersystem.routes.refreshed`.

### 4.10. Static Factory (`createRouterSystem`)
**`createRouterSystem(deps = {}): RouterSystem`**. Throws `RouterError` with unprefixed code `CREATION_FAILED` if factory fails.

---
## 5. Integrations (Routing System Level)
Integrates with:
* **`EventBusSystem` / `CoreEventBus`**: For route definition eventing.
* **HTTP Web Frameworks (e.g., Fastify)**: Via `IRouterAdapter` (which now supports `refreshRoutes`).
* **`ErrorSystem`**: All routing components report errors.
* **`ModuleSystem` & `CoreModule`**: Manages `RoutableModule`s.
* **`ContainerSystem`**: Manages `RouterSystem` and its dependencies.

---
## 6. Overall Routing Flow Diagram (Route Definition to Application)
**Routing System**: Overall Route Definition and Application Flow

```mermaid
graph TD
    subgraph ApplicationBootstrap [Application Bootstrap/Setup]
        direction TB
        AppSetup["App Setup Code"]
        HttpFrameworkInst["HTTP Framework Instance (e.g., Fastify)"]
    end

    subgraph RoutableModuleInstance [MyRoutableModule]
        direction TB
        RM_Define["Define Routes (this.registerRoute(...))"]
        RM_OnInit["onInitialize() calls this.registerAllRoutes()"]
        RM_Emit["_emitRouteRegistration()"]
    end

    subgraph EventSystem [EventBusSystem & CoreEventBus]
        direction TB
        EBSys["EventBusSystem"]
        CEBus["CoreEventBus"]
        EBSys -- Provides --> CEBus
    end

    subgraph RouterSystemFacade [RouterSystem Facade]
        direction TB
        RS["RouterSystem"]
        RS_State[("this.state (System)")]
        RS_ActiveAdapter[("Active Adapter Ref")]
    end
    
    subgraph CoreRouterEngine [CoreRouter Engine]
        direction TB
        CR["CoreRouter"]
        CR_State[("this.state (Router)")]
        CR_Routes[("Route Registry")]
        CR_Adapters[("Adapter Registry")]
        CR_Mw[("Middleware Registry")]
        CR_AppliedFlag[("_routesAppliedOnce")]
    end

    %% Initialization
    AppSetup -- Creates & Initializes --> RS;
    RS -- Creates & Initializes --> CR;
    CR -- Subscribes to 'router.route.register', etc. --> CEBus;
    
    %% Module Route Definition
    RM_OnInit --> RM_Emit;
    RM_Emit -- "Emits 'router.route.register' event" --> CEBus;
    
    %% CoreRouter Processes Event
    CEBus -- Delivers Event --> CR;
    CR -- "handleRouteRegistration(event)" --> CR_Routes;
    CR_Routes -- "Stores route" --> CR_Routes;
    CR -- "If running & applied, emits 'router:routes:changed'" --> RS; %% CoreRouter emits to RouterSystem

    %% RouterSystem Handles Change (Dynamic Update Path)
    RS -- "Receives 'router:routes:changed'" --> RS;
    RS -- "_handleCoreRoutesChanged()" --> RS_ActiveAdapter;
    RS_ActiveAdapter -- "Calls adapter.refreshRoutes(allRoutes)" --> AdapterInst["Specific Adapter (e.g., FastifyAdapter)"];
    AdapterInst -- "Updates its internal router" --> AdapterInternalRouter["Adapter's Internal Router"];

    %% Application Applies Routes (Initial or Manual Full Apply)
    AppSetup -- "1. routerSystem.registerAdapter('fwKey', AdapterClass)" --> RS;
    RS -- Delegates --> CR;
    CR -- "Stores adapter" --> CR_Adapters;
    
    AppSetup -- "2. routerSystem.applyRoutes(HttpFrameworkInst, 'fwKey')" --> RS;
    RS -- "Stores active adapter/fw" --> RS_ActiveAdapter;
    RS -- Delegates to --> CR;
    CR -- "applyRoutes(HttpFrameworkInst, 'fwKey')" --> AdapterInst;
    AdapterInst -- "Populates its internal router & configures HttpFrameworkInst gateway" --> HttpFrameworkInst;
    CR -- "Sets _routesAppliedOnce = true" --> CR_AppliedFlag;


    classDef system fill:#D6EAF8,stroke:#5DADE2,stroke-width:2px;
    classDef module fill:#E8F8F5,stroke:#76D7C4,stroke-width:2px;
    classDef bus fill:#FEF9E7,stroke:#F7DC6F,stroke-width:2px;
    classDef stateNode fill:#f9f,stroke:#333,stroke-width:2px;
    classDef process fill:#E9D8FD,stroke:#8E44AD,stroke-width:1px;


    class RS, CR, AdapterInst system;
    class RM_OnInit, RM_Define, RM_Emit module;
    class EBSys, CEBus bus;
    class RS_State, CR_State, CR_Routes, CR_Adapters, CR_Mw, CR_AppliedFlag, RS_ActiveAdapter stateNode;
    class AppSetup, HttpFrameworkInst, AdapterInternalRouter process;
```

(Diagram to also conceptually include path for `router:routes:changed` -> `RouterSystem` -> `Adapter.refreshRoutes`)

---
## 7. Usage Examples & Best Practices

### 7.1. Defining Routes in a `RoutableModule`
Modules extend `RoutableModule` and use `this.registerRoute()` typically in `onInitialize()`. Errors thrown (e.g., `RouterError` with unprefixed code `INVALID_METHOD`) use the new code strategy.

### 7.2. Registering a Framework Adapter (e.g., Fastify)
Register adapter with `RouterSystem`. The adapter should implement `IRouterAdapter` including `refreshRoutes`.
**RouterSystem**: Registering a Framework Adapter Example (Updated)
```javascript
// // In application bootstrap, after RouterSystem and ErrorSystem are initialized
// // Assuming 'container' is your initialized ContainerSystem instance
// // import { FastifyAdapter } from './core/router/integrations/fastify/FastifyAdapter.js'; // Path to your adapter
// // import { ErrorCodes } from './core/errors/ErrorCodes.js'; // For error checking, if needed
// // import { RouterError } from './core/errors/index.js'; // For error checking, if needed

// async function setupRouterAdapter(container) {
//   try {
//     const routerSystem = await container.resolve('routerSystem');
//     const logger = await container.resolve('logger'); // Assuming a logger is registered

//     // Create an instance of your adapter
//     // The FastifyAdapter constructor now accepts options like gatewayPrefix
//     const fastifyAdapter = new FastifyAdapter({ 
//         logger,
//         gatewayPrefix: '/api' // Example prefix for all routes handled by this adapter
//     });

//     // Register the adapter with RouterSystem
//     routerSystem.registerAdapter('fastifyHttp', fastifyAdapter); // Use a descriptive name
//     logger.info('[AppSetup] FastifyAdapter registered with RouterSystem as "fastifyHttp".');

//   } catch (error) {
//     // Handle error (e.g., RouterSystem not resolved, adapter registration failed)
//     // error.code will be the fully prefixed code, e.g., ROUTER_INVALID_ADAPTER
//     const errorSystem = await container.resolve('errorSystem');
//     await errorSystem.handleError(error, {
//       source: 'setupRouterAdapter',
//       message: `Failed to setup router adapter. Error code: ${error.code}`
//     });
//     throw error; // Or handle more gracefully
//   }
// }

// // setupRouterAdapter(container);
```

### 7.3. Registering and Using Middleware
Register named middleware with `RouterSystem` (delegates to `CoreRouter`). Apply by name in route options.
**RouterSystem**: Registering and Using Middleware Example (Updated)

```javascript
// // In application bootstrap or a dedicated middleware setup file
// // Assuming 'routerSystem' is an initialized RouterSystem instance from container
// // import { ErrorCodes } from './core/errors/ErrorCodes.js'; // For specific error codes
// // import { AuthError } from './core/errors/index.js';     // Example of a specific error type

// // 1. Define Middleware Handlers
// async function simpleLoggerMiddleware(request, reply) {
//   // Assuming logger is attached to request by Fastify or another middleware
//   request.log.info(`Request received for: ${request.method} ${request.url}`);
//   // For Fastify, calling done() is not needed for async handlers unless there's an error.
//   // If you pass an error to done(), Fastify handles it. Otherwise, just let the promise resolve.
// }

// async function authenticationMiddleware(request, reply) {
//   // const authService = await request.diContainer.resolve('authService'); // Example: DI per request
//   const token = request.headers['authorization']?.split(' ')[1];
//   let userIsValid = false; // Assume false

//   // if (token && authService) {
//   //   userIsValid = await authService.validateTokenAndGetUser(token);
//   //   if (userIsValid) request.user = userIsValid; // Attach user to request
//   // }
//   
//   if (!userIsValid) {
//     request.log.warn('Authentication failed: No token or invalid token.');
//     // Throwing a specific error that FastifyErrorHandler can map
//     // ErrorCodes.AUTH.UNAUTHORIZED is 'UNAUTHORIZED'
//     throw new AuthError( 
//         ErrorCodes.AUTH.UNAUTHORIZED, 
//         'Authentication required.'
//     ); // AuthError constructor will prefix to AUTH_UNAUTHORIZED
//     // The global FastifyErrorHandler (setup via ErrorSystem) will catch this and send 401
//   }
//   request.log.info('Authentication successful for middleware.');
// }

// // 2. Register Middleware with RouterSystem (delegates to CoreRouter)
// // routerSystem.registerMiddleware('requestLogger', simpleLoggerMiddleware, { order: 10 });
// // routerSystem.registerMiddleware('authRequired', authenticationMiddleware, {
// //   order: 100,
// //   // paths: ['/api/v1/secure/*'] // Example: apply only to paths under /api/v1/secure/
// // });

// // 3. Applying Middleware in a RoutableModule
// // Inside a RoutableModule (e.g., SecureDataModule.js onInitialize method):
// // this.registerRoute('GET', '/secure/data', this.handleGetSecureData, {
// //   summary: 'Get secure data, auth required',
// //   middleware: ['requestLogger', 'authRequired'] // Names of registered middleware
// // });
// //
// // this.registerRoute('GET', '/public/data', this.handleGetPublicData, {
// //   summary: 'Get public data',
// //   middleware: ['requestLogger'] // Only logger for this one
// // });
```

### 7.4. Applying Routes to a Web Framework
Call `routerSystem.applyRoutes(frameworkInstance, adapterName)` during bootstrap.
**RouterSystem**: Applying Routes to Fastify Example (Updated)

```javascript
// // In application bootstrap, after RouterSystem is initialized,
// // modules have emitted their routes, and an adapter is registered.
// // Assuming 'container' is your initialized ContainerSystem instance
// // import Fastify from 'fastify';
// // import { FastifyAdapter } from './core/router/integrations/fastify/FastifyAdapter.js';
// // import { ErrorCodes } from './core/errors/ErrorCodes.js';
// // import { RouterError } from './core/errors/index.js';

// async function startHttpServer(container) {
//   try {
//     const routerSystem = await container.resolve('routerSystem');
//     const appConfig = await container.resolve('appConfig'); // Assuming config component
//     const logger = await container.resolve('logger');
//     const errorSystem = await container.resolve('errorSystem'); // For Fastify error handler setup

//     const fastifyApp = Fastify({
//       logger: logger, // Use your application's logger instance if compatible
//       requestIdHeader: 'x-request-id',
//       // Consider adding a custom child logger for requests with request IDs
//     });

//     // Ensure ErrorSystem's FastifyErrorHandler is set up for this fastifyApp instance
//     // This should have happened when ErrorSystem was initialized and registerIntegration was called.
//     // Example conceptual check (actual check might differ):
//     // if (!errorSystem.integrations.has('fastifyMain')) { // Assuming it was registered with this name
//     //    logger.warn('[AppSetup] FastifyErrorHandler integration not registered with ErrorSystem. Global errors might not be handled consistently.');
//     //    // Potentially register it here if not done, or throw error
//     // }

//     // Ensure router adapter is registered with RouterSystem
//     // This would typically be done before calling applyRoutes if not already.
//     if (!routerSystem.getRouter().adapters.has('fastifyHttp')) {
//       routerSystem.registerAdapter('fastifyHttp', new FastifyAdapter({ logger, gatewayPrefix: '/api' }));
//       logger.info('[AppSetup] FastifyAdapter registered on-the-fly.');
//     }

//     // Apply all routes known to CoreRouter (via RouterSystem) to the Fastify instance
//     // This will now use the FastifyAdapter's logic which sets up a gateway and internal router.
//     await routerSystem.applyRoutes(fastifyApp, 'fastifyHttp');
//     logger.info('[AppSetup] All TSMIS routes applied to Fastify via adapter gateway.');

//     await fastifyApp.listen({ port: appConfig.port || 3000, host: '0.0.0.0' });
//     // Fastify automatically logs listening address if logger is enabled

//   } catch (error) {
//     console.error('[AppSetup] CRITICAL: Failed to start HTTP server or apply routes:', error);
//     // error.code will be the fully prefixed code, e.g., ROUTER_ADAPTER_NOT_FOUND
//     // Example error checking:
//     // if (error.code === `ROUTER_${ErrorCodes.ROUTER.ADAPTER_NOT_FOUND}`) {
//     //   console.error("The 'fastifyHttp' adapter was not found!");
//     // }
//     // const errorSystemInstance = container.instances?.get('errorSystem'); // Be careful with direct instance access
//     // if (errorSystemInstance) {
//     //   await errorSystemInstance.handleError(error, { source: 'startHttpServer', criticality: 'high' });
//     // }
//     process.exit(1);
//   }
// }
// // startHttpServer(container);
```

### 7.5. Triggering Dynamic Route Updates (Development)
This section is new and describes the high-level process:
1.  **File Changes**: Developer modifies route definitions in a `RoutableModule` file.
2.  **File Watcher (External Tool)**: A development tool (e.g., Nodemon with script execution, custom `chokidar` watcher) detects the change.
3.  **Re-registration Trigger**: The watcher script interacts with the running TSMIS application to:
    * Get the specific `RoutableModule` instance (e.g., via `moduleSystem.resolve()`).
    * Call methods on the module to unregister its old routes and register the new/modified ones (e.g., a new `moduleInstance.reloadRoutes()` method or separate calls to `unregisterRoute` and `registerRoute`).
4.  **Core System Reaction**:
    * The module's calls to `registerRoute`/`unregisterRoute` update `CoreRouter`'s internal route list.
    * `CoreRouter` emits `router:routes:changed`.
    * `RouterSystem` receives this event and calls `activeAdapter.refreshRoutes()` with the complete new list of routes from `CoreRouter`.
    * The adapter (e.g., `FastifyAdapter`) updates its internal routing mechanism, making the changes live without an application restart.
*This mechanism provides a development-time convenience. Production route changes usually follow a more controlled deployment process.*

### 7.6. Generating OpenAPI Documentation
Call `routerSystem.generateOpenApiDoc(info)`.
**RouterSystem**: Generating OpenAPI Documentation Example (Updated)

```javascript
// // Assuming 'routerSystem' is an initialized RouterSystem instance
// // Assuming 'appConfig' holds application metadata

// async function generateAndServeOpenApiSpec(routerSystem, appConfig) {
//   try {
//     const openApiDocument = routerSystem.generateOpenApiDoc({
//       title: appConfig.appName || 'TSMIS API',
//       version: appConfig.appVersion || '1.0.0', // Assuming appConfig has appVersion
//       description: 'API documentation for the TSMIS application.',
//       components: {
//         schemas: {
//           // ExampleError: {
//           //   type: 'object',
//           //   properties: {
//           //     code: { type: 'string', example: 'VALIDATION_INVALID_INPUT' },
//           //     message: { type: 'string' },
//           //     details: { type: 'object', additionalProperties: true }
//           //   }
//           // }
//         }
//       }
//     });
//     // 1. Save to a file (example)
//     // import fs from 'fs/promises';
//     // await fs.writeFile('openapi.json', JSON.stringify(openApiDocument, null, 2));
//     // console.log('OpenAPI specification written to openapi.json');
//     // 2. Or serve via an API endpoint
//     return openApiDocument;

//   } catch (error) {
//     console.error('Failed to generate OpenAPI document:', error);
//     // Example: error.code would be prefixed if it's a RouterError
//     // await routerSystem.handleError(error, { operation: 'generateOpenApiDoc' });
//     return null;
//   }
// }
```

**Best Practices:**
* Decouple route definition in modules.
* Use `static dependencies` for handlers.
* Clear route paths/methods.
* Use schema validation via route options.
* Leverage middleware for cross-cutting concerns.
* For development, integrate a file watcher to trigger route re-registration for dynamic updates.

---
## 8. Testing Strategy Notes
* **`RoutableModule`**: Test route definition and event emission.
* **`CoreRouter`**: Test route registration/conflict, adapter/middleware management, event handling. Test new `router:routes:changed` emission. Test `applyRoutes` and `generateOpenApiDoc`.
* **`RouterSystem`**: Test `CoreRouter` lifecycle management. Test delegated methods. Test new logic for listening to `router:routes:changed` and calling `adapter.refreshRoutes` (with a mock adapter).
* **Adapters (e.g., `FastifyAdapter`)**: Test `applyRoutes` and the new `refreshRoutes` method thoroughly with a mock framework and route sets to ensure the internal router is updated and the gateway functions correctly.

---
## 9. Future Considerations & Potential Enhancements
(Original points are still valid.)
* **Advanced Route Matching**.
* **More Granular Dynamic Updates**: Beyond full refresh, explore adding/removing single routes from live adapters if framework and adapter design permit efficiently. (The current `refreshRoutes` takes the full list, which is simpler to implement robustly).
* **Enhanced Request/Response Validation**.
* **Performance Optimizations** for large route sets.
* **More Granular Middleware Control**.
* **Additional Framework Adapters**.

